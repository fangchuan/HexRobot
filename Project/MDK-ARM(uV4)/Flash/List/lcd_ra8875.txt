; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\lcd_ra8875.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\lcd_ra8875.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\lcd_ra8875.crf ..\..\User\bsp_stm32f4xx\src\LCD_RA8875.c]
                          THUMB

                          AREA ||i.BTE_SetOperateCode||, CODE, READONLY, ALIGN=1

                  BTE_SetOperateCode PROC
;;;588    */
;;;589    static void BTE_SetOperateCode(uint8_t _ucOperate)
000000  b510              PUSH     {r4,lr}
;;;590    {
000002  4604              MOV      r4,r0
;;;591    	/*  设定BTE 操作码和光栅运算码  */
;;;592    	RA8875_WriteReg(0x51, _ucOperate);
000004  4621              MOV      r1,r4
000006  2051              MOVS     r0,#0x51
000008  f7fffffe          BL       RA8875_WriteReg
;;;593    }
00000c  bd10              POP      {r4,pc}
;;;594    
                          ENDP


                          AREA ||i.BTE_SetTarBlock||, CODE, READONLY, ALIGN=1

                  BTE_SetTarBlock PROC
;;;555    */
;;;556    static void BTE_SetTarBlock(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t _ucLayer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;557    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;558    	/* 设置起点坐标 */
;;;559    	RA8875_WriteReg(0x58, _usX);
000010  b2e9              UXTB     r1,r5
000012  2058              MOVS     r0,#0x58
000014  f7fffffe          BL       RA8875_WriteReg
;;;560    	RA8875_WriteReg(0x59, _usX >> 8);
000018  1229              ASRS     r1,r5,#8
00001a  2059              MOVS     r0,#0x59
00001c  f7fffffe          BL       RA8875_WriteReg
;;;561    
;;;562    	RA8875_WriteReg(0x5A, _usY);
000020  b2e1              UXTB     r1,r4
000022  205a              MOVS     r0,#0x5a
000024  f7fffffe          BL       RA8875_WriteReg
;;;563    	if (_ucLayer == 0)	/* 图层2 */
000028  f1b80f00          CMP      r8,#0
00002c  d104              BNE      |L2.56|
;;;564    	{
;;;565    		RA8875_WriteReg(0x5B, _usY >> 8);
00002e  1221              ASRS     r1,r4,#8
000030  205b              MOVS     r0,#0x5b
000032  f7fffffe          BL       RA8875_WriteReg
000036  e005              B        |L2.68|
                  |L2.56|
;;;566    	}
;;;567    	else
;;;568    	{
;;;569    		RA8875_WriteReg(0x5B, (1 << 7) | (_usY >> 8));	/* Bit7 表示图层， 0 图层1； 1 图层2*/
000038  2080              MOVS     r0,#0x80
00003a  ea402124          ORR      r1,r0,r4,ASR #8
00003e  205b              MOVS     r0,#0x5b
000040  f7fffffe          BL       RA8875_WriteReg
                  |L2.68|
;;;570    	}
;;;571    
;;;572    	/* 设置区块宽度 */
;;;573    	RA8875_WriteReg(0x5C, _usWidth);
000044  b2f9              UXTB     r1,r7
000046  205c              MOVS     r0,#0x5c
000048  f7fffffe          BL       RA8875_WriteReg
;;;574    	RA8875_WriteReg(0x5D, _usWidth >> 8);
00004c  1239              ASRS     r1,r7,#8
00004e  205d              MOVS     r0,#0x5d
000050  f7fffffe          BL       RA8875_WriteReg
;;;575    
;;;576    	/* 设置区块高度 */
;;;577    	RA8875_WriteReg(0x5E, _usHeight);
000054  b2f1              UXTB     r1,r6
000056  205e              MOVS     r0,#0x5e
000058  f7fffffe          BL       RA8875_WriteReg
;;;578    	RA8875_WriteReg(0x5F, _usHeight >> 8);
00005c  1231              ASRS     r1,r6,#8
00005e  205f              MOVS     r0,#0x5f
000060  f7fffffe          BL       RA8875_WriteReg
;;;579    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;580    
                          ENDP


                          AREA ||i.BTE_Start||, CODE, READONLY, ALIGN=2

                  BTE_Start PROC
;;;633    */
;;;634    static void BTE_Start(void)
000000  b510              PUSH     {r4,lr}
;;;635    {
;;;636    	s_ucRA8875Busy = 1;
000002  2001              MOVS     r0,#1
000004  4904              LDR      r1,|L3.24|
000006  7008              STRB     r0,[r1,#0]
;;;637    	/* RA8875_WriteReg(0x50, 0x80);  不能使用这个函数，因为内部已经操作了 s_ucRA8875Busy 标志 */
;;;638    	RA8875_WriteCmd(0x50);	/* 设置寄存器地址 */
000008  2050              MOVS     r0,#0x50
00000a  f7fffffe          BL       RA8875_WriteCmd
;;;639    	RA8875_WriteData(0x80);	/* 写入寄存器值 */
00000e  2080              MOVS     r0,#0x80
000010  f7fffffe          BL       RA8875_WriteData
;;;640    }
000014  bd10              POP      {r4,pc}
;;;641    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      s_ucRA8875Busy

                          AREA ||i.BTE_Wait||, CODE, READONLY, ALIGN=2

                  BTE_Wait PROC
;;;649    */
;;;650    static void BTE_Wait(void)
000000  b510              PUSH     {r4,lr}
;;;651    {
;;;652    	uint32_t i;
;;;653    	
;;;654    	//while ((RA8875_ReadStatus() & 0x40) == 0x40);
;;;655    	for (i = 0; i < 100000; i++)
000002  2400              MOVS     r4,#0
000004  e006              B        |L4.20|
                  |L4.6|
;;;656    	{
;;;657    		if ((RA8875_ReadStatus() & 0x40) == 0)
000006  f7fffffe          BL       RA8875_ReadStatus
00000a  f0000040          AND      r0,r0,#0x40
00000e  b900              CBNZ     r0,|L4.18|
;;;658    		{
;;;659    			break;
000010  e003              B        |L4.26|
                  |L4.18|
000012  1c64              ADDS     r4,r4,#1              ;655
                  |L4.20|
000014  4803              LDR      r0,|L4.36|
000016  4284              CMP      r4,r0                 ;655
000018  d3f5              BCC      |L4.6|
                  |L4.26|
00001a  bf00              NOP      
;;;660    		}
;;;661    	}
;;;662    	s_ucRA8875Busy = 0;
00001c  2000              MOVS     r0,#0
00001e  4902              LDR      r1,|L4.40|
000020  7008              STRB     r0,[r1,#0]
;;;663    }
000022  bd10              POP      {r4,pc}
;;;664    
                          ENDP

                  |L4.36|
                          DCD      0x000186a0
                  |L4.40|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_ClrScr||, CODE, READONLY, ALIGN=2

                  RA8875_ClrScr PROC
;;;1021   */
;;;1022   void RA8875_ClrScr(uint16_t _usColor)
000000  b538              PUSH     {r3-r5,lr}
;;;1023   {
000002  4604              MOV      r4,r0
;;;1024   	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */
;;;1025   
;;;1026   	/* 单色填满功能, 中文pdf 第162页
;;;1027   	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。
;;;1028   
;;;1029   	操作步骤:
;;;1030   		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
;;;1031   		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
;;;1032   		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
;;;1033   		4. 设定前景色  REG[63h], [64h], [65h]
;;;1034   		5. 开启BTE 功能  REG[50h] Bit7 = 1
;;;1035   		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
;;;1036   	*/
;;;1037   	BTE_SetTarBlock(s_WinX, s_WinY, s_WinHeight, s_WinWidth, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  480a              LDR      r0,|L5.52|
00000a  8803              LDRH     r3,[r0,#0]  ; s_WinWidth
00000c  480a              LDR      r0,|L5.56|
00000e  8802              LDRH     r2,[r0,#0]  ; s_WinHeight
000010  480a              LDR      r0,|L5.60|
000012  8801              LDRH     r1,[r0,#0]  ; s_WinY
000014  480a              LDR      r0,|L5.64|
000016  8800              LDRH     r0,[r0,#0]  ; s_WinX
000018  f7fffffe          BL       BTE_SetTarBlock
;;;1038   	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
00001c  200c              MOVS     r0,#0xc
00001e  f7fffffe          BL       BTE_SetOperateCode
;;;1039   	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RA8875_SetFrontColor
;;;1040   	BTE_Start();					/* 开启BTE 功能 */
000028  f7fffffe          BL       BTE_Start
;;;1041   	BTE_Wait();						/* 等待操作结束 */
00002c  f7fffffe          BL       BTE_Wait
;;;1042   }
000030  bd38              POP      {r3-r5,pc}
;;;1043   
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      s_WinWidth
                  |L5.56|
                          DCD      s_WinHeight
                  |L5.60|
                          DCD      s_WinY
                  |L5.64|
                          DCD      s_WinX

                          AREA ||i.RA8875_CtrlGPO||, CODE, READONLY, ALIGN=1

                  RA8875_CtrlGPO PROC
;;;1945   */
;;;1946   void RA8875_CtrlGPO(uint8_t _pin, uint8_t _value)
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1948   	RA8875_WriteReg(0x13, _value << _pin);
000006  fa05f004          LSL      r0,r5,r4
00000a  b2c1              UXTB     r1,r0
00000c  2013              MOVS     r0,#0x13
00000e  f7fffffe          BL       RA8875_WriteReg
;;;1949   }
000012  bd70              POP      {r4-r6,pc}
;;;1950   
                          ENDP


                          AREA ||i.RA8875_DispAscii||, CODE, READONLY, ALIGN=2

                  RA8875_DispAscii PROC
;;;1635   */
;;;1636   void RA8875_DispAscii(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1637   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1638   	/*
;;;1639   		RA8875 内建8x16 点的ASCII 字型ROM，提供使用者更方便的方式用特定编码 (Code) 输入文
;;;1640   		字。内建的字集支持ISO/IEC 8859-1~4 编码标准，此外，使用者可以透过REG[60h~62h] 选择
;;;1641   		文字前景颜色，以及透过REG[63h~65h] 选择背景颜色.
;;;1642   
;;;1643   		ISO/IEC 8859-1，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。
;;;1644   		它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。
;;;1645   
;;;1646   		ISO/IEC 8859-2 Latin-2或“中欧语言”，是国际标准化组织内ISO/IEC 8859的其中一个8位字符集 .
;;;1647   		ISO/IEC 8859-3 南欧语言字符集
;;;1648   		ISO/IEC 8859-4 北欧语言字符集
;;;1649   	*/
;;;1650   
;;;1651   	/*
;;;1652   	(1) Text mode  REG[40h] bit7=1
;;;1653   	(2) Internal Font ROM Select   REG[21h] bit7=0, bit5=0
;;;1654   	(3) Font foreground and background color Select  REG[63h~65h], REG[60h~62h]
;;;1655   	(4) Write the font Code  CMD_WR[02h]    DATA_WR[font_code]
;;;1656   	*/
;;;1657   	
;;;1658   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1659   
;;;1660   	s_reg_40H |= (1 << 7);
000010  481a              LDR      r0,|L7.124|
000012  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000014  f0400080          ORR      r0,r0,#0x80
000018  4918              LDR      r1,|L7.124|
00001a  7008              STRB     r0,[r1,#0]
;;;1661   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
00001c  4608              MOV      r0,r1
00001e  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000020  2040              MOVS     r0,#0x40
000022  f7fffffe          BL       RA8875_WriteReg
;;;1662   
;;;1663   	/* 选择CGROM font; 选择内部CGROM; 内部CGROM 编码选择ISO/IEC 8859-1. */
;;;1664   	RA8875_WriteReg(0x2F, 0x00);
000026  2100              MOVS     r1,#0
000028  202f              MOVS     r0,#0x2f
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1665   	RA8875_WriteReg(0x21, (0 << 7) | (0 << 5) | (0 << 1) | (0 << 0));
00002e  2100              MOVS     r1,#0
000030  2021              MOVS     r0,#0x21
000032  f7fffffe          BL       RA8875_WriteReg
;;;1666   
;;;1667   	s_ucRA8875Busy = 1;
000036  2001              MOVS     r0,#1
000038  4911              LDR      r1,|L7.128|
00003a  7008              STRB     r0,[r1,#0]
;;;1668   
;;;1669   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RA8875_WriteCmd
;;;1670   
;;;1671   	/* 开始循环处理字符 */
;;;1672   	while (*_ptr != 0)
000042  e00a              B        |L7.90|
                  |L7.68|
;;;1673   	{
;;;1674   		RA8875_WriteData(*_ptr);
000044  7820              LDRB     r0,[r4,#0]
000046  f7fffffe          BL       RA8875_WriteData
;;;1675   		while ((RA8875_ReadStatus() & 0x80) == 0x80);	/* 必须等待内部写屏操作完成 */
00004a  bf00              NOP      
                  |L7.76|
00004c  f7fffffe          BL       RA8875_ReadStatus
000050  f0000080          AND      r0,r0,#0x80
000054  2880              CMP      r0,#0x80
000056  d0f9              BEQ      |L7.76|
;;;1676   		_ptr++;
000058  1c64              ADDS     r4,r4,#1
                  |L7.90|
00005a  7820              LDRB     r0,[r4,#0]            ;1672
00005c  2800              CMP      r0,#0                 ;1672
00005e  d1f1              BNE      |L7.68|
;;;1677   	}
;;;1678   	s_ucRA8875Busy = 0;
000060  4907              LDR      r1,|L7.128|
000062  7008              STRB     r0,[r1,#0]
;;;1679   
;;;1680   	s_reg_40H &= 0x7F;
000064  4805              LDR      r0,|L7.124|
000066  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000068  f000007f          AND      r0,r0,#0x7f
00006c  4903              LDR      r1,|L7.124|
00006e  7008              STRB     r0,[r1,#0]
;;;1681   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000070  4608              MOV      r0,r1
000072  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000074  2040              MOVS     r0,#0x40
000076  f7fffffe          BL       RA8875_WriteReg
;;;1682   }
00007a  bd70              POP      {r4-r6,pc}
;;;1683   
                          ENDP

                  |L7.124|
                          DCD      s_reg_40H
                  |L7.128|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DispBmpInFlash||, CODE, READONLY, ALIGN=2

                  RA8875_DispBmpInFlash PROC
;;;1056   */
;;;1057   void RA8875_DispBmpInFlash(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1058   	uint32_t _uiFlashAddr)
;;;1059   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;1060   	/* pdf 179页 7-10-1 连续内存直接存取模式
;;;1061   		1. 设定工作窗口范围 (REG[30h] ~REG[37h])和内存写入位置 (REG[46h] ~REG[49h])
;;;1062   		2. 设定Serial Flash/ROM 组态 (REG[05h])
;;;1063   		3. 设定 内存直接存取数据来源起始位置 (REG[B0h] ~REG[B2h])
;;;1064   		4. 设定 内存直接存取区块宽度 (REG[B4h] 和REG[B5h])
;;;1065   		5. 设定 内存直接存取区块高度 (REG[B6h] 和 REG[B7h])
;;;1066   		6. 设定内存直接存取来源图片宽度 (REG[B8h] 和 REG[B9h])
;;;1067   		7. 开启内存直接存取为区块搬移模式 (REG[BFh] bit 1)
;;;1068   		8. 开启内存直接存取起始讯号且检查内存直接存取忙碌讯号 (REG[BFh] bit 0)
;;;1069   	*/
;;;1070   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);	/* REG[30h] ~REG[37h] 和 REG[46h] ~REG[49h] */
00000e  4623              MOV      r3,r4
000010  4632              MOV      r2,r6
000012  4641              MOV      r1,r8
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       RA8875_SetDispWin
;;;1071   
;;;1072   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1073   		7	Serial Flash/ROM I/F # 选择
;;;1074   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板图库芯片接在 1 接口]
;;;1075   				1:选择Serial Flash/ROM 1 接口。
;;;1076   		6	Serial Flash/ROM 寻址模式
;;;1077   				0: 24 位寻址模式。
;;;1078   				此位必须设为0。
;;;1079   		5	Serial Flash/ROM 波形模式
;;;1080   				0: 波形模式 0。
;;;1081   				1: 波形模式 3。
;;;1082   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1083   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1084   			01b: 5 bus ??1 byte 空周期。
;;;1085   			1Xb: 6 bus ??2 byte 空周期。
;;;1086   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1087   			0: 字型模式 。
;;;1088   			1: DMA 模式。
;;;1089   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1090   			0Xb: 单一模式。
;;;1091   			10b: 双倍模式0。
;;;1092   			11b: 双倍模式1。
;;;1093   	*/
;;;1094   	
;;;1095   	/* 对于铁框屏，一片 W25Q128，前面2MB是字库。后面14MB是图片 */
;;;1096   	if (g_tW25.ChipID == W25Q128)
00001a  482c              LDR      r0,|L8.204|
00001c  6800              LDR      r0,[r0,#0]  ; g_tW25
00001e  492c              LDR      r1,|L8.208|
000020  4288              CMP      r0,r1
000022  d106              BNE      |L8.50|
;;;1097   	{
;;;1098   		_uiFlashAddr += PIC_OFFSET;	/* 前面2MB分配给字库 */	
000024  f5051500          ADD      r5,r5,#0x200000
;;;1099   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1100   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000028  2126              MOVS     r1,#0x26
00002a  2005              MOVS     r0,#5
00002c  f7fffffe          BL       RA8875_WriteReg
000030  e003              B        |L8.58|
                  |L8.50|
;;;1101   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1102   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1103   		#endif		
;;;1104   	}	
;;;1105   	else	/* 增强型屏，1片W25Q64(8MB)做字库，1片W25Q64(8MB)做图库 */
;;;1106   	{
;;;1107   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1108   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000032  21a6              MOVS     r1,#0xa6
000034  2005              MOVS     r0,#5
000036  f7fffffe          BL       RA8875_WriteReg
                  |L8.58|
;;;1109   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1110   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1111   		#endif	
;;;1112   	}
;;;1113   
;;;1114   	/*
;;;1115   		Serial Flash/ROM 频率频率设定
;;;1116   			0xb: SFCL 频率 = 系统频率频率(当DMA 为使能状态，并且色彩深度为256 色，则SFCL 频率
;;;1117   				固定为=系统频率频率/ 2)
;;;1118   			10b: SFCL 频率 =系统频率频率/ 2
;;;1119   			11b: SFCL 频率 =系统频率频率/ 4
;;;1120   
;;;1121   		安富莱TFT驱动板。4.3寸系统频率为 68MHz； 7寸系统频率为 81.25MHz。
;;;1122   
;;;1123   		8M串行Flash的访问速度:SPI 时钟频率:80MHz(max.)
;;;1124   		因此可以设置为 1 分频
;;;1125   	*/
;;;1126   	RA8875_WriteReg(0x06, (0 << 0));	/* 设置SCL时钟频率 */
00003a  2100              MOVS     r1,#0
00003c  2006              MOVS     r0,#6
00003e  f7fffffe          BL       RA8875_WriteReg
;;;1127   
;;;1128   	/* 设定源地址
;;;1129   		B0H   DMA 来源开始位置[7:0]
;;;1130   		B1H   DMA 来源开始位置[15:8]
;;;1131   		B2H   DMA 来源开始位置[23:16]
;;;1132   	*/
;;;1133   	RA8875_WriteReg(0xB0, (uint8_t)_uiFlashAddr);
000042  b2e9              UXTB     r1,r5
000044  20b0              MOVS     r0,#0xb0
000046  f7fffffe          BL       RA8875_WriteReg
;;;1134   	RA8875_WriteReg(0xB1, (uint8_t)(_uiFlashAddr >> 8));
00004a  f3c52107          UBFX     r1,r5,#8,#8
00004e  20b1              MOVS     r0,#0xb1
000050  f7fffffe          BL       RA8875_WriteReg
;;;1135   	RA8875_WriteReg(0xB2, (uint8_t)(_uiFlashAddr >> 16));
000054  f3c54107          UBFX     r1,r5,#16,#8
000058  20b2              MOVS     r0,#0xb2
00005a  f7fffffe          BL       RA8875_WriteReg
;;;1136   
;;;1137   	/*
;;;1138   		设置区块大小
;;;1139   		B4   DMA 区块宽度[7:0]
;;;1140   		B5   DMA 区块宽度[9:8]
;;;1141   		B6   DMA 区块高度[7:0]
;;;1142   	    B7   DMA 区块高度[9:8]
;;;1143   	    B8   DMA 来源图片宽度[7:0]
;;;1144   	    B9   DMA 来源图片宽度[9:8]
;;;1145   	*/
;;;1146   	RA8875_WriteReg(0xB4, _usWidth);		/* DMA 区块宽度 */
00005e  b2e1              UXTB     r1,r4
000060  20b4              MOVS     r0,#0xb4
000062  f7fffffe          BL       RA8875_WriteReg
;;;1147   	RA8875_WriteReg(0xB5, _usWidth >> 8);
000066  1221              ASRS     r1,r4,#8
000068  20b5              MOVS     r0,#0xb5
00006a  f7fffffe          BL       RA8875_WriteReg
;;;1148   
;;;1149   	RA8875_WriteReg(0xB6, _usHeight);		/* DMA 区块高度 */
00006e  b2f1              UXTB     r1,r6
000070  20b6              MOVS     r0,#0xb6
000072  f7fffffe          BL       RA8875_WriteReg
;;;1150   	RA8875_WriteReg(0xB7, _usHeight >> 8);
000076  1231              ASRS     r1,r6,#8
000078  20b7              MOVS     r0,#0xb7
00007a  f7fffffe          BL       RA8875_WriteReg
;;;1151   
;;;1152   	RA8875_WriteReg(0xB8, _usWidth);		/* DMA 来源图片宽度 */
00007e  b2e1              UXTB     r1,r4
000080  20b8              MOVS     r0,#0xb8
000082  f7fffffe          BL       RA8875_WriteReg
;;;1153   	RA8875_WriteReg(0xB9, _usWidth >> 8);
000086  1221              ASRS     r1,r4,#8
000088  20b9              MOVS     r0,#0xb9
00008a  f7fffffe          BL       RA8875_WriteReg
;;;1154   
;;;1155   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
00008e  2102              MOVS     r1,#2
000090  20bf              MOVS     r0,#0xbf
000092  f7fffffe          BL       RA8875_WriteReg
;;;1156   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
000096  2102              MOVS     r1,#2
000098  20bf              MOVS     r0,#0xbf
00009a  f7fffffe          BL       RA8875_WriteReg
;;;1157   
;;;1158   	s_ucRA8875Busy = 1;
00009e  2001              MOVS     r0,#1
0000a0  490c              LDR      r1,|L8.212|
0000a2  7008              STRB     r0,[r1,#0]
;;;1159   	RA8875_WriteCmd(0xBF);
0000a4  20bf              MOVS     r0,#0xbf
0000a6  f7fffffe          BL       RA8875_WriteCmd
;;;1160   	RA8875_WriteData((1 << 1) | (1 << 0));
0000aa  2003              MOVS     r0,#3
0000ac  f7fffffe          BL       RA8875_WriteData
;;;1161   	while (RA8875_ReadReg_Int(0xBF) & (1 << 0));	/* 等待结束 */
0000b0  bf00              NOP      
                  |L8.178|
0000b2  20bf              MOVS     r0,#0xbf
0000b4  f7fffffe          BL       RA8875_ReadReg_Int
0000b8  f0000001          AND      r0,r0,#1
0000bc  2800              CMP      r0,#0
0000be  d1f8              BNE      |L8.178|
;;;1162   	s_ucRA8875Busy = 0;
0000c0  4904              LDR      r1,|L8.212|
0000c2  7008              STRB     r0,[r1,#0]
;;;1163   
;;;1164   	RA8875_QuitWinMode();					/* 退出小窗口绘图模式 */
0000c4  f7fffffe          BL       RA8875_QuitWinMode
;;;1165   }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;1166   
                          ENDP

                  |L8.204|
                          DCD      g_tW25
                  |L8.208|
                          DCD      0x00ef4018
                  |L8.212|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DispOff||, CODE, READONLY, ALIGN=1

                  RA8875_DispOff PROC
;;;903    */
;;;904    void RA8875_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;905    {
;;;906    	RA8875_WriteReg(0x01, 0x00);
000002  2100              MOVS     r1,#0
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;907    }
00000a  bd10              POP      {r4,pc}
;;;908    
                          ENDP


                          AREA ||i.RA8875_DispOn||, CODE, READONLY, ALIGN=1

                  RA8875_DispOn PROC
;;;890    */
;;;891    void RA8875_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;892    {
;;;893    	RA8875_WriteReg(0x01, 0x80);
000002  2180              MOVS     r1,#0x80
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;894    }
00000a  bd10              POP      {r4,pc}
;;;895    
                          ENDP


                          AREA ||i.RA8875_DispStr||, CODE, READONLY, ALIGN=2

                  RA8875_DispStr PROC
;;;1695   */
;;;1696   void RA8875_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1697   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1698   	/*
;;;1699   		RA8875 透过使用 ― 上海集通公司 (Genitop Inc) 外部串行式字体内存 (Font ROM)，可支持各样
;;;1700   		的文字写入到DDRAM 中。RA8875 与上海集通公司 (Genitop Inc) 兼容的产品包含 :
;;;1701   		GT21L16TW/GT21H16T1W 、GT23L16U2W 、GT23L24T3Y/GT23H24T3Y 、GT23L24M1Z 、
;;;1702   		及 GT23L32S4W/GT23H32S4W。这些字体包含16x16, 24x24, 32x32 点 (Dot) 与不同的字
;;;1703   
;;;1704   		安富莱RA8875驱动板集成的字库芯片为 集通字库芯片_GT23l32S4W
;;;1705   
;;;1706   		GT23L32S4W是一款内含11X12点阵、15X16点、24X24点阵、32X32点阵的汉字库芯片，支持GB2312
;;;1707   		国标汉字（含有国家信标委合法授权）及SCII字符。排列格式为横置横排。用户通过字符内码，利用本手
;;;1708   		册提供的方法计算出该字符点阵在芯片中的地址，可从该地址连续读出字符点阵信息。
;;;1709   	*/
;;;1710   
;;;1711   	/* 设置文本显示位置，注意文本模式的写入光标和图形模式的写入光标是不同的寄存器 */
;;;1712   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1713   
;;;1714   	s_reg_40H |= (1 << 7);
000010  481e              LDR      r0,|L11.140|
000012  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000014  f0400080          ORR      r0,r0,#0x80
000018  491c              LDR      r1,|L11.140|
00001a  7008              STRB     r0,[r1,#0]
;;;1715   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
00001c  4608              MOV      r0,r1
00001e  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000020  2040              MOVS     r0,#0x40
000022  f7fffffe          BL       RA8875_WriteReg
;;;1716   
;;;1717   	/*
;;;1718   		Serial Flash/ROM 频率频率设定
;;;1719   			0xb: SFCL 频率 = 系统频率频率(当DMA 为致能状态，并且色彩深度为256 色，则SFCL 频率
;;;1720   				固定为=系统频率频率/ 2)
;;;1721   			10b: SFCL 频率 =系统频率频率/ 2
;;;1722   			11b: SFCL 频率 =系统频率频率/ 4
;;;1723   
;;;1724   		安富莱驱动板系统频率为 68MHz
;;;1725   
;;;1726   		GT23L32S4W的访问速度:SPI 时钟频率:20MHz(max.)
;;;1727   
;;;1728   		因此需要设置 4 分频, 17MHz
;;;1729   	*/
;;;1730   	RA8875_WriteReg(0x06, (3 << 0));	/* 设置为文本模式 */
000026  2103              MOVS     r1,#3
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1731   
;;;1732   	/* 选择外部字体ROM */
;;;1733   	RA8875_WriteReg(0x21, (0 << 7) | (1 << 5));
00002e  2120              MOVS     r1,#0x20
000030  2021              MOVS     r0,#0x21
000032  f7fffffe          BL       RA8875_WriteReg
;;;1734   
;;;1735   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1736   		7	Serial Flash/ROM I/F # 选择
;;;1737   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板字库芯片接在 0 接口]
;;;1738   				1:选择Serial Flash/ROM 1 接口。
;;;1739   		6	Serial Flash/ROM 寻址模式
;;;1740   				0: 24 位寻址模式。
;;;1741   				此位必须设为0。
;;;1742   		5	Serial Flash/ROM 波形模式
;;;1743   				0: 波形模式 0。
;;;1744   				1: 波形模式 3。
;;;1745   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1746   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1747   			01b: 5 bus ??1 byte 空周期。
;;;1748   			1Xb: 6 bus ??2 byte 空周期。
;;;1749   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1750   			0: 字型模式 。
;;;1751   			1: DMA 模式。
;;;1752   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1753   			0Xb: 单一模式。
;;;1754   			10b: 双倍模式0。
;;;1755   			11b: 双倍模式1。
;;;1756   	*/
;;;1757   	RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (1 << 3) | (0 << 2) | (0 << 1));
000036  2128              MOVS     r1,#0x28
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       RA8875_WriteReg
;;;1758   
;;;1759   	/*
;;;1760   		设置外部字体芯片型号为 GT23L32S4W, 编码为GB2312,
;;;1761   
;;;1762   		Bit1:0 决定ASCII字符的格式:
;;;1763   			0 = NORMAL		 [笔画细, 和汉字顶部对齐]
;;;1764   			1 = Arial		 [笔画粗，和汉字底部对齐]
;;;1765   			2 = Roman		 [笔画细, 和汉字底部对齐]
;;;1766   			3 = Bold		 [乱码,不可用]
;;;1767   	 */
;;;1768   	RA8875_WriteReg(0x2F, (4 << 5) | (0 << 2) | (1 << 0));
00003e  2181              MOVS     r1,#0x81
000040  202f              MOVS     r0,#0x2f
000042  f7fffffe          BL       RA8875_WriteReg
;;;1769   
;;;1770   	s_ucRA8875Busy = 1;
000046  2001              MOVS     r0,#1
000048  4911              LDR      r1,|L11.144|
00004a  7008              STRB     r0,[r1,#0]
;;;1771   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00004c  2002              MOVS     r0,#2
00004e  f7fffffe          BL       RA8875_WriteCmd
;;;1772   
;;;1773   	/* 开始循环处理字符 */
;;;1774   	while (*_ptr != 0)
000052  e00a              B        |L11.106|
                  |L11.84|
;;;1775   	{
;;;1776   		RA8875_WriteData(*_ptr);
000054  7820              LDRB     r0,[r4,#0]
000056  f7fffffe          BL       RA8875_WriteData
;;;1777   		while ((RA8875_ReadStatus() & 0x80) == 0x80);
00005a  bf00              NOP      
                  |L11.92|
00005c  f7fffffe          BL       RA8875_ReadStatus
000060  f0000080          AND      r0,r0,#0x80
000064  2880              CMP      r0,#0x80
000066  d0f9              BEQ      |L11.92|
;;;1778   		//while ((RA8875_ReadStatus() & 0x01) != 0);	
;;;1779   		//while(RA8875_ReadBusy());
;;;1780   		_ptr++;
000068  1c64              ADDS     r4,r4,#1
                  |L11.106|
00006a  7820              LDRB     r0,[r4,#0]            ;1774
00006c  2800              CMP      r0,#0                 ;1774
00006e  d1f1              BNE      |L11.84|
;;;1781   	}
;;;1782   	s_ucRA8875Busy = 0;
000070  4907              LDR      r1,|L11.144|
000072  7008              STRB     r0,[r1,#0]
;;;1783   
;;;1784   	s_reg_40H &= 0x7F;
000074  4805              LDR      r0,|L11.140|
000076  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000078  f000007f          AND      r0,r0,#0x7f
00007c  4903              LDR      r1,|L11.140|
00007e  7008              STRB     r0,[r1,#0]
;;;1785   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000080  4608              MOV      r0,r1
000082  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000084  2040              MOVS     r0,#0x40
000086  f7fffffe          BL       RA8875_WriteReg
;;;1786   }
00008a  bd70              POP      {r4-r6,pc}
;;;1787   
                          ENDP

                  |L11.140|
                          DCD      s_reg_40H
                  |L11.144|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawBMP||, CODE, READONLY, ALIGN=2

                  RA8875_DrawBMP PROC
;;;1178   */
;;;1179   void RA8875_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1180   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;1181   	uint32_t index = 0;
000010  2600              MOVS     r6,#0
;;;1182   	const uint16_t *p;
;;;1183   
;;;1184   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1185   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
000012  462b              MOV      r3,r5
000014  4622              MOV      r2,r4
000016  4649              MOV      r1,r9
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       RA8875_SetDispWin
;;;1186   
;;;1187   	s_ucRA8875Busy = 1;
00001e  2001              MOVS     r0,#1
000020  490b              LDR      r1,|L12.80|
000022  7008              STRB     r0,[r1,#0]
;;;1188   
;;;1189   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RA8875_WriteCmd
;;;1190   
;;;1191   	p = _ptr;
00002a  4657              MOV      r7,r10
;;;1192   	for (index = 0; index < _usHeight * _usWidth; index++)
00002c  bf00              NOP      
00002e  e004              B        |L12.58|
                  |L12.48|
;;;1193   	{
;;;1194   		/*
;;;1195   			armfly : 进行优化, 函数就地展开
;;;1196   			RA8875_WriteRAM(_ptr[index]);
;;;1197   
;;;1198   			此处可考虑用DMA操作
;;;1199   		*/
;;;1200   		RA8875_WriteData16(*p++);
000030  f8370b02          LDRH     r0,[r7],#2
000034  f7fffffe          BL       RA8875_WriteData16
000038  1c76              ADDS     r6,r6,#1              ;1192
                  |L12.58|
00003a  fb04f005          MUL      r0,r4,r5              ;1192
00003e  42b0              CMP      r0,r6                 ;1192
000040  d8f6              BHI      |L12.48|
;;;1201   	}
;;;1202   	s_ucRA8875Busy = 0;
000042  2000              MOVS     r0,#0
000044  4902              LDR      r1,|L12.80|
000046  7008              STRB     r0,[r1,#0]
;;;1203   
;;;1204   	/* 退出窗口绘图模式 */
;;;1205   	RA8875_QuitWinMode();
000048  f7fffffe          BL       RA8875_QuitWinMode
;;;1206   }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;1207   
                          ENDP

                  |L12.80|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawCircle||, CODE, READONLY, ALIGN=2

                  RA8875_DrawCircle PROC
;;;1457   */
;;;1458   void RA8875_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1459   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1460   	/*
;;;1461   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1462   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1463   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1464   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1465   		画出空心圆 (Not Fill
;;;1466   	*/
;;;1467   	/* 设置圆的半径 */
;;;1468   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L13.20|
                  |L13.16|
;;;1469   	{
;;;1470   		return;
;;;1471   	}
;;;1472   
;;;1473   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1474   	{
;;;1475   		uint16_t temp;
;;;1476   		
;;;1477   		temp = _usX;
;;;1478   		_usX = _usY;
;;;1479   		_usY = temp;
;;;1480   	}
;;;1481   	
;;;1482   	/* 设置圆心坐标 */
;;;1483   	RA8875_WriteReg(0x99, _usX);
;;;1484   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1485   	RA8875_WriteReg(0x9B, _usY);
;;;1486   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1487   
;;;1488   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1489   
;;;1490   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1491   
;;;1492   	s_ucRA8875Busy = 1;
;;;1493   //	RA8875_WriteReg(0x90, (1 << 6) | (0 << 5));				/* 开始画圆, 不填充  */
;;;1494   	RA8875_WriteCmd(0x90);
;;;1495   	RA8875_WriteData( (1 << 6) | (0 << 5));
;;;1496   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1497   	RA8875_WaitBusy();
;;;1498   	s_ucRA8875Busy = 0;
;;;1499   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L13.20|
000014  4817              LDR      r0,|L13.116|
000016  7800              LDRB     r0,[r0,#0]            ;1473  ; g_LcdDirection
000018  2801              CMP      r0,#1                 ;1473
00001a  dd03              BLE      |L13.36|
00001c  4620              MOV      r0,r4                 ;1477
00001e  462c              MOV      r4,r5                 ;1478
000020  4605              MOV      r5,r0                 ;1479
000022  bf00              NOP                            ;1480
                  |L13.36|
000024  b2e1              UXTB     r1,r4                 ;1483
000026  2099              MOVS     r0,#0x99              ;1483
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1221              ASRS     r1,r4,#8              ;1484
00002e  209a              MOVS     r0,#0x9a              ;1484
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2e9              UXTB     r1,r5                 ;1485
000036  209b              MOVS     r0,#0x9b              ;1485
000038  f7fffffe          BL       RA8875_WriteReg
00003c  1229              ASRS     r1,r5,#8              ;1486
00003e  209c              MOVS     r0,#0x9c              ;1486
000040  f7fffffe          BL       RA8875_WriteReg
000044  b2f1              UXTB     r1,r6                 ;1488
000046  209d              MOVS     r0,#0x9d              ;1488
000048  f7fffffe          BL       RA8875_WriteReg
00004c  4638              MOV      r0,r7                 ;1490
00004e  f7fffffe          BL       RA8875_SetFrontColor
000052  2001              MOVS     r0,#1                 ;1492
000054  4908              LDR      r1,|L13.120|
000056  7008              STRB     r0,[r1,#0]            ;1492
000058  2090              MOVS     r0,#0x90              ;1494
00005a  f7fffffe          BL       RA8875_WriteCmd
00005e  2040              MOVS     r0,#0x40              ;1495
000060  f7fffffe          BL       RA8875_WriteData
000064  f7fffffe          BL       RA8875_WaitBusy
000068  2000              MOVS     r0,#0                 ;1498
00006a  4903              LDR      r1,|L13.120|
00006c  7008              STRB     r0,[r1,#0]            ;1498
00006e  bf00              NOP      
000070  e7ce              B        |L13.16|
;;;1500   
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      g_LcdDirection
                  |L13.120|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawHColorLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawHColorLine PROC
;;;2149   */
;;;2150   void RA8875_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  b570              PUSH     {r4-r6,lr}
;;;2151   {
;;;2152   	uint16_t i;
;;;2153   
;;;2154   	s_ucRA8875Busy = 1;
000002  2501              MOVS     r5,#1
000004  4e15              LDR      r6,|L14.92|
000006  7035              STRB     r5,[r6,#0]
;;;2155   	
;;;2156   	RA8875_REG = 0x46; RA8875_RAM = _usX1;
000008  2546              MOVS     r5,#0x46
00000a  4e15              LDR      r6,|L14.96|
00000c  8035              STRH     r5,[r6,#0]
00000e  f04f45d8          MOV      r5,#0x6c000000
000012  8028              STRH     r0,[r5,#0]
;;;2157   	RA8875_REG = 0x47; RA8875_RAM = _usX1 >> 8;
000014  2547              MOVS     r5,#0x47
000016  8035              STRH     r5,[r6,#0]
000018  1205              ASRS     r5,r0,#8
00001a  f04f46d8          MOV      r6,#0x6c000000
00001e  8035              STRH     r5,[r6,#0]
;;;2158   	RA8875_REG = 0x48; RA8875_RAM = _usY1;
000020  2548              MOVS     r5,#0x48
000022  4e0f              LDR      r6,|L14.96|
000024  8035              STRH     r5,[r6,#0]
000026  f04f45d8          MOV      r5,#0x6c000000
00002a  8029              STRH     r1,[r5,#0]
;;;2159   	RA8875_REG = 0x49; RA8875_RAM = _usY1 >> 8;
00002c  2549              MOVS     r5,#0x49
00002e  8035              STRH     r5,[r6,#0]
000030  120d              ASRS     r5,r1,#8
000032  f04f46d8          MOV      r6,#0x6c000000
000036  8035              STRH     r5,[r6,#0]
;;;2160   
;;;2161   	RA8875_REG = 0x02; 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
000038  2502              MOVS     r5,#2
00003a  4e09              LDR      r6,|L14.96|
00003c  8035              STRH     r5,[r6,#0]
;;;2162   	
;;;2163   	for (i = 0; i < _usWidth; i++)
00003e  2400              MOVS     r4,#0
000040  e006              B        |L14.80|
                  |L14.66|
;;;2164   	{
;;;2165   		RA8875_RAM = *_pColor++;
000042  f8335b02          LDRH     r5,[r3],#2
000046  f04f46d8          MOV      r6,#0x6c000000
00004a  8035              STRH     r5,[r6,#0]
00004c  1c65              ADDS     r5,r4,#1              ;2163
00004e  b2ac              UXTH     r4,r5                 ;2163
                  |L14.80|
000050  4294              CMP      r4,r2                 ;2163
000052  dbf6              BLT      |L14.66|
;;;2166   		//RA8875_WriteData16(*_pColor++);
;;;2167   	}
;;;2168   	
;;;2169   	s_ucRA8875Busy = 0;
000054  2500              MOVS     r5,#0
000056  4e01              LDR      r6,|L14.92|
000058  7035              STRB     r5,[r6,#0]
;;;2170   }
00005a  bd70              POP      {r4-r6,pc}
;;;2171   
                          ENDP

                  |L14.92|
                          DCD      s_ucRA8875Busy
                  |L14.96|
                          DCD      0x6c080000

                          AREA ||i.RA8875_DrawHLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawHLine PROC
;;;2116   */
;;;2117   void RA8875_DrawHLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;2118   {
;;;2119   	uint16_t i;
;;;2120   
;;;2121   	s_ucRA8875Busy = 1;
000002  2501              MOVS     r5,#1
000004  4e15              LDR      r6,|L15.92|
000006  7035              STRB     r5,[r6,#0]
;;;2122   	RA8875_REG = 0x46; RA8875_RAM = _usX1;
000008  2546              MOVS     r5,#0x46
00000a  4e15              LDR      r6,|L15.96|
00000c  8035              STRH     r5,[r6,#0]
00000e  f04f45d8          MOV      r5,#0x6c000000
000012  8028              STRH     r0,[r5,#0]
;;;2123   	RA8875_REG = 0x47; RA8875_RAM = _usX1 >> 8;
000014  2547              MOVS     r5,#0x47
000016  8035              STRH     r5,[r6,#0]
000018  1205              ASRS     r5,r0,#8
00001a  f04f46d8          MOV      r6,#0x6c000000
00001e  8035              STRH     r5,[r6,#0]
;;;2124   	RA8875_REG = 0x48; RA8875_RAM = _usY1;
000020  2548              MOVS     r5,#0x48
000022  4e0f              LDR      r6,|L15.96|
000024  8035              STRH     r5,[r6,#0]
000026  f04f45d8          MOV      r5,#0x6c000000
00002a  8029              STRH     r1,[r5,#0]
;;;2125   	RA8875_REG = 0x49; RA8875_RAM = _usY1 >> 8;
00002c  2549              MOVS     r5,#0x49
00002e  8035              STRH     r5,[r6,#0]
000030  120d              ASRS     r5,r1,#8
000032  f04f46d8          MOV      r6,#0x6c000000
000036  8035              STRH     r5,[r6,#0]
;;;2126   
;;;2127   	RA8875_REG = 0x02; 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
000038  2502              MOVS     r5,#2
00003a  4e09              LDR      r6,|L15.96|
00003c  8035              STRH     r5,[r6,#0]
;;;2128   	
;;;2129   	for (i = 0; i < _usX2 - _usX1 + 1; i++)
00003e  2400              MOVS     r4,#0
000040  e004              B        |L15.76|
                  |L15.66|
;;;2130   	{
;;;2131   		
;;;2132   		//RA8875_WriteData16(_usColor);
;;;2133   		RA8875_RAM = _usColor;
000042  f04f45d8          MOV      r5,#0x6c000000
000046  802b              STRH     r3,[r5,#0]
000048  1c65              ADDS     r5,r4,#1              ;2129
00004a  b2ac              UXTH     r4,r5                 ;2129
                  |L15.76|
00004c  1a15              SUBS     r5,r2,r0              ;2129
00004e  1c6d              ADDS     r5,r5,#1              ;2129
000050  42a5              CMP      r5,r4                 ;2129
000052  dcf6              BGT      |L15.66|
;;;2134   	}
;;;2135   	
;;;2136   	s_ucRA8875Busy = 0;
000054  2500              MOVS     r5,#0
000056  4e01              LDR      r6,|L15.92|
000058  7035              STRB     r5,[r6,#0]
;;;2137   }
00005a  bd70              POP      {r4-r6,pc}
;;;2138   
                          ENDP

                  |L15.92|
                          DCD      s_ucRA8875Busy
                  |L15.96|
                          DCD      0x6c080000

                          AREA ||i.RA8875_DrawLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawLine PROC
;;;1260   */
;;;1261   void RA8875_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1262   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1263   	/* pdf 第131页
;;;1264   		RA8875 支持直线绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画直线。先设
;;;1265   		定直线的起始点REG[91h~94h] 与结束点REG[95h~98h]，直线的颜色REG[63h~65h]，然后启
;;;1266   		动绘图设定REG[90h] Bit4 = 0, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将直线的图形写入
;;;1267   		DDRAM，相对的在TFT 模块上就可以显示所画的直线。
;;;1268   	*/
;;;1269   
;;;1270   	if ((_usX1 == _usX2) && (_usY1 == _usY2))
000010  42b4              CMP      r4,r6
000012  d108              BNE      |L16.38|
000014  42bd              CMP      r5,r7
000016  d106              BNE      |L16.38|
;;;1271   	{
;;;1272   		RA8875_PutPixel(_usX1, _usY1, _usColor);
000018  4642              MOV      r2,r8
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       RA8875_PutPixel
                  |L16.34|
;;;1273   		return;
;;;1274   	}
;;;1275   
;;;1276   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1277   	{
;;;1278   		uint16_t temp;
;;;1279   		
;;;1280   		temp = _usX1;
;;;1281   		_usX1 = _usY1;
;;;1282   		_usY1 = temp;
;;;1283   
;;;1284   		temp = _usX2;
;;;1285   		_usX2 = _usY2;
;;;1286   		_usY2 = temp;		
;;;1287   	}
;;;1288   	
;;;1289   	/* 设置起点坐标 */
;;;1290   	RA8875_WriteReg(0x91, _usX1);
;;;1291   	RA8875_WriteReg(0x92, _usX1 >> 8);
;;;1292   	RA8875_WriteReg(0x93, _usY1);
;;;1293   	RA8875_WriteReg(0x94, _usY1 >> 8);
;;;1294   
;;;1295   	/* 设置终点坐标 */
;;;1296   	RA8875_WriteReg(0x95, _usX2);
;;;1297   	RA8875_WriteReg(0x96, _usX2 >> 8);
;;;1298   	RA8875_WriteReg(0x97, _usY2);
;;;1299   	RA8875_WriteReg(0x98, _usY2 >> 8);
;;;1300   
;;;1301   	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */
;;;1302   
;;;1303   	s_ucRA8875Busy = 1;
;;;1304   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 4) | (0 << 0));/* 开始画直线 */
;;;1305   	RA8875_WriteCmd(0x90);
;;;1306   	RA8875_WriteData((1 << 7) | (0 << 4) | (0 << 0));
;;;1307   //	while (RA8875_ReadReg(0x90) & (1 << 7));				/* 等待结束 */
;;;1308   	RA8875_WaitBusy();
;;;1309   	s_ucRA8875Busy = 0;
;;;1310   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L16.38|
000026  481f              LDR      r0,|L16.164|
000028  7800              LDRB     r0,[r0,#0]            ;1276  ; g_LcdDirection
00002a  2801              CMP      r0,#1                 ;1276
00002c  dd06              BLE      |L16.60|
00002e  4620              MOV      r0,r4                 ;1280
000030  462c              MOV      r4,r5                 ;1281
000032  4605              MOV      r5,r0                 ;1282
000034  4630              MOV      r0,r6                 ;1284
000036  463e              MOV      r6,r7                 ;1285
000038  4607              MOV      r7,r0                 ;1286
00003a  bf00              NOP                            ;1287
                  |L16.60|
00003c  b2e1              UXTB     r1,r4                 ;1290
00003e  2091              MOVS     r0,#0x91              ;1290
000040  f7fffffe          BL       RA8875_WriteReg
000044  1221              ASRS     r1,r4,#8              ;1291
000046  2092              MOVS     r0,#0x92              ;1291
000048  f7fffffe          BL       RA8875_WriteReg
00004c  b2e9              UXTB     r1,r5                 ;1292
00004e  2093              MOVS     r0,#0x93              ;1292
000050  f7fffffe          BL       RA8875_WriteReg
000054  1229              ASRS     r1,r5,#8              ;1293
000056  2094              MOVS     r0,#0x94              ;1293
000058  f7fffffe          BL       RA8875_WriteReg
00005c  b2f1              UXTB     r1,r6                 ;1296
00005e  2095              MOVS     r0,#0x95              ;1296
000060  f7fffffe          BL       RA8875_WriteReg
000064  1231              ASRS     r1,r6,#8              ;1297
000066  2096              MOVS     r0,#0x96              ;1297
000068  f7fffffe          BL       RA8875_WriteReg
00006c  b2f9              UXTB     r1,r7                 ;1298
00006e  2097              MOVS     r0,#0x97              ;1298
000070  f7fffffe          BL       RA8875_WriteReg
000074  1239              ASRS     r1,r7,#8              ;1299
000076  2098              MOVS     r0,#0x98              ;1299
000078  f7fffffe          BL       RA8875_WriteReg
00007c  4640              MOV      r0,r8                 ;1301
00007e  f7fffffe          BL       RA8875_SetFrontColor
000082  2001              MOVS     r0,#1                 ;1303
000084  4908              LDR      r1,|L16.168|
000086  7008              STRB     r0,[r1,#0]            ;1303
000088  2090              MOVS     r0,#0x90              ;1305
00008a  f7fffffe          BL       RA8875_WriteCmd
00008e  2080              MOVS     r0,#0x80              ;1306
000090  f7fffffe          BL       RA8875_WriteData
000094  f7fffffe          BL       RA8875_WaitBusy
000098  2000              MOVS     r0,#0                 ;1309
00009a  4903              LDR      r1,|L16.168|
00009c  7008              STRB     r0,[r1,#0]            ;1309
00009e  bf00              NOP      
0000a0  e7bf              B        |L16.34|
;;;1311   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L16.164|
                          DCD      g_LcdDirection
                  |L16.168|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawRect||, CODE, READONLY, ALIGN=2

                  RA8875_DrawRect PROC
;;;1323   */
;;;1324   void RA8875_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1325   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1326   	/*
;;;1327   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1328   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1329   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1330   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1331   	实心方形 (Fill)
;;;1332   
;;;1333   	 ---------------->---
;;;1334   	|(_usX，_usY)        |
;;;1335   	V                    V  _usHeight
;;;1336   	|                    |
;;;1337   	 ---------------->---
;;;1338   		  _usWidth
;;;1339   	*/
;;;1340   
;;;1341   	if (g_LcdDirection > 1)	/* 竖屏  */
000010  4823              LDR      r0,|L17.160|
000012  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000014  2801              CMP      r0,#1
000016  dd06              BLE      |L17.38|
;;;1342   	{
;;;1343   		uint16_t temp;
;;;1344   		
;;;1345   		temp = _usX;
000018  4620              MOV      r0,r4
;;;1346   		_usX = _usY;
00001a  462c              MOV      r4,r5
;;;1347   		_usY = temp;
00001c  4605              MOV      r5,r0
;;;1348   
;;;1349   		temp = _usHeight;
00001e  4630              MOV      r0,r6
;;;1350   		_usHeight = _usWidth;
000020  463e              MOV      r6,r7
;;;1351   		_usWidth = temp;		
000022  4607              MOV      r7,r0
;;;1352   	}
000024  bf00              NOP      
                  |L17.38|
;;;1353   
;;;1354   	/* 设置起点坐标 */
;;;1355   	RA8875_WriteReg(0x91, _usX);
000026  b2e1              UXTB     r1,r4
000028  2091              MOVS     r0,#0x91
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1356   	RA8875_WriteReg(0x92, _usX >> 8);
00002e  1221              ASRS     r1,r4,#8
000030  2092              MOVS     r0,#0x92
000032  f7fffffe          BL       RA8875_WriteReg
;;;1357   	RA8875_WriteReg(0x93, _usY);
000036  b2e9              UXTB     r1,r5
000038  2093              MOVS     r0,#0x93
00003a  f7fffffe          BL       RA8875_WriteReg
;;;1358   	RA8875_WriteReg(0x94, _usY >> 8);
00003e  1229              ASRS     r1,r5,#8
000040  2094              MOVS     r0,#0x94
000042  f7fffffe          BL       RA8875_WriteReg
;;;1359   
;;;1360   	/* 设置终点坐标 */
;;;1361   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000046  19e0              ADDS     r0,r4,r7
000048  1e40              SUBS     r0,r0,#1
00004a  b2c1              UXTB     r1,r0
00004c  2095              MOVS     r0,#0x95
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1362   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
000052  19e0              ADDS     r0,r4,r7
000054  1e40              SUBS     r0,r0,#1
000056  f3c02107          UBFX     r1,r0,#8,#8
00005a  2096              MOVS     r0,#0x96
00005c  f7fffffe          BL       RA8875_WriteReg
;;;1363   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
000060  19a8              ADDS     r0,r5,r6
000062  1e40              SUBS     r0,r0,#1
000064  b2c1              UXTB     r1,r0
000066  2097              MOVS     r0,#0x97
000068  f7fffffe          BL       RA8875_WriteReg
;;;1364   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
00006c  19a8              ADDS     r0,r5,r6
00006e  1e40              SUBS     r0,r0,#1
000070  f3c02107          UBFX     r1,r0,#8,#8
000074  2098              MOVS     r0,#0x98
000076  f7fffffe          BL       RA8875_WriteReg
;;;1365   
;;;1366   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       RA8875_SetFrontColor
;;;1367   
;;;1368   	s_ucRA8875Busy = 1;
000080  2001              MOVS     r0,#1
000082  4908              LDR      r1,|L17.164|
000084  7008              STRB     r0,[r1,#0]
;;;1369   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));	/* 开始画矩形  */
;;;1370   	RA8875_WriteCmd(0x90);
000086  2090              MOVS     r0,#0x90
000088  f7fffffe          BL       RA8875_WriteCmd
;;;1371   	RA8875_WriteData((1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));
00008c  2090              MOVS     r0,#0x90
00008e  f7fffffe          BL       RA8875_WriteData
;;;1372   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1373   	RA8875_WaitBusy();
000092  f7fffffe          BL       RA8875_WaitBusy
;;;1374   	s_ucRA8875Busy = 0;
000096  2000              MOVS     r0,#0
000098  4902              LDR      r1,|L17.164|
00009a  7008              STRB     r0,[r1,#0]
;;;1375   }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;1376   
                          ENDP

                  |L17.160|
                          DCD      g_LcdDirection
                  |L17.164|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawVLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawVLine PROC
;;;2182   */
;;;2183   void RA8875_DrawVLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2 , uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;2184   {
000002  4614              MOV      r4,r2
;;;2185   	uint16_t i;
;;;2186   
;;;2187   	s_ucRA8875Busy = 1;
000004  2501              MOVS     r5,#1
000006  4e23              LDR      r6,|L18.148|
000008  7035              STRB     r5,[r6,#0]
;;;2188   
;;;2189   	RA8875_REG = 0x46; RA8875_RAM = _usX1;
00000a  2546              MOVS     r5,#0x46
00000c  4e22              LDR      r6,|L18.152|
00000e  8035              STRH     r5,[r6,#0]
000010  f04f45d8          MOV      r5,#0x6c000000
000014  8028              STRH     r0,[r5,#0]
;;;2190   	RA8875_REG = 0x47; RA8875_RAM = _usX1 >> 8;
000016  2547              MOVS     r5,#0x47
000018  8035              STRH     r5,[r6,#0]
00001a  1205              ASRS     r5,r0,#8
00001c  f04f46d8          MOV      r6,#0x6c000000
000020  8035              STRH     r5,[r6,#0]
;;;2191   	RA8875_REG = 0x48; RA8875_RAM = _usY1;
000022  2548              MOVS     r5,#0x48
000024  4e1c              LDR      r6,|L18.152|
000026  8035              STRH     r5,[r6,#0]
000028  f04f45d8          MOV      r5,#0x6c000000
00002c  8029              STRH     r1,[r5,#0]
;;;2192   	RA8875_REG = 0x49; RA8875_RAM = _usY1 >> 8;
00002e  2549              MOVS     r5,#0x49
000030  8035              STRH     r5,[r6,#0]
000032  120d              ASRS     r5,r1,#8
000034  f04f46d8          MOV      r6,#0x6c000000
000038  8035              STRH     r5,[r6,#0]
;;;2193   	
;;;2194   	for (i = 1; i <= _usY2 - _usY1 + 1; i++)
00003a  2201              MOVS     r2,#1
00003c  e021              B        |L18.130|
                  |L18.62|
;;;2195   	{	
;;;2196   		RA8875_REG = 0x02; 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003e  2502              MOVS     r5,#2
000040  4e15              LDR      r6,|L18.152|
000042  8035              STRH     r5,[r6,#0]
;;;2197   		RA8875_RAM = _usColor;
000044  f04f45d8          MOV      r5,#0x6c000000
000048  802b              STRH     r3,[r5,#0]
;;;2198   		
;;;2199   		RA8875_REG = 0x46; RA8875_RAM = _usX1;
00004a  2546              MOVS     r5,#0x46
00004c  8035              STRH     r5,[r6,#0]
00004e  f04f45d8          MOV      r5,#0x6c000000
000052  8028              STRH     r0,[r5,#0]
;;;2200   		RA8875_REG = 0x47; RA8875_RAM = _usX1 >> 8;
000054  2547              MOVS     r5,#0x47
000056  8035              STRH     r5,[r6,#0]
000058  1205              ASRS     r5,r0,#8
00005a  f04f46d8          MOV      r6,#0x6c000000
00005e  8035              STRH     r5,[r6,#0]
;;;2201   		RA8875_REG = 0x48; RA8875_RAM = _usY1 + i;
000060  2548              MOVS     r5,#0x48
000062  4e0d              LDR      r6,|L18.152|
000064  8035              STRH     r5,[r6,#0]
000066  188d              ADDS     r5,r1,r2
000068  f04f46d8          MOV      r6,#0x6c000000
00006c  8035              STRH     r5,[r6,#0]
;;;2202   		RA8875_REG = 0x49; RA8875_RAM = ( _usY1 + i) >> 8;
00006e  2549              MOVS     r5,#0x49
000070  4e09              LDR      r6,|L18.152|
000072  8035              STRH     r5,[r6,#0]
000074  188d              ADDS     r5,r1,r2
000076  122d              ASRS     r5,r5,#8
000078  f04f46d8          MOV      r6,#0x6c000000
00007c  8035              STRH     r5,[r6,#0]
00007e  1c55              ADDS     r5,r2,#1              ;2194
000080  b2aa              UXTH     r2,r5                 ;2194
                  |L18.130|
000082  1a65              SUBS     r5,r4,r1              ;2194
000084  1c6d              ADDS     r5,r5,#1              ;2194
000086  4295              CMP      r5,r2                 ;2194
000088  dad9              BGE      |L18.62|
;;;2203   	}
;;;2204   	
;;;2205   	s_ucRA8875Busy = 0;
00008a  2500              MOVS     r5,#0
00008c  4e01              LDR      r6,|L18.148|
00008e  7035              STRB     r5,[r6,#0]
;;;2206   }
000090  bd70              POP      {r4-r6,pc}
;;;2207   
                          ENDP

000092  0000              DCW      0x0000
                  |L18.148|
                          DCD      s_ucRA8875Busy
                  |L18.152|
                          DCD      0x6c080000

                          AREA ||i.RA8875_FillCircle||, CODE, READONLY, ALIGN=2

                  RA8875_FillCircle PROC
;;;1511   */
;;;1512   void RA8875_FillCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1513   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1514   	/*
;;;1515   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1516   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1517   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1518   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1519   		画出空心圆 (Not Fill
;;;1520   	*/
;;;1521   	/* 设置圆的半径 */
;;;1522   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L19.20|
                  |L19.16|
;;;1523   	{
;;;1524   		return;
;;;1525   	}
;;;1526   
;;;1527   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1528   	{
;;;1529   		uint16_t temp;
;;;1530   		
;;;1531   		temp = _usX;
;;;1532   		_usX = _usY;
;;;1533   		_usY = temp;
;;;1534   	}
;;;1535   	
;;;1536   	/* 设置圆心坐标 */
;;;1537   	RA8875_WriteReg(0x99, _usX);
;;;1538   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1539   	RA8875_WriteReg(0x9B, _usY);
;;;1540   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1541   
;;;1542   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1543   
;;;1544   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1545   
;;;1546   	s_ucRA8875Busy = 1;
;;;1547   //	RA8875_WriteReg(0x90, (1 << 6) | (1 << 5));				/* 开始画圆, 填充  */
;;;1548   	RA8875_WriteCmd(0x90);
;;;1549   	RA8875_WriteData((1 << 6) | (1 << 5));
;;;1550   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1551   	RA8875_WaitBusy();
;;;1552   	s_ucRA8875Busy = 0;
;;;1553   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L19.20|
000014  4817              LDR      r0,|L19.116|
000016  7800              LDRB     r0,[r0,#0]            ;1527  ; g_LcdDirection
000018  2801              CMP      r0,#1                 ;1527
00001a  dd03              BLE      |L19.36|
00001c  4620              MOV      r0,r4                 ;1531
00001e  462c              MOV      r4,r5                 ;1532
000020  4605              MOV      r5,r0                 ;1533
000022  bf00              NOP                            ;1534
                  |L19.36|
000024  b2e1              UXTB     r1,r4                 ;1537
000026  2099              MOVS     r0,#0x99              ;1537
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1221              ASRS     r1,r4,#8              ;1538
00002e  209a              MOVS     r0,#0x9a              ;1538
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2e9              UXTB     r1,r5                 ;1539
000036  209b              MOVS     r0,#0x9b              ;1539
000038  f7fffffe          BL       RA8875_WriteReg
00003c  1229              ASRS     r1,r5,#8              ;1540
00003e  209c              MOVS     r0,#0x9c              ;1540
000040  f7fffffe          BL       RA8875_WriteReg
000044  b2f1              UXTB     r1,r6                 ;1542
000046  209d              MOVS     r0,#0x9d              ;1542
000048  f7fffffe          BL       RA8875_WriteReg
00004c  4638              MOV      r0,r7                 ;1544
00004e  f7fffffe          BL       RA8875_SetFrontColor
000052  2001              MOVS     r0,#1                 ;1546
000054  4908              LDR      r1,|L19.120|
000056  7008              STRB     r0,[r1,#0]            ;1546
000058  2090              MOVS     r0,#0x90              ;1548
00005a  f7fffffe          BL       RA8875_WriteCmd
00005e  2060              MOVS     r0,#0x60              ;1549
000060  f7fffffe          BL       RA8875_WriteData
000064  f7fffffe          BL       RA8875_WaitBusy
000068  2000              MOVS     r0,#0                 ;1552
00006a  4903              LDR      r1,|L19.120|
00006c  7008              STRB     r0,[r1,#0]            ;1552
00006e  bf00              NOP      
000070  e7ce              B        |L19.16|
;;;1554   
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      g_LcdDirection
                  |L19.120|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_FillRect||, CODE, READONLY, ALIGN=2

                  RA8875_FillRect PROC
;;;1388   */
;;;1389   void RA8875_FillRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1390   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1391   	/*
;;;1392   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1393   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1394   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1395   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1396   	实心方形 (Fill)
;;;1397   
;;;1398   	 ---------------->---
;;;1399   	|(_usX，_usY)        |
;;;1400   	V                    V  _usHeight
;;;1401   	|                    |
;;;1402   	 ---------------->---
;;;1403   		  _usWidth
;;;1404   	*/
;;;1405   
;;;1406   	if (_usWidth == 0 || _usHeight == 0)
000010  b107              CBZ      r7,|L20.20|
000012  b90e              CBNZ     r6,|L20.24|
                  |L20.20|
;;;1407   	{
;;;1408   		return;
;;;1409   	}
;;;1410   
;;;1411   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1412   	{
;;;1413   		uint16_t temp;
;;;1414   		
;;;1415   		temp = _usX;
;;;1416   		_usX = _usY;
;;;1417   		_usY = temp;
;;;1418   		
;;;1419   		temp = _usHeight;
;;;1420   		_usHeight = _usWidth;
;;;1421   		_usWidth = temp;
;;;1422   	}
;;;1423   	
;;;1424   	/* 设置起点坐标 */
;;;1425   	RA8875_WriteReg(0x91, _usX);
;;;1426   	RA8875_WriteReg(0x92, _usX >> 8);
;;;1427   	RA8875_WriteReg(0x93, _usY);
;;;1428   	RA8875_WriteReg(0x94, _usY >> 8);
;;;1429   
;;;1430   	/* 设置终点坐标 */
;;;1431   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
;;;1432   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
;;;1433   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
;;;1434   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
;;;1435   
;;;1436   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1437   
;;;1438   	s_ucRA8875Busy = 1;
;;;1439   //	RA8875_WriteReg(0x90, (1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));	/* 开始填充矩形  */
;;;1440   	RA8875_WriteCmd(0x90);
;;;1441   	RA8875_WriteData((1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));
;;;1442   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1443   	RA8875_WaitBusy();
;;;1444   	s_ucRA8875Busy = 0;
;;;1445   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L20.24|
000018  4823              LDR      r0,|L20.168|
00001a  7800              LDRB     r0,[r0,#0]            ;1411  ; g_LcdDirection
00001c  2801              CMP      r0,#1                 ;1411
00001e  dd06              BLE      |L20.46|
000020  4620              MOV      r0,r4                 ;1415
000022  462c              MOV      r4,r5                 ;1416
000024  4605              MOV      r5,r0                 ;1417
000026  4630              MOV      r0,r6                 ;1419
000028  463e              MOV      r6,r7                 ;1420
00002a  4607              MOV      r7,r0                 ;1421
00002c  bf00              NOP                            ;1422
                  |L20.46|
00002e  b2e1              UXTB     r1,r4                 ;1425
000030  2091              MOVS     r0,#0x91              ;1425
000032  f7fffffe          BL       RA8875_WriteReg
000036  1221              ASRS     r1,r4,#8              ;1426
000038  2092              MOVS     r0,#0x92              ;1426
00003a  f7fffffe          BL       RA8875_WriteReg
00003e  b2e9              UXTB     r1,r5                 ;1427
000040  2093              MOVS     r0,#0x93              ;1427
000042  f7fffffe          BL       RA8875_WriteReg
000046  1229              ASRS     r1,r5,#8              ;1428
000048  2094              MOVS     r0,#0x94              ;1428
00004a  f7fffffe          BL       RA8875_WriteReg
00004e  19e0              ADDS     r0,r4,r7              ;1431
000050  1e40              SUBS     r0,r0,#1              ;1431
000052  b2c1              UXTB     r1,r0                 ;1431
000054  2095              MOVS     r0,#0x95              ;1431
000056  f7fffffe          BL       RA8875_WriteReg
00005a  19e0              ADDS     r0,r4,r7              ;1432
00005c  1e40              SUBS     r0,r0,#1              ;1432
00005e  f3c02107          UBFX     r1,r0,#8,#8           ;1432
000062  2096              MOVS     r0,#0x96              ;1432
000064  f7fffffe          BL       RA8875_WriteReg
000068  19a8              ADDS     r0,r5,r6              ;1433
00006a  1e40              SUBS     r0,r0,#1              ;1433
00006c  b2c1              UXTB     r1,r0                 ;1433
00006e  2097              MOVS     r0,#0x97              ;1433
000070  f7fffffe          BL       RA8875_WriteReg
000074  19a8              ADDS     r0,r5,r6              ;1434
000076  1e40              SUBS     r0,r0,#1              ;1434
000078  f3c02107          UBFX     r1,r0,#8,#8           ;1434
00007c  2098              MOVS     r0,#0x98              ;1434
00007e  f7fffffe          BL       RA8875_WriteReg
000082  4640              MOV      r0,r8                 ;1436
000084  f7fffffe          BL       RA8875_SetFrontColor
000088  2001              MOVS     r0,#1                 ;1438
00008a  4908              LDR      r1,|L20.172|
00008c  7008              STRB     r0,[r1,#0]            ;1438
00008e  2090              MOVS     r0,#0x90              ;1440
000090  f7fffffe          BL       RA8875_WriteCmd
000094  20b0              MOVS     r0,#0xb0              ;1441
000096  f7fffffe          BL       RA8875_WriteData
00009a  f7fffffe          BL       RA8875_WaitBusy
00009e  2000              MOVS     r0,#0                 ;1444
0000a0  4902              LDR      r1,|L20.172|
0000a2  7008              STRB     r0,[r1,#0]            ;1444
0000a4  bf00              NOP      
0000a6  e7b5              B        |L20.20|
;;;1446   
                          ENDP

                  |L20.168|
                          DCD      g_LcdDirection
                  |L20.172|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_GetPixel||, CODE, READONLY, ALIGN=2

                  RA8875_GetPixel PROC
;;;992    */
;;;993    uint16_t RA8875_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;994    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;995    	uint16_t usRGB;
;;;996    
;;;997    //	RA8875_WriteReg(0x40, (1 << 0));	/* 设置为绘图模式，读取光标不自动加1 */
;;;998    
;;;999    	RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       RA8875_SetReadCursor
;;;1000   
;;;1001   	s_ucRA8875Busy = 1;
00000e  2001              MOVS     r0,#1
000010  4909              LDR      r1,|L21.56|
000012  7008              STRB     r0,[r1,#0]
;;;1002   
;;;1003   	RA8875_WriteCmd(0x02);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RA8875_WriteCmd
;;;1004   	usRGB = RA8875_ReadData16();	/* 第1次读取数据丢弃 */
00001a  f7fffffe          BL       RA8875_ReadData16
00001e  4606              MOV      r6,r0
;;;1005   	usRGB = RA8875_ReadData16();
000020  f7fffffe          BL       RA8875_ReadData16
000024  4606              MOV      r6,r0
;;;1006   	usRGB = RA8875_ReadData16();
000026  f7fffffe          BL       RA8875_ReadData16
00002a  4606              MOV      r6,r0
;;;1007   
;;;1008   	s_ucRA8875Busy = 0;
00002c  2000              MOVS     r0,#0
00002e  4902              LDR      r1,|L21.56|
000030  7008              STRB     r0,[r1,#0]
;;;1009   
;;;1010   	return usRGB;
000032  4630              MOV      r0,r6
;;;1011   }
000034  bd70              POP      {r4-r6,pc}
;;;1012   
                          ENDP

000036  0000              DCW      0x0000
                  |L21.56|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_GetPixelGUI||, CODE, READONLY, ALIGN=2

                  RA8875_GetPixelGUI PROC
;;;2060   */
;;;2061   uint16_t RA8875_GetPixelGUI(uint16_t _usX, uint16_t _usY)
000000  b510              PUSH     {r4,lr}
;;;2062   {
000002  4602              MOV      r2,r0
;;;2063   	uint16_t usRGB;
;;;2064   	
;;;2065   	s_ucRA8875Busy = 1;
000004  2301              MOVS     r3,#1
000006  4c13              LDR      r4,|L22.84|
000008  7023              STRB     r3,[r4,#0]
;;;2066   
;;;2067   //	RA8875_WriteReg(0x40, (1 << 0));	/* 设置为绘图模式，读取光标不自动加1 */
;;;2068   //  RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */
;;;2069   	
;;;2070   	RA8875_REG = 0x4A; RA8875_RAM = _usX;
00000a  234a              MOVS     r3,#0x4a
00000c  4c12              LDR      r4,|L22.88|
00000e  8023              STRH     r3,[r4,#0]
000010  f04f43d8          MOV      r3,#0x6c000000
000014  801a              STRH     r2,[r3,#0]
;;;2071   	RA8875_REG = 0x4B; RA8875_RAM = _usX >> 8;
000016  234b              MOVS     r3,#0x4b
000018  8023              STRH     r3,[r4,#0]
00001a  1213              ASRS     r3,r2,#8
00001c  f04f44d8          MOV      r4,#0x6c000000
000020  8023              STRH     r3,[r4,#0]
;;;2072   	RA8875_REG = 0x4C; RA8875_RAM = _usY;
000022  234c              MOVS     r3,#0x4c
000024  4c0c              LDR      r4,|L22.88|
000026  8023              STRH     r3,[r4,#0]
000028  f04f43d8          MOV      r3,#0x6c000000
00002c  8019              STRH     r1,[r3,#0]
;;;2073   	RA8875_REG = 0x4D; RA8875_RAM = _usY >> 8;
00002e  234d              MOVS     r3,#0x4d
000030  8023              STRH     r3,[r4,#0]
000032  120b              ASRS     r3,r1,#8
000034  f04f44d8          MOV      r4,#0x6c000000
000038  8023              STRH     r3,[r4,#0]
;;;2074   	RA8875_REG = 0x02;
00003a  2302              MOVS     r3,#2
00003c  4c06              LDR      r4,|L22.88|
00003e  8023              STRH     r3,[r4,#0]
;;;2075   	
;;;2076   	usRGB = RA8875_RAM;
000040  f04f43d8          MOV      r3,#0x6c000000
000044  8818              LDRH     r0,[r3,#0]
;;;2077   	usRGB = RA8875_RAM;
000046  8818              LDRH     r0,[r3,#0]
;;;2078   	usRGB = RA8875_RAM;
000048  8818              LDRH     r0,[r3,#0]
;;;2079   
;;;2080   	s_ucRA8875Busy = 0;
00004a  2300              MOVS     r3,#0
00004c  4c01              LDR      r4,|L22.84|
00004e  7023              STRB     r3,[r4,#0]
;;;2081   
;;;2082   	return usRGB;
;;;2083   }
000050  bd10              POP      {r4,pc}
;;;2084   
                          ENDP

000052  0000              DCW      0x0000
                  |L22.84|
                          DCD      s_ucRA8875Busy
                  |L22.88|
                          DCD      0x6c080000

                          AREA ||i.RA8875_InitHard||, CODE, READONLY, ALIGN=2

                  RA8875_InitHard PROC
;;;152    */
;;;153    void RA8875_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155    	uint8_t ucGPIX;
;;;156    	
;;;157    	RA8875_ConfigGPIO();	/* 配置GPIO FSMC等 */
000002  f7fffffe          BL       RA8875_ConfigGPIO
;;;158    
;;;159    	/* 读取 RA8875 芯片额GPIX引脚的电平状态；1表示4.3寸屏；0表示7寸屏
;;;160    	【备注】这是安富莱电子为了便于统一测试例程，在LCD模块上做的硬件标识。在做产品时，不必自动识别。
;;;161    	*/
;;;162    	ucGPIX = RA8875_ReadReg(0xC7);
000006  20c7              MOVS     r0,#0xc7
000008  f7fffffe          BL       RA8875_ReadReg
00000c  4604              MOV      r4,r0
;;;163    
;;;164    	if (ucGPIX == 1)	/* 	GPIX = 1 表示 4.3 寸屏 480x272 */
00000e  2c01              CMP      r4,#1
000010  d161              BNE      |L23.214|
;;;165    	{
;;;166    		/* 初始化PLL.  晶振频率为25M */
;;;167    		RA8875_WriteCmd(0x88);
000012  2088              MOVS     r0,#0x88
000014  f7fffffe          BL       RA8875_WriteCmd
;;;168    		RA8875_Delaly1us();		/* 延迟1us */
000018  f7fffffe          BL       RA8875_Delaly1us
;;;169    		RA8875_WriteData(10);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       RA8875_WriteData
;;;170    
;;;171    	    RA8875_Delaly1ms();
000022  f7fffffe          BL       RA8875_Delaly1ms
;;;172    
;;;173    		RA8875_WriteCmd(0x89);
000026  2089              MOVS     r0,#0x89
000028  f7fffffe          BL       RA8875_WriteCmd
;;;174    		RA8875_Delaly1us();		/* 延迟1us */
00002c  f7fffffe          BL       RA8875_Delaly1us
;;;175    		RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       RA8875_WriteData
;;;176    
;;;177    		/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;178    		  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;179    		          = 25M * (10 + 1) / ((0 + 1) * (2 ^ 2))
;;;180    				  = 68.75MHz
;;;181    		*/
;;;182    
;;;183    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;184    	    RA8875_Delaly1ms();
000036  f7fffffe          BL       RA8875_Delaly1ms
;;;185    		RA8875_Delaly1ms();
00003a  f7fffffe          BL       RA8875_Delaly1ms
;;;186    
;;;187    		/*
;;;188    			配置系统控制寄存器。 中文pdf 第18页:
;;;189    
;;;190    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;191    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;192    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;193    
;;;194    			bit1:0 MCUIF 选择
;;;195    				00b : 8-位MCU 接口。
;;;196    				1xb : 16-位MCU 接口。 【选这个】
;;;197    		*/
;;;198    		if (g_RA8875_IF == RA_HARD_8080_16)
00003e  4868              LDR      r0,|L23.480|
000040  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000042  2803              CMP      r0,#3
000044  d104              BNE      |L23.80|
;;;199    		{
;;;200    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
000046  210a              MOVS     r1,#0xa
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       RA8875_WriteReg
00004e  e003              B        |L23.88|
                  |L23.80|
;;;201    		}
;;;202    		else
;;;203    		{
;;;204    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
000050  2108              MOVS     r1,#8
000052  2010              MOVS     r0,#0x10
000054  f7fffffe          BL       RA8875_WriteReg
                  |L23.88|
;;;205    		}
;;;206    
;;;207    		/* REG[04h] Pixel Clock Setting Register   PCSR
;;;208    			bit7  PCLK Inversion
;;;209    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;210    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;211    			bit1:0 PCLK 频率周期设定
;;;212    				Pixel Clock  PCLK 频率周期设定。
;;;213    				00b: PCLK 频率周期= 系统频率周期。
;;;214    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;215    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;216    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;217    		*/
;;;218    	    RA8875_WriteReg(0x04, 0x82);    /* 设置PCLK反相 */
000058  2182              MOVS     r1,#0x82
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       RA8875_WriteReg
;;;219    	    RA8875_Delaly1ms();
000060  f7fffffe          BL       RA8875_Delaly1ms
;;;220    
;;;221    	    //Horizontal set
;;;222    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;223    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;224    	    RA8875_WriteReg(0x14, 0x3B);
000064  213b              MOVS     r1,#0x3b
000066  2014              MOVS     r0,#0x14
000068  f7fffffe          BL       RA8875_WriteReg
;;;225    	    RA8875_WriteReg(0x15, 0x00);
00006c  2100              MOVS     r1,#0
00006e  2015              MOVS     r0,#0x15
000070  f7fffffe          BL       RA8875_WriteReg
;;;226    
;;;227    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;228    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;229    		RA8875_WriteReg(0x16, 0x01);
000074  2101              MOVS     r1,#1
000076  2016              MOVS     r0,#0x16
000078  f7fffffe          BL       RA8875_WriteReg
;;;230    
;;;231    	    //HSTR//HSYNC Start Position[4:0]
;;;232    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;233    		RA8875_WriteReg(0x17, 0x00);
00007c  2100              MOVS     r1,#0
00007e  2017              MOVS     r0,#0x17
000080  f7fffffe          BL       RA8875_WriteReg
;;;234    
;;;235    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;236    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;237    		RA8875_WriteReg(0x18, 0x05);
000084  2105              MOVS     r1,#5
000086  2018              MOVS     r0,#0x18
000088  f7fffffe          BL       RA8875_WriteReg
;;;238    
;;;239    	    //Vertical set
;;;240    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;241    	    //Vertical pixels = VDHR + 1
;;;242    		RA8875_WriteReg(0x19, 0x0F);
00008c  210f              MOVS     r1,#0xf
00008e  2019              MOVS     r0,#0x19
000090  f7fffffe          BL       RA8875_WriteReg
;;;243    
;;;244    	    //VDHR1 //Vertical Display Height Bit [8]
;;;245    	    //Vertical pixels = VDHR + 1
;;;246    		RA8875_WriteReg(0x1A, 0x01);
000094  2101              MOVS     r1,#1
000096  201a              MOVS     r0,#0x1a
000098  f7fffffe          BL       RA8875_WriteReg
;;;247    
;;;248    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;249    	    //Vertical Non-Display area = (VNDR + 1)
;;;250    		RA8875_WriteReg(0x1B, 0x02);
00009c  2102              MOVS     r1,#2
00009e  201b              MOVS     r0,#0x1b
0000a0  f7fffffe          BL       RA8875_WriteReg
;;;251    
;;;252    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;253    	    //Vertical Non-Display area = (VNDR + 1)
;;;254    		RA8875_WriteReg(0x1C, 0x00);
0000a4  2100              MOVS     r1,#0
0000a6  201c              MOVS     r0,#0x1c
0000a8  f7fffffe          BL       RA8875_WriteReg
;;;255    
;;;256    	    //VSTR0 //VSYNC Start Position[7:0]
;;;257    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;258    		RA8875_WriteReg(0x1D, 0x07);
0000ac  2107              MOVS     r1,#7
0000ae  201d              MOVS     r0,#0x1d
0000b0  f7fffffe          BL       RA8875_WriteReg
;;;259    
;;;260    	    //VSTR1 //VSYNC Start Position[8]
;;;261    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;262    		RA8875_WriteReg(0x1E, 0x00);
0000b4  2100              MOVS     r1,#0
0000b6  201e              MOVS     r0,#0x1e
0000b8  f7fffffe          BL       RA8875_WriteReg
;;;263    
;;;264    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;265    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;266    	    RA8875_WriteReg(0x1F, 0x09);
0000bc  2109              MOVS     r1,#9
0000be  201f              MOVS     r0,#0x1f
0000c0  f7fffffe          BL       RA8875_WriteReg
;;;267    
;;;268    
;;;269    	    g_LcdHeight = LCD_43_HEIGHT;
0000c4  f44f7088          MOV      r0,#0x110
0000c8  4946              LDR      r1,|L23.484|
0000ca  8008              STRH     r0,[r1,#0]
;;;270    		g_LcdWidth = LCD_43_WIDTH;
0000cc  f44f70f0          MOV      r0,#0x1e0
0000d0  4945              LDR      r1,|L23.488|
0000d2  8008              STRH     r0,[r1,#0]
0000d4  e05e              B        |L23.404|
                  |L23.214|
;;;271    	}
;;;272    	else	/* GPIX = 0 表示7寸屏(800x480) */
;;;273    	{
;;;274    	    g_LcdHeight = LCD_70_HEIGHT;
0000d6  f44f70f0          MOV      r0,#0x1e0
0000da  4942              LDR      r1,|L23.484|
0000dc  8008              STRH     r0,[r1,#0]
;;;275    		g_LcdWidth = LCD_70_WIDTH;
0000de  f44f7048          MOV      r0,#0x320
0000e2  4941              LDR      r1,|L23.488|
0000e4  8008              STRH     r0,[r1,#0]
;;;276    
;;;277    		#if 1	/* 75MHz */
;;;278    			RA8875_WriteCmd(0x88);
0000e6  2088              MOVS     r0,#0x88
0000e8  f7fffffe          BL       RA8875_WriteCmd
;;;279    			RA8875_Delaly1us();		/* 延迟1us */
0000ec  f7fffffe          BL       RA8875_Delaly1us
;;;280    			RA8875_WriteData(11);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 11 */
0000f0  200b              MOVS     r0,#0xb
0000f2  f7fffffe          BL       RA8875_WriteData
;;;281    
;;;282    			RA8875_Delaly1ms();
0000f6  f7fffffe          BL       RA8875_Delaly1ms
;;;283    
;;;284    			RA8875_WriteCmd(0x89);
0000fa  2089              MOVS     r0,#0x89
0000fc  f7fffffe          BL       RA8875_WriteCmd
;;;285    			RA8875_Delaly1us();		/* 延迟1us */
000100  f7fffffe          BL       RA8875_Delaly1us
;;;286    			RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
000104  2002              MOVS     r0,#2
000106  f7fffffe          BL       RA8875_WriteData
;;;287    		#else	/* 81.25M */
;;;288    			/* 初始化PLL.  晶振频率为25M */
;;;289    			RA8875_WriteCmd(0x88);
;;;290    			RA8875_Delaly1us();		/* 延迟1us */
;;;291    			RA8875_WriteData(12);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 12 */
;;;292    
;;;293    			RA8875_Delaly1ms();
;;;294    
;;;295    			RA8875_WriteCmd(0x89);
;;;296    			RA8875_Delaly1us();		/* 延迟1us */
;;;297    			RA8875_WriteData(2);	/* PLLDIVK[2:0] = 2, 除以4 */
;;;298    
;;;299    			/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;300    			  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;301    					  = 25M * (12 + 1) / ((0 + 1) * (2 ^ 2))
;;;302    					  = 81.25MHz
;;;303    			*/
;;;304    		#endif
;;;305    		
;;;306    
;;;307    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;308    	    RA8875_Delaly1ms();
00010a  f7fffffe          BL       RA8875_Delaly1ms
;;;309    
;;;310    		/*
;;;311    			配置系统控制寄存器。 中文pdf 第18页:
;;;312    
;;;313    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;314    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;315    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;316    
;;;317    			bit1:0 MCUIF 选择
;;;318    				00b : 8-位MCU 接口。
;;;319    				1xb : 16-位MCU 接口。 【选这个】
;;;320    		*/
;;;321    		if (g_RA8875_IF == RA_HARD_8080_16)
00010e  4834              LDR      r0,|L23.480|
000110  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000112  2803              CMP      r0,#3
000114  d104              BNE      |L23.288|
;;;322    		{
;;;323    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
000116  210a              MOVS     r1,#0xa
000118  2010              MOVS     r0,#0x10
00011a  f7fffffe          BL       RA8875_WriteReg
00011e  e003              B        |L23.296|
                  |L23.288|
;;;324    		}
;;;325    		else
;;;326    		{
;;;327    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
000120  2108              MOVS     r1,#8
000122  2010              MOVS     r0,#0x10
000124  f7fffffe          BL       RA8875_WriteReg
                  |L23.296|
;;;328    		}
;;;329    
;;;330    		/* REG[04h] Pixel Clock Setting Register (PCSR)
;;;331    			bit7  PCLK Inversion
;;;332    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;333    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;334    			bit1:0 PCLK 频率周期设定
;;;335    				Pixel Clock ,PCLK 频率周期设定。
;;;336    				00b: PCLK 频率周期= 系统频率周期。
;;;337    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;338    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;339    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;340    		*/
;;;341    	    RA8875_WriteReg(0x04, 0x81);
000128  2181              MOVS     r1,#0x81
00012a  2004              MOVS     r0,#4
00012c  f7fffffe          BL       RA8875_WriteReg
;;;342    	    RA8875_Delaly1ms();
000130  f7fffffe          BL       RA8875_Delaly1ms
;;;343    
;;;344    	#if 1
;;;345    		/* OTD9960 & OTA7001 设置 */
;;;346    		RA8875_WriteReg(0x14, 0x63);
000134  2163              MOVS     r1,#0x63
000136  2014              MOVS     r0,#0x14
000138  f7fffffe          BL       RA8875_WriteReg
;;;347    		RA8875_WriteReg(0x15, 0x00);
00013c  2100              MOVS     r1,#0
00013e  2015              MOVS     r0,#0x15
000140  f7fffffe          BL       RA8875_WriteReg
;;;348    		RA8875_WriteReg(0x16, 0x03);
000144  2103              MOVS     r1,#3
000146  2016              MOVS     r0,#0x16
000148  f7fffffe          BL       RA8875_WriteReg
;;;349    		RA8875_WriteReg(0x17, 0x03);
00014c  2103              MOVS     r1,#3
00014e  2017              MOVS     r0,#0x17
000150  f7fffffe          BL       RA8875_WriteReg
;;;350    		RA8875_WriteReg(0x18, 0x0B);
000154  210b              MOVS     r1,#0xb
000156  2018              MOVS     r0,#0x18
000158  f7fffffe          BL       RA8875_WriteReg
;;;351    		RA8875_WriteReg(0x19, 0xDF);
00015c  21df              MOVS     r1,#0xdf
00015e  2019              MOVS     r0,#0x19
000160  f7fffffe          BL       RA8875_WriteReg
;;;352    		RA8875_WriteReg(0x1A, 0x01);
000164  2101              MOVS     r1,#1
000166  201a              MOVS     r0,#0x1a
000168  f7fffffe          BL       RA8875_WriteReg
;;;353    		RA8875_WriteReg(0x1B, 0x1F);
00016c  211f              MOVS     r1,#0x1f
00016e  201b              MOVS     r0,#0x1b
000170  f7fffffe          BL       RA8875_WriteReg
;;;354    		RA8875_WriteReg(0x1C, 0x00);
000174  2100              MOVS     r1,#0
000176  201c              MOVS     r0,#0x1c
000178  f7fffffe          BL       RA8875_WriteReg
;;;355    		RA8875_WriteReg(0x1D, 0x16);
00017c  2116              MOVS     r1,#0x16
00017e  201d              MOVS     r0,#0x1d
000180  f7fffffe          BL       RA8875_WriteReg
;;;356    		RA8875_WriteReg(0x1E, 0x00);
000184  2100              MOVS     r1,#0
000186  201e              MOVS     r0,#0x1e
000188  f7fffffe          BL       RA8875_WriteReg
;;;357    		RA8875_WriteReg(0x1F, 0x01);
00018c  2101              MOVS     r1,#1
00018e  201f              MOVS     r0,#0x1f
000190  f7fffffe          BL       RA8875_WriteReg
                  |L23.404|
;;;358    
;;;359    	#else	/* AT070TN92  setting */
;;;360    	    //Horizontal set
;;;361    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;362    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;363    	    RA8875_WriteReg(0x14, 0x4F);
;;;364    	    RA8875_WriteReg(0x15, 0x05);
;;;365    
;;;366    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;367    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;368    		RA8875_WriteReg(0x16, 0x0F);
;;;369    
;;;370    	    //HSTR//HSYNC Start Position[4:0]
;;;371    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;372    		RA8875_WriteReg(0x17, 0x01);
;;;373    
;;;374    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;375    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;376    		RA8875_WriteReg(0x18, 0x00);
;;;377    
;;;378    	    //Vertical set
;;;379    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;380    	    //Vertical pixels = VDHR + 1
;;;381    		RA8875_WriteReg(0x19, 0xDF);
;;;382    
;;;383    	    //VDHR1 //Vertical Display Height Bit [8]
;;;384    	    //Vertical pixels = VDHR + 1
;;;385    		RA8875_WriteReg(0x1A, 0x01);
;;;386    
;;;387    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;388    	    //Vertical Non-Display area = (VNDR + 1)
;;;389    		RA8875_WriteReg(0x1B, 0x0A);
;;;390    
;;;391    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;392    	    //Vertical Non-Display area = (VNDR + 1)
;;;393    		RA8875_WriteReg(0x1C, 0x00);
;;;394    
;;;395    	    //VSTR0 //VSYNC Start Position[7:0]
;;;396    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;397    		RA8875_WriteReg(0x1D, 0x0E);
;;;398    
;;;399    	    //VSTR1 //VSYNC Start Position[8]
;;;400    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;401    		RA8875_WriteReg(0x1E, 0x00);
;;;402    
;;;403    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;404    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;405    	    RA8875_WriteReg(0x1F, 0x01);
;;;406    	#endif
;;;407    	}
;;;408    
;;;409    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;410    	RA8875_WriteReg(0xC7, 0x01);	/* DISP = 1 */
000194  2101              MOVS     r1,#1
000196  20c7              MOVS     r0,#0xc7
000198  f7fffffe          BL       RA8875_WriteReg
;;;411    
;;;412    	/* LCD 显示/关闭讯号 (LCD Display on) */
;;;413    	RA8875_WriteReg(0x01, 0x80);
00019c  2180              MOVS     r1,#0x80
00019e  2001              MOVS     r0,#1
0001a0  f7fffffe          BL       RA8875_WriteReg
;;;414    
;;;415    	/* 	REG[40h] Memory Write Control Register 0 (MWCR0)
;;;416    
;;;417    		Bit 7	显示模式设定
;;;418    			0 : 绘图模式。
;;;419    			1 : 文字模式。
;;;420    
;;;421    		Bit 6	文字写入光标/内存写入光标设定
;;;422    			0 : 设定文字/内存写入光标为不显示。
;;;423    			1 : 设定文字/内存写入光标为显示。
;;;424    
;;;425    		Bit 5	文字写入光标/内存写入光标闪烁设定
;;;426    			0 : 游标不闪烁。
;;;427    			1 : 游标闪烁。
;;;428    
;;;429    		Bit 4   NA
;;;430    
;;;431    		Bit 3-2  绘图模式时的内存写入方向
;;;432    			00b : 左 -> 右，然后上 -> 下。
;;;433    			01b : 右 -> 左，然后上 -> 下。
;;;434    			10b : 上 -> 下，然后左 -> 右。
;;;435    			11b : 下 -> 上，然后左 -> 右。
;;;436    
;;;437    		Bit 1 	内存写入光标自动增加功能设定
;;;438    			0 : 当内存写入时光标位置自动加一。
;;;439    			1 : 当内存写入时光标位置不会自动加一。
;;;440    
;;;441    		Bit 0 内存读取光标自动增加功能设定
;;;442    			0 : 当内存读取时光标位置自动加一。
;;;443    			1 : 当内存读取时光标位置不会自动加一。
;;;444    	*/
;;;445    	//RA8875_WriteReg(0x40, 0x00);	/* 选择绘图模式 */	
;;;446    	RA8875_SetDirection(0);
0001a4  2000              MOVS     r0,#0
0001a6  f7fffffe          BL       RA8875_SetDirection
;;;447    
;;;448    	/* 	REG[41h] Memory Write Control Register1 (MWCR1)
;;;449    		写入目的位置，选择图层1
;;;450    	*/
;;;451    	RA8875_WriteReg(0x41, 0x00);	/* 选择绘图模式, 目的为CGRAM */
0001aa  2100              MOVS     r1,#0
0001ac  2041              MOVS     r0,#0x41
0001ae  f7fffffe          BL       RA8875_WriteReg
;;;452    
;;;453    	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
0001b2  480d              LDR      r0,|L23.488|
0001b4  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
0001b6  480b              LDR      r0,|L23.484|
0001b8  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
0001ba  2100              MOVS     r1,#0
0001bc  4608              MOV      r0,r1
0001be  f7fffffe          BL       RA8875_SetDispWin
;;;454    
;;;455    	if ((g_RA8875_IF == RA_HARD_SPI) || (g_RA8875_IF == RA_SOFT_SPI))
0001c2  4807              LDR      r0,|L23.480|
0001c4  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
0001c6  2802              CMP      r0,#2
0001c8  d003              BEQ      |L23.466|
0001ca  4805              LDR      r0,|L23.480|
0001cc  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
0001ce  2801              CMP      r0,#1
0001d0  d102              BNE      |L23.472|
                  |L23.466|
;;;456    	{
;;;457    		RA8875_HighSpeedSPI();		/* 配置完毕后，切换SPI到高速模式 */
0001d2  f7fffffe          BL       RA8875_HighSpeedSPI
0001d6  e001              B        |L23.476|
                  |L23.472|
;;;458    	}
;;;459    	else
;;;460    	{
;;;461    		#ifdef WRTIE_SF_EN		/* 使能了字库图片芯片写功能，配置CPU的SPI接口和PWM-GPIO */
;;;462    			bsp_InitRA8875Flash();		
0001d8  f7fffffe          BL       bsp_InitRA8875Flash
                  |L23.476|
;;;463    		#endif	
;;;464    	}
;;;465    }
0001dc  bd10              POP      {r4,pc}
;;;466    
                          ENDP

0001de  0000              DCW      0x0000
                  |L23.480|
                          DCD      g_RA8875_IF
                  |L23.484|
                          DCD      g_LcdHeight
                  |L23.488|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_IsBusy||, CODE, READONLY, ALIGN=2

                  RA8875_IsBusy PROC
;;;672    */
;;;673    uint8_t RA8875_IsBusy(void)
000000  4803              LDR      r0,|L24.16|
;;;674    {
;;;675    	if (s_ucRA8875Busy == 0)
000002  7800              LDRB     r0,[r0,#0]  ; s_ucRA8875Busy
000004  b908              CBNZ     r0,|L24.10|
;;;676    	{
;;;677    		return 0;
000006  2000              MOVS     r0,#0
                  |L24.8|
;;;678    	}
;;;679    	return 1;
;;;680    }
000008  4770              BX       lr
                  |L24.10|
00000a  2001              MOVS     r0,#1                 ;679
00000c  e7fc              B        |L24.8|
;;;681    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_Layer1Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer1Visable PROC
;;;702    */
;;;703    void RA8875_Layer1Visable(void)
000000  b510              PUSH     {r4,lr}
;;;704    {
;;;705    	/* 0x52 寄存器的 Bit2:0
;;;706    		图层显示模式
;;;707    		000b : 只有图层1 显示。
;;;708    		001b : 只有图层2 显示。
;;;709    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;710    		011b : 显示图层1 与图层2 的通透模式。
;;;711    		100b : Boolean OR。
;;;712    		101b : Boolean AND。
;;;713    		110b : 浮动窗口模式 (Floating window mode)。
;;;714    		111b :保留。
;;;715    	*/
;;;716    	RA8875_WriteReg(0x52, RA8875_ReadReg(0x52) & 0xF8);	/* 只有图层1 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00004f8          AND      r4,r0,#0xf8
00000c  4621              MOV      r1,r4
00000e  2052              MOVS     r0,#0x52
000010  f7fffffe          BL       RA8875_WriteReg
;;;717    }
000014  bd10              POP      {r4,pc}
;;;718    
                          ENDP


                          AREA ||i.RA8875_Layer2Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer2Visable PROC
;;;726    */
;;;727    void RA8875_Layer2Visable(void)
000000  b510              PUSH     {r4,lr}
;;;728    {
;;;729    	/* 0x52 寄存器的 Bit2:0
;;;730    		图层显示模式
;;;731    		000b : 只有图层1 显示。
;;;732    		001b : 只有图层2 显示。
;;;733    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;734    		011b : 显示图层1 与图层2 的通透模式。
;;;735    		100b : Boolean OR。
;;;736    		101b : Boolean AND。
;;;737    		110b : 浮动窗口模式 (Floating window mode)。
;;;738    		111b :保留。
;;;739    	*/
;;;740    	RA8875_WriteReg(0x52, (RA8875_ReadReg(0x52) & 0xF8) | 0x01);	/* 只有图层2 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00000f8          AND      r0,r0,#0xf8
00000c  1c44              ADDS     r4,r0,#1
00000e  4621              MOV      r1,r4
000010  2052              MOVS     r0,#0x52
000012  f7fffffe          BL       RA8875_WriteReg
;;;741    }
000016  bd10              POP      {r4,pc}
;;;742    
                          ENDP


                          AREA ||i.RA8875_PutPixel||, CODE, READONLY, ALIGN=2

                  RA8875_PutPixel PROC
;;;939    */
;;;940    void RA8875_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;941    {	
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;942    	if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000008  482b              LDR      r0,|L27.184|
00000a  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00000c  2803              CMP      r0,#3
00000e  d141              BNE      |L27.148|
;;;943    	{
;;;944    		// 优化 RA8875_SetCursor(_usX, _usY);
;;;945    		s_ucRA8875Busy = 1;
000010  2001              MOVS     r0,#1
000012  492a              LDR      r1,|L27.188|
000014  7008              STRB     r0,[r1,#0]
;;;946    		{	
;;;947    			if (g_LcdDirection > 1)	/* 竖屏  */
000016  482a              LDR      r0,|L27.192|
000018  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00001a  2801              CMP      r0,#1
00001c  dd18              BLE      |L27.80|
;;;948    			{
;;;949    				RA8875_REG = 0x46; RA8875_RAM = _usY;
00001e  2046              MOVS     r0,#0x46
000020  4928              LDR      r1,|L27.196|
000022  8008              STRH     r0,[r1,#0]
000024  f04f40d8          MOV      r0,#0x6c000000
000028  8005              STRH     r5,[r0,#0]
;;;950    				RA8875_REG = 0x47; RA8875_RAM = _usY >> 8;
00002a  2047              MOVS     r0,#0x47
00002c  8008              STRH     r0,[r1,#0]
00002e  1228              ASRS     r0,r5,#8
000030  f04f41d8          MOV      r1,#0x6c000000
000034  8008              STRH     r0,[r1,#0]
;;;951    				RA8875_REG = 0x48; RA8875_RAM = _usX;
000036  2048              MOVS     r0,#0x48
000038  4922              LDR      r1,|L27.196|
00003a  8008              STRH     r0,[r1,#0]
00003c  f04f40d8          MOV      r0,#0x6c000000
000040  8004              STRH     r4,[r0,#0]
;;;952    				RA8875_REG = 0x49; RA8875_RAM = _usX >> 8;
000042  2049              MOVS     r0,#0x49
000044  8008              STRH     r0,[r1,#0]
000046  1220              ASRS     r0,r4,#8
000048  f04f41d8          MOV      r1,#0x6c000000
00004c  8008              STRH     r0,[r1,#0]
00004e  e017              B        |L27.128|
                  |L27.80|
;;;953    			}
;;;954    			else	/* 横屏 */
;;;955    			{
;;;956    				RA8875_REG = 0x46; RA8875_RAM = _usX;
000050  2046              MOVS     r0,#0x46
000052  491c              LDR      r1,|L27.196|
000054  8008              STRH     r0,[r1,#0]
000056  f04f40d8          MOV      r0,#0x6c000000
00005a  8004              STRH     r4,[r0,#0]
;;;957    				RA8875_REG = 0x47; RA8875_RAM = _usX >> 8;
00005c  2047              MOVS     r0,#0x47
00005e  8008              STRH     r0,[r1,#0]
000060  1220              ASRS     r0,r4,#8
000062  f04f41d8          MOV      r1,#0x6c000000
000066  8008              STRH     r0,[r1,#0]
;;;958    				RA8875_REG = 0x48; RA8875_RAM = _usY;
000068  2048              MOVS     r0,#0x48
00006a  4916              LDR      r1,|L27.196|
00006c  8008              STRH     r0,[r1,#0]
00006e  f04f40d8          MOV      r0,#0x6c000000
000072  8005              STRH     r5,[r0,#0]
;;;959    				RA8875_REG = 0x49; RA8875_RAM = _usY >> 8;	
000074  2049              MOVS     r0,#0x49
000076  8008              STRH     r0,[r1,#0]
000078  1228              ASRS     r0,r5,#8
00007a  f04f41d8          MOV      r1,#0x6c000000
00007e  8008              STRH     r0,[r1,#0]
                  |L27.128|
;;;960    			}
;;;961    		}
;;;962    		
;;;963    		// 优化 RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
;;;964    		// 优化 RA8875_WriteData16(_usColor);
;;;965    		
;;;966    		RA8875_REG = 0x02;
000080  2002              MOVS     r0,#2
000082  4910              LDR      r1,|L27.196|
000084  8008              STRH     r0,[r1,#0]
;;;967    		RA8875_RAM = _usColor;
000086  f04f40d8          MOV      r0,#0x6c000000
00008a  8006              STRH     r6,[r0,#0]
;;;968    
;;;969    		s_ucRA8875Busy = 0;
00008c  2000              MOVS     r0,#0
00008e  490b              LDR      r1,|L27.188|
000090  7008              STRB     r0,[r1,#0]
000092  e00f              B        |L27.180|
                  |L27.148|
;;;970    	}
;;;971    	else	/* SPI接口分支 */
;;;972    	{
;;;973    		RA8875_SetCursor(_usX, _usY);
000094  4629              MOV      r1,r5
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       RA8875_SetCursor
;;;974    		s_ucRA8875Busy = 1;
00009c  2001              MOVS     r0,#1
00009e  4907              LDR      r1,|L27.188|
0000a0  7008              STRB     r0,[r1,#0]
;;;975    
;;;976    		RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       RA8875_WriteCmd
;;;977    		RA8875_WriteData16(_usColor);
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       RA8875_WriteData16
;;;978    
;;;979    		s_ucRA8875Busy = 0;
0000ae  2000              MOVS     r0,#0
0000b0  4902              LDR      r1,|L27.188|
0000b2  7008              STRB     r0,[r1,#0]
                  |L27.180|
;;;980    	}
;;;981    }
0000b4  bd70              POP      {r4-r6,pc}
;;;982    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L27.184|
                          DCD      g_RA8875_IF
                  |L27.188|
                          DCD      s_ucRA8875Busy
                  |L27.192|
                          DCD      g_LcdDirection
                  |L27.196|
                          DCD      0x6c080000

                          AREA ||i.RA8875_PutPixelGUI||, CODE, READONLY, ALIGN=2

                  RA8875_PutPixelGUI PROC
;;;2035   */
;;;2036   void RA8875_PutPixelGUI(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;2037   {	
;;;2038   	s_ucRA8875Busy = 1;
000002  2301              MOVS     r3,#1
000004  4c11              LDR      r4,|L28.76|
000006  7023              STRB     r3,[r4,#0]
;;;2039   	
;;;2040   	RA8875_REG = 0x46; RA8875_RAM = _usX;
000008  2346              MOVS     r3,#0x46
00000a  4c11              LDR      r4,|L28.80|
00000c  8023              STRH     r3,[r4,#0]
00000e  f04f43d8          MOV      r3,#0x6c000000
000012  8018              STRH     r0,[r3,#0]
;;;2041   	RA8875_REG = 0x47; RA8875_RAM = _usX >> 8;
000014  2347              MOVS     r3,#0x47
000016  8023              STRH     r3,[r4,#0]
000018  1203              ASRS     r3,r0,#8
00001a  f04f44d8          MOV      r4,#0x6c000000
00001e  8023              STRH     r3,[r4,#0]
;;;2042   	RA8875_REG = 0x48; RA8875_RAM = _usY;
000020  2348              MOVS     r3,#0x48
000022  4c0b              LDR      r4,|L28.80|
000024  8023              STRH     r3,[r4,#0]
000026  f04f43d8          MOV      r3,#0x6c000000
00002a  8019              STRH     r1,[r3,#0]
;;;2043   	RA8875_REG = 0x49; RA8875_RAM = _usY >> 8;	
00002c  2349              MOVS     r3,#0x49
00002e  8023              STRH     r3,[r4,#0]
000030  120b              ASRS     r3,r1,#8
000032  f04f44d8          MOV      r4,#0x6c000000
000036  8023              STRH     r3,[r4,#0]
;;;2044   
;;;2045   	RA8875_REG = 0x02;
000038  2302              MOVS     r3,#2
00003a  4c05              LDR      r4,|L28.80|
00003c  8023              STRH     r3,[r4,#0]
;;;2046   	RA8875_RAM = _usColor;
00003e  f04f43d8          MOV      r3,#0x6c000000
000042  801a              STRH     r2,[r3,#0]
;;;2047   
;;;2048   	s_ucRA8875Busy = 0;
000044  2300              MOVS     r3,#0
000046  4c01              LDR      r4,|L28.76|
000048  7023              STRB     r3,[r4,#0]
;;;2049   }
00004a  bd10              POP      {r4,pc}
;;;2050   
                          ENDP

                  |L28.76|
                          DCD      s_ucRA8875Busy
                  |L28.80|
                          DCD      0x6c080000

                          AREA ||i.RA8875_QuitDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_QuitDirectDraw PROC
;;;1241   */
;;;1242   void RA8875_QuitDirectDraw(void)
000000  b510              PUSH     {r4,lr}
;;;1243   {
;;;1244   	s_ucRA8875Busy = 0;
000002  2000              MOVS     r0,#0
000004  4902              LDR      r1,|L29.16|
000006  7008              STRB     r0,[r1,#0]
;;;1245   
;;;1246   	/* 退出窗口绘图模式 */
;;;1247   	RA8875_QuitWinMode();
000008  f7fffffe          BL       RA8875_QuitWinMode
;;;1248   }
00000c  bd10              POP      {r4,pc}
;;;1249   
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_QuitWinMode||, CODE, READONLY, ALIGN=2

                  RA8875_QuitWinMode PROC
;;;1930   */
;;;1931   void RA8875_QuitWinMode(void)
000000  b510              PUSH     {r4,lr}
;;;1932   {
;;;1933   	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
000002  4804              LDR      r0,|L30.20|
000004  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
000006  4804              LDR      r0,|L30.24|
000008  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RA8875_SetDispWin
;;;1934   }
000012  bd10              POP      {r4,pc}
;;;1935   
                          ENDP

                  |L30.20|
                          DCD      g_LcdWidth
                  |L30.24|
                          DCD      g_LcdHeight

                          AREA ||i.RA8875_RTERect||, CODE, READONLY, ALIGN=2

                  RA8875_RTERect PROC
;;;2092   */
;;;2093   void RA8875_RTERect(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t _usColor) 
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2094   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;2095   	s_ucRA8875Busy = 1;	
000010  2001              MOVS     r0,#1
000012  490e              LDR      r1,|L31.76|
000014  7008              STRB     r0,[r1,#0]
;;;2096   	
;;;2097   	BTE_SetTarBlock(x0, y0, y1-y0+1, x1-x0+1, 0);	/* 设置BTE位置和宽度高度 */
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  1b30              SUBS     r0,r6,r4
00001c  1c40              ADDS     r0,r0,#1
00001e  b283              UXTH     r3,r0
000020  1b78              SUBS     r0,r7,r5
000022  1c40              ADDS     r0,r0,#1
000024  b282              UXTH     r2,r0
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       BTE_SetTarBlock
;;;2098   	BTE_SetOperateCode(0x0C);	        			/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
00002e  200c              MOVS     r0,#0xc
000030  f7fffffe          BL       BTE_SetOperateCode
;;;2099   	RA8875_SetFrontColor(_usColor);			        /* 设置BTE前景色 */
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       RA8875_SetFrontColor
;;;2100   	BTE_Start();				        			/* 开启BTE 功能 */
00003a  f7fffffe          BL       BTE_Start
;;;2101   	BTE_Wait();	
00003e  f7fffffe          BL       BTE_Wait
;;;2102   
;;;2103   	s_ucRA8875Busy = 0;
000042  2000              MOVS     r0,#0
000044  4901              LDR      r1,|L31.76|
000046  7008              STRB     r0,[r1,#0]
;;;2104   }
000048  e8bd83f8          POP      {r3-r9,pc}
;;;2105   
                          ENDP

                  |L31.76|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_ReadID||, CODE, READONLY, ALIGN=1

                  RA8875_ReadID PROC
;;;84     */
;;;85     uint16_t RA8875_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87     	RA8875_ConfigGPIO();
000002  f7fffffe          BL       RA8875_ConfigGPIO
;;;88     	
;;;89     	return RA8875_ReadReg(0x00);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       RA8875_ReadReg
;;;90     }
00000c  bd10              POP      {r4,pc}
;;;91     
                          ENDP


                          AREA ||i.RA8875_ReadReg||, CODE, READONLY, ALIGN=2

                  RA8875_ReadReg PROC
;;;117    */
;;;118    uint8_t RA8875_ReadReg(uint8_t _ucRegAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
000002  4604              MOV      r4,r0
;;;120    	uint8_t value;
;;;121    	
;;;122    	s_ucRA8875Busy = 1;
000004  2001              MOVS     r0,#1
000006  4906              LDR      r1,|L33.32|
000008  7008              STRB     r0,[r1,#0]
;;;123    	
;;;124    	RA8875_WriteCmd(_ucRegAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RA8875_WriteCmd
;;;125    	value = RA8875_ReadData();
000010  f7fffffe          BL       RA8875_ReadData
000014  4605              MOV      r5,r0
;;;126    	
;;;127    	s_ucRA8875Busy = 0;
000016  2000              MOVS     r0,#0
000018  4901              LDR      r1,|L33.32|
00001a  7008              STRB     r0,[r1,#0]
;;;128    	return value;	
00001c  4628              MOV      r0,r5
;;;129    }
00001e  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  |L33.32|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_ReadReg_Int||, CODE, READONLY, ALIGN=1

                  RA8875_ReadReg_Int PROC
;;;138    */
;;;139    uint8_t RA8875_ReadReg_Int(uint8_t _ucRegAddr)
000000  b510              PUSH     {r4,lr}
;;;140    {
000002  4604              MOV      r4,r0
;;;141    	RA8875_WriteCmd(_ucRegAddr);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       RA8875_WriteCmd
;;;142    	return RA8875_ReadData();
00000a  f7fffffe          BL       RA8875_ReadData
;;;143    }
00000e  bd10              POP      {r4,pc}
;;;144    
                          ENDP


                          AREA ||i.RA8875_SetBackColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackColor PROC
;;;617    */
;;;618    void RA8875_SetBackColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;619    {
000002  4604              MOV      r4,r0
;;;620    	RA8875_WriteReg(0x60, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ae1              LSRS     r1,r4,#11
000006  2060              MOVS     r0,#0x60
000008  f7fffffe          BL       RA8875_WriteReg
;;;621    	RA8875_WriteReg(0x61, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2061              MOVS     r0,#0x61
000012  f7fffffe          BL       RA8875_WriteReg
;;;622    	RA8875_WriteReg(0x62, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  2062              MOVS     r0,#0x62
00001c  f7fffffe          BL       RA8875_WriteReg
;;;623    }
000020  bd10              POP      {r4,pc}
;;;624    
                          ENDP


                          AREA ||i.RA8875_SetBackLight||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackLight PROC
;;;1958   */
;;;1959   void RA8875_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1960   {
000002  4604              MOV      r4,r0
;;;1961   	if (_bright == 0)
000004  b924              CBNZ     r4,|L36.16|
;;;1962   	{
;;;1963   		/* 关闭PWM, PWM1引脚缺省输出LOW  */
;;;1964   		RA8875_WriteReg(0x8A, 0 << 6);
000006  2100              MOVS     r1,#0
000008  208a              MOVS     r0,#0x8a
00000a  f7fffffe          BL       RA8875_WriteReg
00000e  e00e              B        |L36.46|
                  |L36.16|
;;;1965   	}
;;;1966   	else if (_bright == BRIGHT_MAX)	/* 最大亮度 */
000010  2cff              CMP      r4,#0xff
000012  d104              BNE      |L36.30|
;;;1967   	{
;;;1968   		/* 关闭PWM, PWM1引脚缺省输出HIGH */
;;;1969   		RA8875_WriteReg(0x8A, 1 << 6);
000014  2140              MOVS     r1,#0x40
000016  208a              MOVS     r0,#0x8a
000018  f7fffffe          BL       RA8875_WriteReg
00001c  e007              B        |L36.46|
                  |L36.30|
;;;1970   	}
;;;1971   	else
;;;1972   	{
;;;1973   		/* 使能PWM1, 进行占空比调节 */
;;;1974   
;;;1975   		/* 	REG[8Ah] PWM1 Control Register (P1CR)
;;;1976   
;;;1977   			Bit7 脉波宽度调变 (PWM1) 设定
;;;1978   				0 : 关闭，此状态下，PWM1 输出准位依照此缓存器Bit6 决定。
;;;1979   				1 : 开启。
;;;1980   
;;;1981   			Bit6 PWM1 关闭时的准位
;;;1982   				0 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”Low” 状态。
;;;1983   				1 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”High” 状态。
;;;1984   
;;;1985   			Bit5 保留
;;;1986   
;;;1987   			Bit4 PWM1 功能选择
;;;1988   				0 : PWM1 功能。
;;;1989   				1 : PWM1 固定输出一频率为外部晶体振荡器Clock (Fin) 频率 1 /16 的Clock
;;;1990   
;;;1991   			Bit3-0  PWM1 电路的频率来源选择PWM_CLK	【不是PWM输出频率】
;;;1992   				0000b : SYS_CLK / 1   , 1000b : SYS_CLK / 256
;;;1993   				0001b : SYS_CLK / 2   , 1001b : SYS_CLK / 512
;;;1994   				0010b : SYS_CLK / 4   , 1010b : SYS_CLK / 1024
;;;1995   				0011b : SYS_CLK / 8   , 1011b : SYS_CLK / 2048
;;;1996   				0100b : SYS_CLK / 16  , 1100b : SYS_CLK / 4096
;;;1997   				0101b : SYS_CLK / 32  , 1101b : SYS_CLK / 8192
;;;1998   				0110b : SYS_CLK / 64  , 1110b : SYS_CLK / 16384
;;;1999   				0111b : SYS_CLK / 128 , 1111b : SYS_CLK / 32768
;;;2000   
;;;2001   				“SYS_CLK” 代表系统频率， 例如SYS_CLK 为20MHz， 当Bit[3:0] =0001b 时，PWM1 频率来源为10MHz。
;;;2002   				实际输出的PWM频率还需要除以 256，支持8位的分辨率。
;;;2003   
;;;2004   				安富莱的4.3寸(480*272)模块，SYS_CLK =  68.75MHz
;;;2005   				安富莱的7.0寸(800*480)模块，SYS_CLK =  81.25MHz
;;;2006   
;;;2007   				为了避免音频噪声，PWM频率可以选择
;;;2008   				（1） 低频100Hz
;;;2009   				（2） 高于 20KHz
;;;2010   
;;;2011   				比如，Bit3-0为0011b时 SYS_CLK / 8，
;;;2012   					4.3寸 输出的PWM频率为 (68.75MHz / 8) / 256 = 33.56KHz
;;;2013   					7寸 输出的PWM频率为 (75 MHz / 8) / 256 = 36.62KHz
;;;2014   		*/
;;;2015   
;;;2016   		// 5寸和7寸新屏可以用 3 ，高频PWM, 4.3寸不行
;;;2017   		RA8875_WriteReg(0x8A, (1 << 7) | 3);   
00001e  2183              MOVS     r1,#0x83
000020  208a              MOVS     r0,#0x8a
000022  f7fffffe          BL       RA8875_WriteReg
;;;2018   		// RA8875_WriteReg(0x8A, (1 << 7) | 12);
;;;2019   
;;;2020   		/* REG[8Bh] PWM1 Duty Cycle Register (P1DCR) */
;;;2021   		RA8875_WriteReg(0x8B, _bright);
000026  4621              MOV      r1,r4
000028  208b              MOVS     r0,#0x8b
00002a  f7fffffe          BL       RA8875_WriteReg
                  |L36.46|
;;;2022   	}
;;;2023   }
00002e  bd10              POP      {r4,pc}
;;;2024   
                          ENDP


                          AREA ||i.RA8875_SetCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetCursor PROC
;;;1852   */
;;;1853   static void RA8875_SetCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1854   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1855   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  4813              LDR      r0,|L37.84|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd10              BLE      |L37.48|
;;;1856   	{
;;;1857   		RA8875_WriteReg(0x46, _usY);
00000e  b2e9              UXTB     r1,r5
000010  2046              MOVS     r0,#0x46
000012  f7fffffe          BL       RA8875_WriteReg
;;;1858   		RA8875_WriteReg(0x47, _usY >> 8);
000016  1229              ASRS     r1,r5,#8
000018  2047              MOVS     r0,#0x47
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1859   		RA8875_WriteReg(0x48, _usX);
00001e  b2e1              UXTB     r1,r4
000020  2048              MOVS     r0,#0x48
000022  f7fffffe          BL       RA8875_WriteReg
;;;1860   		RA8875_WriteReg(0x49, _usX >> 8);
000026  1221              ASRS     r1,r4,#8
000028  2049              MOVS     r0,#0x49
00002a  f7fffffe          BL       RA8875_WriteReg
00002e  e00f              B        |L37.80|
                  |L37.48|
;;;1861   	}
;;;1862   	else	/* 横屏 */
;;;1863   	{
;;;1864   		RA8875_WriteReg(0x46, _usX);
000030  b2e1              UXTB     r1,r4
000032  2046              MOVS     r0,#0x46
000034  f7fffffe          BL       RA8875_WriteReg
;;;1865   		RA8875_WriteReg(0x47, _usX >> 8);
000038  1221              ASRS     r1,r4,#8
00003a  2047              MOVS     r0,#0x47
00003c  f7fffffe          BL       RA8875_WriteReg
;;;1866   		RA8875_WriteReg(0x48, _usY);
000040  b2e9              UXTB     r1,r5
000042  2048              MOVS     r0,#0x48
000044  f7fffffe          BL       RA8875_WriteReg
;;;1867   		RA8875_WriteReg(0x49, _usY >> 8);
000048  1229              ASRS     r1,r5,#8
00004a  2049              MOVS     r0,#0x49
00004c  f7fffffe          BL       RA8875_WriteReg
                  |L37.80|
;;;1868   	}
;;;1869   }
000050  bd70              POP      {r4-r6,pc}
;;;1870   
                          ENDP

000052  0000              DCW      0x0000
                  |L37.84|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetDirection||, CODE, READONLY, ALIGN=2

                  RA8875_SetDirection PROC
;;;474    */
;;;475    void RA8875_SetDirection(uint8_t _ucDir)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
000002  4604              MOV      r4,r0
;;;477    	uint8_t reg20H = 0;
000004  2500              MOVS     r5,#0
;;;478    	
;;;479    	s_reg_40H = 0x01;
000006  2001              MOVS     r0,#1
000008  4921              LDR      r1,|L38.144|
00000a  7008              STRB     r0,[r1,#0]
;;;480    	
;;;481    	if (_ucDir == 0)
00000c  b90c              CBNZ     r4,|L38.18|
;;;482    	{
;;;483    		s_reg_40H = 0x01;
00000e  7008              STRB     r0,[r1,#0]
;;;484    		reg20H = (0 << 3) | (0 << 2);
000010  e013              B        |L38.58|
                  |L38.18|
;;;485    	}
;;;486    	else if (_ucDir == 1)
000012  2c01              CMP      r4,#1
000014  d104              BNE      |L38.32|
;;;487    	{
;;;488    		s_reg_40H = 0x01;	/* 2015-04-21 由05修改为 01. 解决emwin下的问题 */
000016  2001              MOVS     r0,#1
000018  491d              LDR      r1,|L38.144|
00001a  7008              STRB     r0,[r1,#0]
;;;489    		reg20H = (1 << 3) | (1 << 2);
00001c  250c              MOVS     r5,#0xc
00001e  e00c              B        |L38.58|
                  |L38.32|
;;;490    	}
;;;491    	else if (_ucDir == 2)
000020  2c02              CMP      r4,#2
000022  d104              BNE      |L38.46|
;;;492    	{
;;;493    		s_reg_40H = 0x09;
000024  2009              MOVS     r0,#9
000026  491a              LDR      r1,|L38.144|
000028  7008              STRB     r0,[r1,#0]
;;;494    		reg20H = (0 << 3) | (1 << 2);
00002a  2504              MOVS     r5,#4
00002c  e005              B        |L38.58|
                  |L38.46|
;;;495    	}
;;;496    	else if (_ucDir == 3)
00002e  2c03              CMP      r4,#3
000030  d103              BNE      |L38.58|
;;;497    	{
;;;498    		s_reg_40H = 0x09;
000032  2009              MOVS     r0,#9
000034  4916              LDR      r1,|L38.144|
000036  7008              STRB     r0,[r1,#0]
;;;499    		reg20H = (1 << 3) | (0 << 2);
000038  2508              MOVS     r5,#8
                  |L38.58|
;;;500    	}
;;;501    	RA8875_WriteReg(0x40, s_reg_40H);	
00003a  4815              LDR      r0,|L38.144|
00003c  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
00003e  2040              MOVS     r0,#0x40
000040  f7fffffe          BL       RA8875_WriteReg
;;;502    
;;;503    	/* 
;;;504    		REG[20h] Display Configuration Register (DPCR) 
;;;505    		Bit  说  明  初始值  Access
;;;506    		Bit7 
;;;507    			图层设定(Layer Control) 
;;;508    			0 : 单图层。
;;;509    			1 : 双图层。
;;;510    		Bit3  HDIR 水平扫描方向设定(n = SEG number) 
;;;511    			0 : 由SEG0 到SEG(n-1)。
;;;512    			1 : 由SEG(n-1) 到SEG0。
;;;513    		Bit2 VDIR 垂直扫描方向设定(n = COM number) 
;;;514    			0 : 由COM0 到COM(n-1)。
;;;515    			1 : 由COM(n-1) 到COM0。
;;;516    	*/
;;;517    	RA8875_WriteReg(0x20, reg20H);	
000044  4629              MOV      r1,r5
000046  2020              MOVS     r0,#0x20
000048  f7fffffe          BL       RA8875_WriteReg
;;;518    
;;;519    	if (_ucDir > 1)	/* 竖屏  */
00004c  2c01              CMP      r4,#1
00004e  dd0e              BLE      |L38.110|
;;;520    	{
;;;521    		uint16_t temp;
;;;522    		
;;;523    		if (g_LcdHeight < g_LcdWidth)
000050  4910              LDR      r1,|L38.148|
000052  8809              LDRH     r1,[r1,#0]  ; g_LcdHeight
000054  4a10              LDR      r2,|L38.152|
000056  8812              LDRH     r2,[r2,#0]  ; g_LcdWidth
000058  4291              CMP      r1,r2
00005a  da07              BGE      |L38.108|
;;;524    		{
;;;525    			temp = g_LcdHeight;
00005c  490d              LDR      r1,|L38.148|
00005e  8808              LDRH     r0,[r1,#0]  ; g_LcdHeight
;;;526    			g_LcdHeight = g_LcdWidth;
000060  490d              LDR      r1,|L38.152|
000062  8809              LDRH     r1,[r1,#0]  ; g_LcdWidth
000064  4a0b              LDR      r2,|L38.148|
000066  8011              STRH     r1,[r2,#0]
;;;527    			g_LcdWidth = temp;
000068  490b              LDR      r1,|L38.152|
00006a  8008              STRH     r0,[r1,#0]
                  |L38.108|
;;;528    		}
;;;529    	}		
00006c  e00e              B        |L38.140|
                  |L38.110|
;;;530    	else	/* 横屏 */
;;;531    	{
;;;532    		uint16_t temp;
;;;533    		
;;;534    		if (g_LcdHeight > g_LcdWidth)
00006e  4909              LDR      r1,|L38.148|
000070  8809              LDRH     r1,[r1,#0]  ; g_LcdHeight
000072  4a09              LDR      r2,|L38.152|
000074  8812              LDRH     r2,[r2,#0]  ; g_LcdWidth
000076  4291              CMP      r1,r2
000078  dd07              BLE      |L38.138|
;;;535    		{
;;;536    			temp = g_LcdHeight;
00007a  4906              LDR      r1,|L38.148|
00007c  8808              LDRH     r0,[r1,#0]  ; g_LcdHeight
;;;537    			g_LcdHeight = g_LcdWidth;
00007e  4906              LDR      r1,|L38.152|
000080  8809              LDRH     r1,[r1,#0]  ; g_LcdWidth
000082  4a04              LDR      r2,|L38.148|
000084  8011              STRH     r1,[r2,#0]
;;;538    			g_LcdWidth = temp;
000086  4904              LDR      r1,|L38.152|
000088  8008              STRH     r0,[r1,#0]
                  |L38.138|
;;;539    		}
;;;540    	}
00008a  bf00              NOP      
                  |L38.140|
;;;541    }
00008c  bd70              POP      {r4-r6,pc}
;;;542    
                          ENDP

00008e  0000              DCW      0x0000
                  |L38.144|
                          DCD      s_reg_40H
                  |L38.148|
                          DCD      g_LcdHeight
                  |L38.152|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_SetDispWin||, CODE, READONLY, ALIGN=2

                  RA8875_SetDispWin PROC
;;;1799   */
;;;1800   void RA8875_SetDispWin(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1801   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1802   
;;;1803   	uint16_t usTemp;
;;;1804   
;;;1805   	/* 坐标系统示意图: （横屏）
;;;1806   			 -----------------------------
;;;1807   			|(0,0)                        |
;;;1808   			|     --------->              |
;;;1809   			|         |                   |
;;;1810   			|         |                   |
;;;1811   			|         |                   |
;;;1812   			|         V                   |
;;;1813   			|     --------->              |
;;;1814   			|                    (479,271)|
;;;1815   			 -----------------------------
;;;1816   
;;;1817   		左上角是坐标零点, 扫描方向，先从左到右，再从上到下。
;;;1818   
;;;1819   		如果需要做竖屏方式，你需要进行物理坐标和逻辑坐标的转换
;;;1820   	*/
;;;1821   	RA8875_WriteReg(0x30, _usX);
00000c  b2e1              UXTB     r1,r4
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       RA8875_WriteReg
;;;1822       RA8875_WriteReg(0x31, _usX >> 8);
000014  1221              ASRS     r1,r4,#8
000016  2031              MOVS     r0,#0x31
000018  f7fffffe          BL       RA8875_WriteReg
;;;1823   
;;;1824   	RA8875_WriteReg(0x32, _usY);
00001c  b2e9              UXTB     r1,r5
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       RA8875_WriteReg
;;;1825       RA8875_WriteReg(0x33, _usY >> 8);
000024  1229              ASRS     r1,r5,#8
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       RA8875_WriteReg
;;;1826   
;;;1827   	usTemp = _usWidth + _usX - 1;
00002c  eb080004          ADD      r0,r8,r4
000030  1e40              SUBS     r0,r0,#1
000032  b286              UXTH     r6,r0
;;;1828   	RA8875_WriteReg(0x34, usTemp);
000034  b2f1              UXTB     r1,r6
000036  2034              MOVS     r0,#0x34
000038  f7fffffe          BL       RA8875_WriteReg
;;;1829       RA8875_WriteReg(0x35, usTemp >> 8);
00003c  1231              ASRS     r1,r6,#8
00003e  2035              MOVS     r0,#0x35
000040  f7fffffe          BL       RA8875_WriteReg
;;;1830   
;;;1831   	usTemp = _usHeight + _usY - 1;
000044  1978              ADDS     r0,r7,r5
000046  1e40              SUBS     r0,r0,#1
000048  b286              UXTH     r6,r0
;;;1832   	RA8875_WriteReg(0x36, usTemp);
00004a  b2f1              UXTB     r1,r6
00004c  2036              MOVS     r0,#0x36
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1833       RA8875_WriteReg(0x37, usTemp >> 8);
000052  1231              ASRS     r1,r6,#8
000054  2037              MOVS     r0,#0x37
000056  f7fffffe          BL       RA8875_WriteReg
;;;1834   
;;;1835   	RA8875_SetCursor(_usX, _usY);
00005a  4629              MOV      r1,r5
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       RA8875_SetCursor
;;;1836   
;;;1837   	/* 保存当前窗口信息，提高以后单色填充操作的效率.
;;;1838   	另外一种做法是通过读取0x30-0x37寄存器获得当前窗口，不过效率较低 */
;;;1839   	s_WinX = _usX;
000062  4805              LDR      r0,|L39.120|
000064  8004              STRH     r4,[r0,#0]
;;;1840   	s_WinY = _usY;
000066  4805              LDR      r0,|L39.124|
000068  8005              STRH     r5,[r0,#0]
;;;1841   	s_WinHeight = _usHeight;
00006a  4805              LDR      r0,|L39.128|
00006c  8007              STRH     r7,[r0,#0]
;;;1842   	s_WinWidth = _usWidth;
00006e  4805              LDR      r0,|L39.132|
000070  f8a08000          STRH     r8,[r0,#0]
;;;1843   }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;1844   
                          ENDP

                  |L39.120|
                          DCD      s_WinX
                  |L39.124|
                          DCD      s_WinY
                  |L39.128|
                          DCD      s_WinHeight
                  |L39.132|
                          DCD      s_WinWidth

                          AREA ||i.RA8875_SetFont||, CODE, READONLY, ALIGN=1

                  RA8875_SetFont PROC
;;;1566   */
;;;1567   void RA8875_SetFont(uint8_t _ucFontType, uint8_t _ucLineSpace, uint8_t _ucCharSpace)
000000  b570              PUSH     {r4-r6,lr}
;;;1568   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1569   	/*
;;;1570   		[29H]在文字模式下，用来设定文字间的行距 (单位: 像素) 。
;;;1571   		只有低5个bit有效，0-31
;;;1572   	*/
;;;1573   	if (_ucLineSpace >31)
000008  2e1f              CMP      r6,#0x1f
00000a  dd00              BLE      |L40.14|
;;;1574   	{
;;;1575   		_ucLineSpace = 31;
00000c  261f              MOVS     r6,#0x1f
                  |L40.14|
;;;1576   	}
;;;1577   	RA8875_WriteReg(0x29, _ucLineSpace);
00000e  4631              MOV      r1,r6
000010  2029              MOVS     r0,#0x29
000012  f7fffffe          BL       RA8875_WriteReg
;;;1578   
;;;1579   	/*
;;;1580   		[2EH] 设置字符间距（像素单位，0-63），和字体（16*16，24*24，32*32）
;;;1581   	*/
;;;1582   	if (_ucCharSpace > 63)
000016  2d3f              CMP      r5,#0x3f
000018  dd00              BLE      |L40.28|
;;;1583   	{
;;;1584   		_ucCharSpace = 63;
00001a  253f              MOVS     r5,#0x3f
                  |L40.28|
;;;1585   	}
;;;1586   	if (_ucFontType > RA_FONT_32)
00001c  2c02              CMP      r4,#2
00001e  dd00              BLE      |L40.34|
;;;1587   	{
;;;1588   		_ucFontType = RA_FONT_16;
000020  2400              MOVS     r4,#0
                  |L40.34|
;;;1589   	}
;;;1590   	RA8875_WriteReg(0x2E, (_ucCharSpace & 0x3F) | (_ucFontType << 6));
000022  4628              MOV      r0,r5
000024  f364109f          BFI      r0,r4,#6,#26
000028  b2c1              UXTB     r1,r0
00002a  202e              MOVS     r0,#0x2e
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1591   }
000030  bd70              POP      {r4-r6,pc}
;;;1592   
                          ENDP


                          AREA ||i.RA8875_SetFrontColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetFrontColor PROC
;;;602    */
;;;603    void RA8875_SetFrontColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;604    {
000002  4604              MOV      r4,r0
;;;605    	RA8875_WriteReg(0x63, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ae1              LSRS     r1,r4,#11
000006  2063              MOVS     r0,#0x63
000008  f7fffffe          BL       RA8875_WriteReg
;;;606    	RA8875_WriteReg(0x64, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2064              MOVS     r0,#0x64
000012  f7fffffe          BL       RA8875_WriteReg
;;;607    	RA8875_WriteReg(0x65, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  2065              MOVS     r0,#0x65
00001c  f7fffffe          BL       RA8875_WriteReg
;;;608    }
000020  bd10              POP      {r4,pc}
;;;609    
                          ENDP


                          AREA ||i.RA8875_SetReadCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetReadCursor PROC
;;;1878   */
;;;1879   static void RA8875_SetReadCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1880   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1881   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480c              LDR      r0,|L42.56|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd03              BLE      |L42.22|
;;;1882   	{
;;;1883   		uint16_t temp;
;;;1884   		
;;;1885   		temp = _usX;
00000e  4620              MOV      r0,r4
;;;1886   		_usX = _usY;
000010  462c              MOV      r4,r5
;;;1887   		_usY = temp;
000012  4605              MOV      r5,r0
;;;1888   	}
000014  bf00              NOP      
                  |L42.22|
;;;1889   		
;;;1890   	/* 设置内存读光标的坐标 */
;;;1891   	RA8875_WriteReg(0x4A, _usX);
000016  b2e1              UXTB     r1,r4
000018  204a              MOVS     r0,#0x4a
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1892   	RA8875_WriteReg(0x4B, _usX >> 8);
00001e  1221              ASRS     r1,r4,#8
000020  204b              MOVS     r0,#0x4b
000022  f7fffffe          BL       RA8875_WriteReg
;;;1893   	RA8875_WriteReg(0x4C, _usY);
000026  b2e9              UXTB     r1,r5
000028  204c              MOVS     r0,#0x4c
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1894   	RA8875_WriteReg(0x4D, _usY >> 8);
00002e  1229              ASRS     r1,r5,#8
000030  204d              MOVS     r0,#0x4d
000032  f7fffffe          BL       RA8875_WriteReg
;;;1895   }
000036  bd70              POP      {r4-r6,pc}
;;;1896   
                          ENDP

                  |L42.56|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetTextCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextCursor PROC
;;;1904   */
;;;1905   static void RA8875_SetTextCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1906   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1907   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480c              LDR      r0,|L43.56|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd03              BLE      |L43.22|
;;;1908   	{
;;;1909   		uint16_t temp;
;;;1910   		
;;;1911   		temp = _usX;
00000e  4620              MOV      r0,r4
;;;1912   		_usX = _usY;
000010  462c              MOV      r4,r5
;;;1913   		_usY = temp;
000012  4605              MOV      r5,r0
;;;1914   	}
000014  bf00              NOP      
                  |L43.22|
;;;1915   			
;;;1916   	/* 设置内存读光标的坐标 */
;;;1917   	RA8875_WriteReg(0x2A, _usX);
000016  b2e1              UXTB     r1,r4
000018  202a              MOVS     r0,#0x2a
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1918   	RA8875_WriteReg(0x2B, _usX >> 8);
00001e  1221              ASRS     r1,r4,#8
000020  202b              MOVS     r0,#0x2b
000022  f7fffffe          BL       RA8875_WriteReg
;;;1919   	RA8875_WriteReg(0x2C, _usY);
000026  b2e9              UXTB     r1,r5
000028  202c              MOVS     r0,#0x2c
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1920   	RA8875_WriteReg(0x2D, _usY >> 8);
00002e  1229              ASRS     r1,r5,#8
000030  202d              MOVS     r0,#0x2d
000032  f7fffffe          BL       RA8875_WriteReg
;;;1921   }
000036  bd70              POP      {r4-r6,pc}
;;;1922   
                          ENDP

                  |L43.56|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetTextZoom||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextZoom PROC
;;;1603   */
;;;1604   void RA8875_SetTextZoom(uint8_t _ucHSize, uint8_t _ucVSize)
000000  b570              PUSH     {r4-r6,lr}
;;;1605   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1606   	/*
;;;1607   		pdf 第22页		[22H]
;;;1608   		bit7 用于对齐，一般不用，缺省设0
;;;1609   		bit6 用于通透，一般不用，缺省设0
;;;1610   		bit4 用于旋转90读，一般不用，缺省设0
;;;1611   		bit3-2 水平放大倍数
;;;1612   		bit1-0 垂直放大倍数
;;;1613   	*/
;;;1614   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480f              LDR      r0,|L44.68|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd0c              BLE      |L44.40|
;;;1615   	{
;;;1616   		RA8875_WriteReg(0x22, (1 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
00000e  f0040003          AND      r0,r4,#3
000012  2210              MOVS     r2,#0x10
000014  ea420080          ORR      r0,r2,r0,LSL #2
000018  f0050203          AND      r2,r5,#3
00001c  ea400102          ORR      r1,r0,r2
000020  2022              MOVS     r0,#0x22
000022  f7fffffe          BL       RA8875_WriteReg
000026  e00b              B        |L44.64|
                  |L44.40|
;;;1617   	}
;;;1618   	else	/* 横屏 */
;;;1619   	{
;;;1620   		RA8875_WriteReg(0x22, (0 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
000028  f0040003          AND      r0,r4,#3
00002c  2200              MOVS     r2,#0
00002e  ea420080          ORR      r0,r2,r0,LSL #2
000032  f0050203          AND      r2,r5,#3
000036  ea400102          ORR      r1,r0,r2
00003a  2022              MOVS     r0,#0x22
00003c  f7fffffe          BL       RA8875_WriteReg
                  |L44.64|
;;;1621   	}
;;;1622   }
000040  bd70              POP      {r4-r6,pc}
;;;1623   
                          ENDP

000042  0000              DCW      0x0000
                  |L44.68|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_Sleep||, CODE, READONLY, ALIGN=1

                  RA8875_Sleep PROC
;;;916    */
;;;917    void RA8875_Sleep(void)
000000  b510              PUSH     {r4,lr}
;;;918    {
;;;919    	RA8875_SetBackLight(0);		/* 关闭背光 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RA8875_SetBackLight
;;;920    
;;;921    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;922    	RA8875_WriteReg(0xC7, 0x00);	/* DISP = 0  */
000008  2100              MOVS     r1,#0
00000a  20c7              MOVS     r0,#0xc7
00000c  f7fffffe          BL       RA8875_WriteReg
;;;923    
;;;924    	RA8875_WriteReg(0x01, 0x01);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RA8875_WriteReg
;;;925    	RA8875_WriteReg(0x01, 0x00);
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RA8875_WriteReg
;;;926    
;;;927    	RA8875_WriteReg(0x01, 0x02);	/* RA8875 Sleep */
000020  2102              MOVS     r1,#2
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       RA8875_WriteReg
;;;928    }
000028  bd10              POP      {r4,pc}
;;;929    
                          ENDP


                          AREA ||i.RA8875_StartDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_StartDirectDraw PROC
;;;1218   */
;;;1219   void RA8875_StartDirectDraw(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1220   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1221   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1222   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RA8875_SetDispWin
;;;1223   
;;;1224   	s_ucRA8875Busy = 1;
000018  2001              MOVS     r0,#1
00001a  4903              LDR      r1,|L46.40|
00001c  7008              STRB     r0,[r1,#0]
;;;1225   
;;;1226   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RA8875_WriteCmd
;;;1227   
;;;1228   	/* 之后，应用程序可以直接绘图 */
;;;1229   }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;1230   
                          ENDP

                  |L46.40|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_TouchInit||, CODE, READONLY, ALIGN=1

                  RA8875_TouchInit PROC
;;;750    */
;;;751    void RA8875_TouchInit(void)
000000  b510              PUSH     {r4,lr}
;;;752    {
;;;753    	RA8875_WriteReg(0xF0, (1 << 2));	/* 开启触控面板中断位 */
000002  2104              MOVS     r1,#4
000004  20f0              MOVS     r0,#0xf0
000006  f7fffffe          BL       RA8875_WriteReg
;;;754    
;;;755    	/*
;;;756    		REG[71h] Touch Panel Control Register 1 (TPCR1)
;;;757    
;;;758    		Bit7 N/A
;;;759    		Bit6 触控面板模式设定
;;;760    			0 : 自动模式。
;;;761    			1 : 手动模式。
;;;762    		Bit5 触控面板控制器ADC 参考电压(Vref)来源设定
;;;763    			0 : 内部产生参考电压。
;;;764    			1 : 外部输入参考电压，ADC 参考电压准位= 1/2 VDD。
;;;765    		Bit4-3 N/A
;;;766    		Bit2 触控中断讯号的消除弹跳电路选择
;;;767    			0: 关闭消除弹跳电路。
;;;768    			1: 开启消除弹跳电路。
;;;769    		Bit1-0 触控面板手动模式之选择位
;;;770    			00b : 闲置模式。触控控制单元进入闲置模式。
;;;771    			01b : 侦测触摸事件发生。在此模式控制器会侦测触摸事件的发
;;;772    				生，事件发生可以引发中断或是由缓存器得知(REG[F1h]
;;;773    				Bit2)。
;;;774    			10b : X 轴数据撷取模式。在此模式触摸位置的X 轴数据会被储
;;;775    				存至 REG[72h] 和REG[74h]。
;;;776    			11b : Y 轴数据撷取模式。在此模式触摸位置的Y 轴数据会被储
;;;777    				存至REG[73h] and REG[74h]。
;;;778    	*/
;;;779    	RA8875_WriteReg(0x71, (0 << 6) | (0 << 5) | (1 << 2));	/* 选择自动模式 */
00000a  2104              MOVS     r1,#4
00000c  2071              MOVS     r0,#0x71
00000e  f7fffffe          BL       RA8875_WriteReg
;;;780    
;;;781    	/*
;;;782    		REG[70h] Touch Panel Control Register 0 (TPCR0)
;;;783    
;;;784    		Bit7 触控面板功能设定
;;;785    			0 : 关闭。
;;;786    			1 : 开启。
;;;787    		Bit6-4 触控面板控制器取样时间设定
;;;788    			000b : ADC 取样时间为512 个系统频率周期。
;;;789    			001b : ADC 取样时间为 1024 个系统频率周期。
;;;790    			010b : ADC 取样时间为 2048 个系统频率周期。
;;;791    			011b : ADC 取样时间为 4096 个系统频率周期。
;;;792    			100b : ADC 取样时间为 8192 个系统频率周期。
;;;793    			101b : ADC 取样时间为 16384 个系统频率周期。
;;;794    			110b : ADC 取样时间为 32768 个系统频率周期。
;;;795    			111b : ADC 取样时间为65536 个系统频率周期。
;;;796    		Bit3 触控面板唤醒模式
;;;797    			0 : 关闭触控事件唤醒模式。
;;;798    			1 : 触控事件可唤醒睡眠模式。
;;;799    		Bit2-0 触控面板控制器ADC 频率设定
;;;800    			000b : 系统频率。
;;;801    			001b : 系统频率 / 2。
;;;802    			010b : 系统频率 / 4。
;;;803    			011b : 系统频率 / 8。
;;;804    			100b : 系统频率 / 16。
;;;805    			101b : 系统频率 / 32。
;;;806    			110b : 系统频率 / 64。
;;;807    			111b : 系统频率 / 128。
;;;808    
;;;809    		注 : ADC 的输入频率设定不能超过10MHz。
;;;810    	*/
;;;811    	RA8875_WriteReg(0x70, (1 << 7) | (3 << 4) | (0 << 3) | (2 << 0));	/* 开启触摸功能； */
000012  21b2              MOVS     r1,#0xb2
000014  2070              MOVS     r0,#0x70
000016  f7fffffe          BL       RA8875_WriteReg
;;;812    }
00001a  bd10              POP      {r4,pc}
;;;813    
                          ENDP


                          AREA ||i.RA8875_TouchReadX||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadX PROC
;;;821    */
;;;822    uint16_t RA8875_TouchReadX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
;;;824    	uint16_t usAdc;
;;;825    	uint8_t ucRegValue;
;;;826    	uint8_t ucReg74;
;;;827    
;;;828    	/* 软件读取中断事件标志 */
;;;829    	ucRegValue = RA8875_ReadReg_Int(0xF1);
000002  20f1              MOVS     r0,#0xf1
000004  f7fffffe          BL       RA8875_ReadReg_Int
000008  4606              MOV      r6,r0
;;;830    	if (ucRegValue & (1 << 2))
00000a  f0060004          AND      r0,r6,#4
00000e  b1f0              CBZ      r0,|L48.78|
;;;831    	{
;;;832    		ucReg74 = RA8875_ReadReg_Int(0x74);
000010  2074              MOVS     r0,#0x74
000012  f7fffffe          BL       RA8875_ReadReg_Int
000016  4605              MOV      r5,r0
;;;833    		usAdc = RA8875_ReadReg_Int(0x72);	/* Bit9-2 */
000018  2072              MOVS     r0,#0x72
00001a  f7fffffe          BL       RA8875_ReadReg_Int
00001e  4604              MOV      r4,r0
;;;834    		usAdc <<= 2;
000020  f64f70ff          MOV      r0,#0xffff
000024  ea000484          AND      r4,r0,r4,LSL #2
;;;835    		usAdc += (ucReg74 & 0x03);
000028  f0050003          AND      r0,r5,#3
00002c  4404              ADD      r4,r4,r0
;;;836    
;;;837    		s_usTouchX = usAdc;
00002e  480f              LDR      r0,|L48.108|
000030  8004              STRH     r4,[r0,#0]
;;;838    
;;;839    		usAdc = RA8875_ReadReg_Int(0x73);	/* Bit9-2 */
000032  2073              MOVS     r0,#0x73
000034  f7fffffe          BL       RA8875_ReadReg_Int
000038  4604              MOV      r4,r0
;;;840    		usAdc <<= 2;
00003a  f64f70ff          MOV      r0,#0xffff
00003e  ea000484          AND      r4,r0,r4,LSL #2
;;;841    		usAdc += ((ucReg74 & 0x0C) >> 2);
000042  f3c50081          UBFX     r0,r5,#2,#2
000046  4404              ADD      r4,r4,r0
;;;842    
;;;843    		s_usTouchY = usAdc;
000048  4809              LDR      r0,|L48.112|
00004a  8004              STRH     r4,[r0,#0]
00004c  e004              B        |L48.88|
                  |L48.78|
;;;844    	}
;;;845    	else
;;;846    	{
;;;847    		s_usTouchX = 0;
00004e  2000              MOVS     r0,#0
000050  4906              LDR      r1,|L48.108|
000052  8008              STRH     r0,[r1,#0]
;;;848    		s_usTouchY = 0;
000054  4906              LDR      r1,|L48.112|
000056  8008              STRH     r0,[r1,#0]
                  |L48.88|
;;;849    	}
;;;850    
;;;851    	/*
;;;852    		bit2 写入功能?? 触控面板中断清除位
;;;853    		0 : 未操作。
;;;854    		1 : 清除触控面板中断。
;;;855    		读取功能?? 触控面板中断状态
;;;856    		0 : 未发生触控面板中断。
;;;857    		1 : 发生触控面板中断。
;;;858    	*/
;;;859    
;;;860    	/*
;;;861    		不要调用这个函数写寄存器，因为该函数改写了busy标志
;;;862    		RA8875_WriteReg(0xF1, (1 << 2));	 必须清除， 才会下次采样.
;;;863    	*/
;;;864    	RA8875_WriteCmd(0xF1);
000058  20f1              MOVS     r0,#0xf1
00005a  f7fffffe          BL       RA8875_WriteCmd
;;;865    	RA8875_WriteData(1 << 2);
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RA8875_WriteData
;;;866    
;;;867    	return s_usTouchX;
000064  4801              LDR      r0,|L48.108|
000066  8800              LDRH     r0,[r0,#0]  ; s_usTouchX
;;;868    }
000068  bd70              POP      {r4-r6,pc}
;;;869    
                          ENDP

00006a  0000              DCW      0x0000
                  |L48.108|
                          DCD      s_usTouchX
                  |L48.112|
                          DCD      s_usTouchY

                          AREA ||i.RA8875_TouchReadY||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadY PROC
;;;877    */
;;;878    uint16_t RA8875_TouchReadY(void)
000000  4801              LDR      r0,|L49.8|
;;;879    {
;;;880    	return s_usTouchY;
000002  8800              LDRH     r0,[r0,#0]  ; s_usTouchY
;;;881    }
000004  4770              BX       lr
;;;882    
                          ENDP

000006  0000              DCW      0x0000
                  |L49.8|
                          DCD      s_usTouchY

                          AREA ||i.RA8875_WaitBusy||, CODE, READONLY, ALIGN=1

                  RA8875_WaitBusy PROC
;;;689    */
;;;690    void RA8875_WaitBusy(void)
000000  b510              PUSH     {r4,lr}
;;;691    {
;;;692    	while ((RA8875_ReadStatus() & 0x80) == 0x80);
000002  bf00              NOP      
                  |L50.4|
000004  f7fffffe          BL       RA8875_ReadStatus
000008  f0000080          AND      r0,r0,#0x80
00000c  2880              CMP      r0,#0x80
00000e  d0f9              BEQ      |L50.4|
;;;693    }
000010  bd10              POP      {r4,pc}
;;;694    
                          ENDP


                          AREA ||i.RA8875_WriteReg||, CODE, READONLY, ALIGN=2

                  RA8875_WriteReg PROC
;;;99     */
;;;100    void RA8875_WriteReg(uint8_t _ucRegAddr, uint8_t _ucRegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;102    	s_ucRA8875Busy = 1;				/* 设置忙标志，避免触摸中断中的程序访问冲突 */
000006  2001              MOVS     r0,#1
000008  4905              LDR      r1,|L51.32|
00000a  7008              STRB     r0,[r1,#0]
;;;103    
;;;104    	RA8875_WriteCmd(_ucRegAddr);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       RA8875_WriteCmd
;;;105    	RA8875_WriteData(_ucRegValue);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RA8875_WriteData
;;;106    
;;;107    	s_ucRA8875Busy = 0;
000018  2000              MOVS     r0,#0
00001a  4901              LDR      r1,|L51.32|
00001c  7008              STRB     r0,[r1,#0]
;;;108    }
00001e  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP

                  |L51.32|
                          DCD      s_ucRA8875Busy

                          AREA ||.data||, DATA, ALIGN=1

                  s_usTouchX
000000  0000              DCB      0x00,0x00
                  s_usTouchY
000002  0000              DCB      0x00,0x00
                  s_ucRA8875Busy
000004  00                DCB      0x00
                  s_reg_40H
000005  00                DCB      0x00
                  s_reg_22H
000006  0000              DCB      0x00,0x00
                  s_WinX
000008  0000              DCW      0x0000
                  s_WinY
00000a  0000              DCW      0x0000
                  s_WinHeight
00000c  0110              DCW      0x0110
                  s_WinWidth
00000e  01e0              DCW      0x01e0

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\LCD_RA8875.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_LCD_RA8875_c_fad3ed70____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REVSH|
#line 144
|__asm___12_LCD_RA8875_c_fad3ed70____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____RRX|
#line 300
|__asm___12_LCD_RA8875_c_fad3ed70____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
