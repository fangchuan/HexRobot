; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_mem.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_mem.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\os_mem.crf ..\..\uCOS-III\uCOS-III\Source\os_mem.c]
                          THUMB

                          AREA ||i.OSMemCreate||, CODE, READONLY, ALIGN=2

                  OSMemCreate PROC
;;;74     
;;;75     void  OSMemCreate (OS_MEM       *p_mem,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76                        CPU_CHAR     *p_name,
;;;77                        void         *p_addr,
;;;78                        OS_MEM_QTY    n_blks,
;;;79                        OS_MEM_SIZE   blk_size,
;;;80                        OS_ERR       *p_err)
;;;81     {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9610          LDRD     r9,r6,[sp,#0x40]
;;;82     #if OS_CFG_ARG_CHK_EN > 0u
;;;83         CPU_DATA       align_msk;
;;;84     #endif
;;;85         OS_MEM_QTY     i;
;;;86         OS_MEM_QTY     loops;
;;;87         CPU_INT08U    *p_blk;
;;;88         void         **p_link;
;;;89         CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;90     
;;;91     
;;;92     
;;;93     #ifdef OS_SAFETY_CRITICAL
;;;94         if (p_err == (OS_ERR *)0) {
;;;95             OS_SAFETY_CRITICAL_EXCEPTION();
;;;96             return;
;;;97         }
;;;98     #endif
;;;99     
;;;100    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;101        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;102           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;103            return;
;;;104        }
;;;105    #endif
;;;106    
;;;107    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;108        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000014  4834              LDR      r0,|L1.232|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000018  2800              CMP      r0,#0
00001a  dd05              BLE      |L1.40|
;;;109           *p_err = OS_ERR_MEM_CREATE_ISR;
00001c  f24560b9          MOV      r0,#0x56b9
000020  8030              STRH     r0,[r6,#0]
                  |L1.34|
;;;110            return;
;;;111        }
;;;112    #endif
;;;113    
;;;114    #if OS_CFG_ARG_CHK_EN > 0u
;;;115        if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
;;;116           *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
;;;117            return;
;;;118        }
;;;119        if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
;;;120           *p_err = OS_ERR_MEM_INVALID_BLKS;
;;;121            return;
;;;122        }
;;;123        if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
;;;124           *p_err = OS_ERR_MEM_INVALID_SIZE;
;;;125            return;
;;;126        }
;;;127        align_msk = sizeof(void *) - 1u;
;;;128        if (align_msk > 0u) {
;;;129            if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
;;;130               *p_err = OS_ERR_MEM_INVALID_P_ADDR;
;;;131                return;
;;;132            }
;;;133            if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
;;;134               *p_err = OS_ERR_MEM_INVALID_SIZE;
;;;135                return;
;;;136            }
;;;137        }
;;;138    #endif
;;;139    
;;;140        p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
;;;141        p_blk  = (CPU_INT08U *)p_addr;
;;;142        loops  = n_blks - 1u;
;;;143        for (i = 0u; i < loops; i++) {
;;;144            p_blk +=  blk_size;
;;;145           *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
;;;146            p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
;;;147        }
;;;148       *p_link             = (void *)0;                         /* Last memory block points to NULL                       */
;;;149    
;;;150        OS_CRITICAL_ENTER();
;;;151        p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
;;;152        p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
;;;153        p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
;;;154        p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
;;;155        p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
;;;156        p_mem->NbrMax      = n_blks;
;;;157        p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
;;;158    
;;;159    #if OS_CFG_DBG_EN > 0u
;;;160        OS_MemDbgListAdd(p_mem);
;;;161    #endif
;;;162    
;;;163        OSMemQty++;
;;;164    
;;;165        OS_CRITICAL_EXIT_NO_SCHED();
;;;166       *p_err = OS_ERR_NONE;
;;;167    }
000022  b007              ADD      sp,sp,#0x1c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.40|
000028  b91d              CBNZ     r5,|L1.50|
00002a  f24560bb          MOV      r0,#0x56bb            ;116
00002e  8030              STRH     r0,[r6,#0]            ;116
000030  e7f7              B        |L1.34|
                  |L1.50|
000032  2f02              CMP      r7,#2                 ;119
000034  da03              BGE      |L1.62|
000036  f24560bc          MOV      r0,#0x56bc            ;120
00003a  8030              STRH     r0,[r6,#0]            ;120
00003c  e7f1              B        |L1.34|
                  |L1.62|
00003e  f1b90f04          CMP      r9,#4                 ;123
000042  d203              BCS      |L1.76|
000044  f24560c1          MOV      r0,#0x56c1            ;124
000048  8030              STRH     r0,[r6,#0]            ;124
00004a  e7ea              B        |L1.34|
                  |L1.76|
00004c  f04f0a03          MOV      r10,#3                ;127
000050  f1ba0f00          CMP      r10,#0                ;128
000054  d00d              BEQ      |L1.114|
000056  ea05000a          AND      r0,r5,r10             ;129
00005a  b118              CBZ      r0,|L1.100|
00005c  f24560bb          MOV      r0,#0x56bb            ;130
000060  8030              STRH     r0,[r6,#0]            ;130
000062  e7de              B        |L1.34|
                  |L1.100|
000064  ea09000a          AND      r0,r9,r10             ;133
000068  b118              CBZ      r0,|L1.114|
00006a  f24560c1          MOV      r0,#0x56c1            ;134
00006e  8030              STRH     r0,[r6,#0]            ;134
000070  e7d7              B        |L1.34|
                  |L1.114|
000072  46ab              MOV      r11,r5                ;140
000074  46a8              MOV      r8,r5                 ;141
000076  1e78              SUBS     r0,r7,#1              ;142
000078  b280              UXTH     r0,r0                 ;142
00007a  9001              STR      r0,[sp,#4]            ;142
00007c  2000              MOVS     r0,#0                 ;143
00007e  9002              STR      r0,[sp,#8]            ;143
000080  e007              B        |L1.146|
                  |L1.130|
000082  44c8              ADD      r8,r8,r9              ;144
000084  f8cb8000          STR      r8,[r11,#0]           ;145
000088  46c3              MOV      r11,r8                ;146
00008a  9802              LDR      r0,[sp,#8]            ;143
00008c  1c40              ADDS     r0,r0,#1              ;143
00008e  b280              UXTH     r0,r0                 ;143
000090  9002              STR      r0,[sp,#8]            ;143
                  |L1.146|
000092  e9dd1001          LDRD     r1,r0,[sp,#4]         ;143
000096  4288              CMP      r0,r1                 ;143
000098  dbf3              BLT      |L1.130|
00009a  2000              MOVS     r0,#0                 ;148
00009c  f8cb0000          STR      r0,[r11,#0]           ;148
0000a0  bf00              NOP                            ;150
0000a2  bf00              NOP                            ;150
0000a4  f7fffffe          BL       CPU_SR_Save
0000a8  9000              STR      r0,[sp,#0]            ;150
0000aa  bf00              NOP                            ;150
0000ac  bf00              NOP                            ;150
0000ae  480f              LDR      r0,|L1.236|
0000b0  6020              STR      r0,[r4,#0]            ;151
0000b2  9804              LDR      r0,[sp,#0x10]         ;152
0000b4  60a0              STR      r0,[r4,#8]            ;152
0000b6  6065              STR      r5,[r4,#4]            ;153
0000b8  60e5              STR      r5,[r4,#0xc]          ;154
0000ba  82a7              STRH     r7,[r4,#0x14]         ;155
0000bc  8267              STRH     r7,[r4,#0x12]         ;156
0000be  f8a49010          STRH     r9,[r4,#0x10]         ;157
0000c2  4620              MOV      r0,r4                 ;160
0000c4  f7fffffe          BL       OS_MemDbgListAdd
0000c8  4809              LDR      r0,|L1.240|
0000ca  8800              LDRH     r0,[r0,#0]            ;163  ; OSMemQty
0000cc  1c40              ADDS     r0,r0,#1              ;163
0000ce  4908              LDR      r1,|L1.240|
0000d0  8008              STRH     r0,[r1,#0]            ;163
0000d2  bf00              NOP                            ;165
0000d4  bf00              NOP                            ;165
0000d6  9800              LDR      r0,[sp,#0]            ;165
0000d8  f7fffffe          BL       CPU_SR_Restore
0000dc  bf00              NOP                            ;165
0000de  bf00              NOP                            ;165
0000e0  2000              MOVS     r0,#0                 ;166
0000e2  8030              STRH     r0,[r6,#0]            ;166
0000e4  bf00              NOP      
0000e6  e79c              B        |L1.34|
;;;168    
                          ENDP

                  |L1.232|
                          DCD      OSIntNestingCtr
                  |L1.236|
                          DCD      0x204d454d
                  |L1.240|
                          DCD      OSMemQty

                          AREA ||i.OSMemGet||, CODE, READONLY, ALIGN=1

                  OSMemGet PROC
;;;189    
;;;190    void  *OSMemGet (OS_MEM  *p_mem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;191                     OS_ERR  *p_err)
;;;192    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;193        void    *p_blk;
;;;194        CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;195    
;;;196    
;;;197    
;;;198    #ifdef OS_SAFETY_CRITICAL
;;;199        if (p_err == (OS_ERR *)0) {
;;;200            OS_SAFETY_CRITICAL_EXCEPTION();
;;;201            return ((void *)0);
;;;202        }
;;;203    #endif
;;;204    
;;;205    #if OS_CFG_ARG_CHK_EN > 0u
;;;206        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
00000a  b92c              CBNZ     r4,|L2.24|
;;;207           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
00000c  f24560bf          MOV      r0,#0x56bf
000010  8028              STRH     r0,[r5,#0]
;;;208            return ((void *)0);
000012  2000              MOVS     r0,#0
                  |L2.20|
;;;209        }
;;;210    #endif
;;;211    
;;;212        CPU_CRITICAL_ENTER();
;;;213        if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
;;;214            CPU_CRITICAL_EXIT();
;;;215           *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
;;;216            return ((void *)0);                                 /*      Return NULL pointer to caller                     */
;;;217        }
;;;218        p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
;;;219        p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
;;;220        p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
;;;221        CPU_CRITICAL_EXIT();
;;;222       *p_err = OS_ERR_NONE;                                    /*      No error                                          */
;;;223        return (p_blk);                                         /*      Return memory block to caller                     */
;;;224    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L2.24|
000018  bf00              NOP                            ;212
00001a  bf00              NOP                            ;212
00001c  f7fffffe          BL       CPU_SR_Save
000020  4607              MOV      r7,r0                 ;212
000022  bf00              NOP                            ;212
000024  bf00              NOP                            ;212
000026  8aa0              LDRH     r0,[r4,#0x14]         ;213
000028  b958              CBNZ     r0,|L2.66|
00002a  bf00              NOP                            ;214
00002c  bf00              NOP                            ;214
00002e  4638              MOV      r0,r7                 ;214
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP                            ;214
000036  bf00              NOP                            ;214
000038  f24560c2          MOV      r0,#0x56c2            ;215
00003c  8028              STRH     r0,[r5,#0]            ;215
00003e  2000              MOVS     r0,#0                 ;216
000040  e7e8              B        |L2.20|
                  |L2.66|
000042  68e6              LDR      r6,[r4,#0xc]          ;218
000044  6830              LDR      r0,[r6,#0]            ;219
000046  60e0              STR      r0,[r4,#0xc]          ;219
000048  8aa0              LDRH     r0,[r4,#0x14]         ;220
00004a  1e40              SUBS     r0,r0,#1              ;220
00004c  82a0              STRH     r0,[r4,#0x14]         ;220
00004e  bf00              NOP                            ;221
000050  bf00              NOP                            ;221
000052  4638              MOV      r0,r7                 ;221
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;221
00005a  bf00              NOP                            ;221
00005c  2000              MOVS     r0,#0                 ;222
00005e  8028              STRH     r0,[r5,#0]            ;222
000060  4630              MOV      r0,r6                 ;223
000062  e7d7              B        |L2.20|
;;;225    
                          ENDP


                          AREA ||i.OSMemPut||, CODE, READONLY, ALIGN=1

                  OSMemPut PROC
;;;246    
;;;247    void  OSMemPut (OS_MEM  *p_mem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;248                    void    *p_blk,
;;;249                    OS_ERR  *p_err)
;;;250    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;251        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;252    
;;;253    
;;;254    
;;;255    #ifdef OS_SAFETY_CRITICAL
;;;256        if (p_err == (OS_ERR *)0) {
;;;257            OS_SAFETY_CRITICAL_EXCEPTION();
;;;258            return;
;;;259        }
;;;260    #endif
;;;261    
;;;262    #if OS_CFG_ARG_CHK_EN > 0u
;;;263        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
00000c  b924              CBNZ     r4,|L3.24|
;;;264           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
00000e  f24560bf          MOV      r0,#0x56bf
000012  8028              STRH     r0,[r5,#0]
                  |L3.20|
;;;265            return;
;;;266        }
;;;267        if (p_blk == (void *)0) {                               /* Must release a valid block                             */
;;;268           *p_err  = OS_ERR_MEM_INVALID_P_BLK;
;;;269            return;
;;;270        }
;;;271    #endif
;;;272    
;;;273        CPU_CRITICAL_ENTER();
;;;274        if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
;;;275            CPU_CRITICAL_EXIT();
;;;276           *p_err = OS_ERR_MEM_FULL;
;;;277            return;
;;;278        }
;;;279        *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
;;;280        p_mem->FreeListPtr = p_blk;
;;;281        p_mem->NbrFree++;                                       /* One more memory block in this partition                */
;;;282        CPU_CRITICAL_EXIT();
;;;283       *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
;;;284    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  b91e              CBNZ     r6,|L3.34|
00001a  f24560be          MOV      r0,#0x56be            ;268
00001e  8028              STRH     r0,[r5,#0]            ;268
000020  e7f8              B        |L3.20|
                  |L3.34|
000022  bf00              NOP                            ;273
000024  bf00              NOP                            ;273
000026  f7fffffe          BL       CPU_SR_Save
00002a  4607              MOV      r7,r0                 ;273
00002c  bf00              NOP                            ;273
00002e  bf00              NOP                            ;273
000030  8aa0              LDRH     r0,[r4,#0x14]         ;274
000032  8a61              LDRH     r1,[r4,#0x12]         ;274
000034  4288              CMP      r0,r1                 ;274
000036  db0a              BLT      |L3.78|
000038  bf00              NOP                            ;275
00003a  bf00              NOP                            ;275
00003c  4638              MOV      r0,r7                 ;275
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;275
000044  bf00              NOP                            ;275
000046  f24560ba          MOV      r0,#0x56ba            ;276
00004a  8028              STRH     r0,[r5,#0]            ;276
00004c  e7e2              B        |L3.20|
                  |L3.78|
00004e  68e0              LDR      r0,[r4,#0xc]          ;279
000050  6030              STR      r0,[r6,#0]            ;279
000052  60e6              STR      r6,[r4,#0xc]          ;280
000054  8aa0              LDRH     r0,[r4,#0x14]         ;281
000056  1c40              ADDS     r0,r0,#1              ;281
000058  82a0              STRH     r0,[r4,#0x14]         ;281
00005a  bf00              NOP                            ;282
00005c  bf00              NOP                            ;282
00005e  4638              MOV      r0,r7                 ;282
000060  f7fffffe          BL       CPU_SR_Restore
000064  bf00              NOP                            ;282
000066  bf00              NOP                            ;282
000068  2000              MOVS     r0,#0                 ;283
00006a  8028              STRH     r0,[r5,#0]            ;283
00006c  bf00              NOP      
00006e  e7d1              B        |L3.20|
;;;285    
                          ENDP


                          AREA ||i.OS_MemDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MemDbgListAdd PROC
;;;301    #if OS_CFG_DBG_EN > 0u
;;;302    void  OS_MemDbgListAdd (OS_MEM  *p_mem)
000000  2100              MOVS     r1,#0
;;;303    {
;;;304        p_mem->DbgPrevPtr               = (OS_MEM *)0;
000002  6181              STR      r1,[r0,#0x18]
;;;305        if (OSMemDbgListPtr == (OS_MEM *)0) {
000004  4907              LDR      r1,|L4.36|
000006  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
000008  b911              CBNZ     r1,|L4.16|
;;;306            p_mem->DbgNextPtr           = (OS_MEM *)0;
00000a  2100              MOVS     r1,#0
00000c  61c1              STR      r1,[r0,#0x1c]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;307        } else {
;;;308            p_mem->DbgNextPtr           =  OSMemDbgListPtr;
000010  4904              LDR      r1,|L4.36|
000012  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
000014  61c1              STR      r1,[r0,#0x1c]
;;;309            OSMemDbgListPtr->DbgPrevPtr =  p_mem;
000016  4903              LDR      r1,|L4.36|
000018  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
00001a  6188              STR      r0,[r1,#0x18]
                  |L4.28|
;;;310        }
;;;311        OSMemDbgListPtr                 =  p_mem;
00001c  4901              LDR      r1,|L4.36|
00001e  6008              STR      r0,[r1,#0]  ; OSMemDbgListPtr
;;;312    }
000020  4770              BX       lr
;;;313    #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      OSMemDbgListPtr

                          AREA ||i.OS_MemInit||, CODE, READONLY, ALIGN=2

                  OS_MemInit PROC
;;;330    
;;;331    void  OS_MemInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;332    {
;;;333    #ifdef OS_SAFETY_CRITICAL
;;;334        if (p_err == (OS_ERR *)0) {
;;;335            OS_SAFETY_CRITICAL_EXCEPTION();
;;;336            return;
;;;337        }
;;;338    #endif
;;;339    
;;;340    #if OS_CFG_DBG_EN > 0u
;;;341        OSMemDbgListPtr = (OS_MEM   *)0;
000002  4a03              LDR      r2,|L5.16|
000004  6011              STR      r1,[r2,#0]  ; OSMemDbgListPtr
;;;342    #endif
;;;343    
;;;344        OSMemQty        = (OS_OBJ_QTY)0;
000006  4a03              LDR      r2,|L5.20|
000008  8011              STRH     r1,[r2,#0]
;;;345       *p_err           = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;346    }
00000c  4770              BX       lr
;;;347    #endif
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      OSMemDbgListPtr
                  |L5.20|
                          DCD      OSMemQty
