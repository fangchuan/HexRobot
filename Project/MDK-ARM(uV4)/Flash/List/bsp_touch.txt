; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_touch.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_touch.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_touch.crf ..\..\User\bsp_stm32f4xx\src\bsp_touch.c]
                          THUMB

                          AREA ||i.CalTwoPoint||, CODE, READONLY, ALIGN=1

                  CalTwoPoint PROC
;;;653    */
;;;654    static int32_t CalTwoPoint(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t x)
000000  b570              PUSH     {r4-r6,lr}
;;;655    {
000002  4604              MOV      r4,r0
000004  9d04              LDR      r5,[sp,#0x10]
;;;656    	return y1 + ((int32_t)(y2 - y1) * (x - x1)) / (x2 - x1);
000006  1a58              SUBS     r0,r3,r1
000008  1b2e              SUBS     r6,r5,r4
00000a  4370              MULS     r0,r6,r0
00000c  1b16              SUBS     r6,r2,r4
00000e  fb90f0f6          SDIV     r0,r0,r6
000012  4408              ADD      r0,r0,r1
;;;657    }
000014  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||i.TOUCH_Abs||, CODE, READONLY, ALIGN=1

                  TOUCH_Abs PROC
;;;1029   */
;;;1030   int32_t TOUCH_Abs(int32_t x)
000000  4601              MOV      r1,r0
;;;1031   {
;;;1032   	if (x >= 0)
000002  2900              CMP      r1,#0
000004  db01              BLT      |L2.10|
;;;1033   	{
;;;1034   		return x;
000006  4608              MOV      r0,r1
                  |L2.8|
;;;1035   	}
;;;1036   	else
;;;1037   	{
;;;1038   		return -x;
;;;1039   	}
;;;1040   }
000008  4770              BX       lr
                  |L2.10|
00000a  4248              RSBS     r0,r1,#0              ;1038
00000c  e7fc              B        |L2.8|
;;;1041   
                          ENDP


                          AREA ||i.TOUCH_Calibration||, CODE, READONLY, ALIGN=2

                  TOUCH_Calibration PROC
;;;1049   */
;;;1050   void TOUCH_Calibration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1051   {
;;;1052   	uint16_t usAdcX;
;;;1053   	uint16_t usAdcY;
;;;1054   	uint8_t usCount;
;;;1055   	uint8_t i;
;;;1056   	uint32_t n;
;;;1057   
;;;1058   	TOUCH_CelarFIFO();		/* 清除无效的触摸事件 */
000004  f7fffffe          BL       TOUCH_CelarFIFO
;;;1059   
;;;1060   	for (i = 0; i < CALIB_POINT_COUNT; i++)
000008  2600              MOVS     r6,#0
00000a  e03f              B        |L3.140|
                  |L3.12|
;;;1061   	{
;;;1062   		TOUCH_DispPoint(i);		/* 显示校准点 */
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       TOUCH_DispPoint
;;;1063   
;;;1064   		TOUCH_WaitRelease(); 	/* 等待触笔释放 */
000012  f7fffffe          BL       TOUCH_WaitRelease
;;;1065   
;;;1066   		usCount = 0;
000016  f04f0800          MOV      r8,#0
;;;1067   		for (n = 0; n < 500; n++)
00001a  2700              MOVS     r7,#0
00001c  e02b              B        |L3.118|
                  |L3.30|
;;;1068   		{
;;;1069   			usAdcX = TOUCH_ReadAdcX();
00001e  f7fffffe          BL       TOUCH_ReadAdcX
000022  4604              MOV      r4,r0
;;;1070   			usAdcY = TOUCH_ReadAdcY();
000024  f7fffffe          BL       TOUCH_ReadAdcY
000028  4605              MOV      r5,r0
;;;1071   
;;;1072   			if (TOUCH_PressValid(usAdcX, usAdcY))
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TOUCH_PressValid
000032  b1d0              CBZ      r0,|L3.106|
;;;1073   			{
;;;1074   				if (++usCount > 5)
000034  f1080001          ADD      r0,r8,#1
000038  b2c0              UXTB     r0,r0
00003a  4680              MOV      r8,r0
00003c  2805              CMP      r0,#5
00003e  dd16              BLE      |L3.110|
;;;1075   				{
;;;1076   					/* 按压有效, 保存校准点ADC采样值 */
;;;1077   					if (i == 0)
000040  b91e              CBNZ     r6,|L3.74|
;;;1078   					{
;;;1079   						g_tTP.usAdcX1 = usAdcX;
000042  483e              LDR      r0,|L3.316|
000044  8004              STRH     r4,[r0,#0]
;;;1080   						g_tTP.usAdcY1 = usAdcY;
000046  8045              STRH     r5,[r0,#2]
000048  e00e              B        |L3.104|
                  |L3.74|
;;;1081   					}
;;;1082   					else if (i == 1)
00004a  2e01              CMP      r6,#1
00004c  d103              BNE      |L3.86|
;;;1083   					{
;;;1084   						g_tTP.usAdcX2 = usAdcX;
00004e  483b              LDR      r0,|L3.316|
000050  8084              STRH     r4,[r0,#4]
;;;1085   						g_tTP.usAdcY2 = usAdcY;
000052  80c5              STRH     r5,[r0,#6]
000054  e008              B        |L3.104|
                  |L3.86|
;;;1086   					}
;;;1087   					else if (i == 2)
000056  2e02              CMP      r6,#2
000058  d103              BNE      |L3.98|
;;;1088   					{
;;;1089   						g_tTP.usAdcX3 = usAdcX;
00005a  4838              LDR      r0,|L3.316|
00005c  8104              STRH     r4,[r0,#8]
;;;1090   						g_tTP.usAdcY3 = usAdcY;
00005e  8145              STRH     r5,[r0,#0xa]
000060  e002              B        |L3.104|
                  |L3.98|
;;;1091   					}
;;;1092   					else
;;;1093   					{
;;;1094   						g_tTP.usAdcX4 = usAdcX;
000062  4836              LDR      r0,|L3.316|
000064  8184              STRH     r4,[r0,#0xc]
;;;1095   						g_tTP.usAdcY4 = usAdcY;
000066  81c5              STRH     r5,[r0,#0xe]
                  |L3.104|
;;;1096   					}
;;;1097   					break;
000068  e008              B        |L3.124|
                  |L3.106|
;;;1098   				}
;;;1099   			}
;;;1100   			else
;;;1101   			{
;;;1102   				usCount = 0;
00006a  f04f0800          MOV      r8,#0
                  |L3.110|
;;;1103   			}
;;;1104   			bsp_DelayMS(10);
00006e  200a              MOVS     r0,#0xa
000070  f7fffffe          BL       bsp_DelayMS
000074  1c7f              ADDS     r7,r7,#1              ;1067
                  |L3.118|
000076  f5b77ffa          CMP      r7,#0x1f4             ;1067
00007a  d3d0              BCC      |L3.30|
                  |L3.124|
00007c  bf00              NOP                            ;1097
;;;1105   		}
;;;1106   		if (n == 500)
00007e  f5b77ffa          CMP      r7,#0x1f4
000082  d101              BNE      |L3.136|
                  |L3.132|
;;;1107   		{
;;;1108   			return;
;;;1109   		}
;;;1110   	}
;;;1111   
;;;1112   	TOUCH_WaitRelease(); 	/* 等待触笔释放 */
;;;1113   
;;;1114   	/* 识别触摸的 X, Y 和 显示面板的 X，Y 是否需要交换 */
;;;1115   	g_tTP.XYChange = 0;		/* 1表示X Y需要交换 */
;;;1116   	if (LCD_GetHeight() < LCD_GetWidth())
;;;1117   	{
;;;1118   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) < TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
;;;1119   		{
;;;1120   			g_tTP.XYChange = 1;
;;;1121   		}
;;;1122   	}
;;;1123   	else
;;;1124   	{
;;;1125   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) > TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
;;;1126   		{
;;;1127   			g_tTP.XYChange = 1;
;;;1128   		}
;;;1129   	}
;;;1130   
;;;1131   	g_tTP.usLcdX1 = TP_X1;
;;;1132   	g_tTP.usLcdY1 = TP_Y1;
;;;1133   	g_tTP.usLcdX2 = TP_X2;
;;;1134   	g_tTP.usLcdY2 = TP_Y2;
;;;1135   	g_tTP.usLcdX3 = TP_X3;
;;;1136   	g_tTP.usLcdY3 = TP_Y3;
;;;1137   	g_tTP.usLcdX4 = TP_X3;
;;;1138   	g_tTP.usLcdY4 = TP_Y3;
;;;1139   
;;;1140   	/* 在最后一步，可以将校准参数保存入Flash 或者EEPROM */
;;;1141   	TOUCH_SaveParam();
;;;1142   }
000084  e8bd87f0          POP      {r4-r10,pc}
                  |L3.136|
000088  1c70              ADDS     r0,r6,#1              ;1060
00008a  b2c6              UXTB     r6,r0                 ;1060
                  |L3.140|
00008c  2e04              CMP      r6,#4                 ;1060
00008e  dbbd              BLT      |L3.12|
000090  f7fffffe          BL       TOUCH_WaitRelease
000094  2000              MOVS     r0,#0                 ;1115
000096  4929              LDR      r1,|L3.316|
000098  8408              STRH     r0,[r1,#0x20]         ;1115
00009a  f7fffffe          BL       LCD_GetHeight
00009e  4681              MOV      r9,r0                 ;1116
0000a0  f7fffffe          BL       LCD_GetWidth
0000a4  4581              CMP      r9,r0                 ;1116
0000a6  da14              BGE      |L3.210|
0000a8  4924              LDR      r1,|L3.316|
0000aa  8809              LDRH     r1,[r1,#0]            ;1118  ; g_tTP
0000ac  4a23              LDR      r2,|L3.316|
0000ae  8892              LDRH     r2,[r2,#4]            ;1118  ; g_tTP
0000b0  1a88              SUBS     r0,r1,r2              ;1118
0000b2  f7fffffe          BL       TOUCH_Abs
0000b6  4602              MOV      r2,r0                 ;1118
0000b8  4920              LDR      r1,|L3.316|
0000ba  8849              LDRH     r1,[r1,#2]            ;1118  ; g_tTP
0000bc  4b1f              LDR      r3,|L3.316|
0000be  88db              LDRH     r3,[r3,#6]            ;1118  ; g_tTP
0000c0  1ac8              SUBS     r0,r1,r3              ;1118
0000c2  f7fffffe          BL       TOUCH_Abs
0000c6  4282              CMP      r2,r0                 ;1118
0000c8  da17              BGE      |L3.250|
0000ca  2001              MOVS     r0,#1                 ;1120
0000cc  491b              LDR      r1,|L3.316|
0000ce  8408              STRH     r0,[r1,#0x20]         ;1120
0000d0  e013              B        |L3.250|
                  |L3.210|
0000d2  491a              LDR      r1,|L3.316|
0000d4  8809              LDRH     r1,[r1,#0]            ;1125  ; g_tTP
0000d6  4a19              LDR      r2,|L3.316|
0000d8  8892              LDRH     r2,[r2,#4]            ;1125  ; g_tTP
0000da  1a88              SUBS     r0,r1,r2              ;1125
0000dc  f7fffffe          BL       TOUCH_Abs
0000e0  4602              MOV      r2,r0                 ;1125
0000e2  4916              LDR      r1,|L3.316|
0000e4  8849              LDRH     r1,[r1,#2]            ;1125  ; g_tTP
0000e6  4b15              LDR      r3,|L3.316|
0000e8  88db              LDRH     r3,[r3,#6]            ;1125  ; g_tTP
0000ea  1ac8              SUBS     r0,r1,r3              ;1125
0000ec  f7fffffe          BL       TOUCH_Abs
0000f0  4282              CMP      r2,r0                 ;1125
0000f2  dd02              BLE      |L3.250|
0000f4  2001              MOVS     r0,#1                 ;1127
0000f6  4911              LDR      r1,|L3.316|
0000f8  8408              STRH     r0,[r1,#0x20]         ;1127
                  |L3.250|
0000fa  2014              MOVS     r0,#0x14              ;1131
0000fc  490f              LDR      r1,|L3.316|
0000fe  8208              STRH     r0,[r1,#0x10]         ;1131
000100  8248              STRH     r0,[r1,#0x12]         ;1132
000102  f7fffffe          BL       LCD_GetWidth
000106  3814              SUBS     r0,r0,#0x14           ;1133
000108  490c              LDR      r1,|L3.316|
00010a  8288              STRH     r0,[r1,#0x14]         ;1133
00010c  f7fffffe          BL       LCD_GetHeight
000110  3814              SUBS     r0,r0,#0x14           ;1134
000112  490a              LDR      r1,|L3.316|
000114  82c8              STRH     r0,[r1,#0x16]         ;1134
000116  2014              MOVS     r0,#0x14              ;1135
000118  8308              STRH     r0,[r1,#0x18]         ;1135
00011a  f7fffffe          BL       LCD_GetHeight
00011e  3814              SUBS     r0,r0,#0x14           ;1136
000120  4906              LDR      r1,|L3.316|
000122  8348              STRH     r0,[r1,#0x1a]         ;1136
000124  2014              MOVS     r0,#0x14              ;1137
000126  8388              STRH     r0,[r1,#0x1c]         ;1137
000128  f7fffffe          BL       LCD_GetHeight
00012c  3814              SUBS     r0,r0,#0x14           ;1138
00012e  4903              LDR      r1,|L3.316|
000130  83c8              STRH     r0,[r1,#0x1e]         ;1138
000132  f7fffffe          BL       TOUCH_SaveParam
000136  bf00              NOP      
000138  e7a4              B        |L3.132|
;;;1143   
                          ENDP

00013a  0000              DCW      0x0000
                  |L3.316|
                          DCD      g_tTP

                          AREA ||i.TOUCH_CapScan||, CODE, READONLY, ALIGN=2

                  TOUCH_CapScan PROC
;;;482    */
;;;483    void TOUCH_CapScan(void)
000000  b510              PUSH     {r4,lr}
;;;484    {
;;;485    	if (g_GT811.Enable == 1)
000002  4808              LDR      r0,|L4.36|
000004  7800              LDRB     r0,[r0,#0]  ; g_GT811
000006  2801              CMP      r0,#1
000008  d102              BNE      |L4.16|
;;;486    	{
;;;487    		GT811_Scan();
00000a  f7fffffe          BL       GT811_Scan
                  |L4.14|
;;;488    		return;
;;;489    	}
;;;490    	
;;;491    	if (g_tFT5X06.Enable == 1)
;;;492    	{
;;;493    		FT5X06_Scan();
;;;494    		return;
;;;495    	}
;;;496    }
00000e  bd10              POP      {r4,pc}
                  |L4.16|
000010  4805              LDR      r0,|L4.40|
000012  7840              LDRB     r0,[r0,#1]            ;491  ; g_tFT5X06
000014  2801              CMP      r0,#1                 ;491
000016  d102              BNE      |L4.30|
000018  f7fffffe          BL       FT5X06_Scan
00001c  e7f7              B        |L4.14|
                  |L4.30|
00001e  bf00              NOP      
000020  e7f5              B        |L4.14|
;;;497    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      g_GT811
                  |L4.40|
                          DCD      g_tFT5X06

                          AREA ||i.TOUCH_CelarFIFO||, CODE, READONLY, ALIGN=2

                  TOUCH_CelarFIFO PROC
;;;409    */
;;;410    void TOUCH_CelarFIFO(void)
000000  b510              PUSH     {r4,lr}
;;;411    {
;;;412    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;413    	g_tTP.Write = g_tTP.Read;
000008  4804              LDR      r0,|L5.28|
00000a  f890008e          LDRB     r0,[r0,#0x8e]  ; g_tTP
00000e  4903              LDR      r1,|L5.28|
000010  f881008f          STRB     r0,[r1,#0x8f]
;;;414    	__set_PRIMASK(0);  		/* 开中断 */
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       __set_PRIMASK
;;;415    }
00001a  bd10              POP      {r4,pc}
;;;416    
                          ENDP

                  |L5.28|
                          DCD      g_tTP

                          AREA ||i.TOUCH_DataFilter||, CODE, READONLY, ALIGN=1

                  TOUCH_DataFilter PROC
;;;868    */
;;;869    static uint16_t TOUCH_DataFilter(uint16_t *_pBuf, uint8_t _ucCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;870    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;871    #if 0
;;;872    	uint8_t i;
;;;873    	uint32_t uiSum;
;;;874    
;;;875    	uiSum = 0;
;;;876    	for (i = 0; i < _ucCount; i++)
;;;877    	{
;;;878    		uiSum += _pBuf[i];
;;;879    	}
;;;880    	return uiSum / _ucCount;
;;;881    #else
;;;882    	uint8_t flag;
;;;883    	uint8_t i;
;;;884    	uint16_t usTemp;
;;;885    	uint32_t uiSum;
;;;886    
;;;887    	/* 升序排列 */
;;;888        do
000006  bf00              NOP      
                  |L6.8|
;;;889    	{
;;;890    		flag = 0;
000008  2500              MOVS     r5,#0
;;;891    		for (i = 0; i < _ucCount - 1; i++)
00000a  2100              MOVS     r1,#0
00000c  e012              B        |L6.52|
                  |L6.14|
;;;892    		{
;;;893    			if (_pBuf[i] > _pBuf[i+1])
00000e  f8327011          LDRH     r7,[r2,r1,LSL #1]
000012  1c4e              ADDS     r6,r1,#1
000014  f8326016          LDRH     r6,[r2,r6,LSL #1]
000018  42b7              CMP      r7,r6
00001a  dd09              BLE      |L6.48|
;;;894    			{
;;;895    				usTemp = _pBuf[i + 1];
00001c  1c4e              ADDS     r6,r1,#1
00001e  f8320016          LDRH     r0,[r2,r6,LSL #1]
;;;896    				_pBuf[i+1] = _pBuf[i];
000022  f8327011          LDRH     r7,[r2,r1,LSL #1]
000026  f8227016          STRH     r7,[r2,r6,LSL #1]
;;;897    				_pBuf[i] = usTemp;
00002a  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;898    				flag = 1;
00002e  2501              MOVS     r5,#1
                  |L6.48|
000030  1c4e              ADDS     r6,r1,#1              ;891
000032  b2f1              UXTB     r1,r6                 ;891
                  |L6.52|
000034  1e5e              SUBS     r6,r3,#1              ;891
000036  428e              CMP      r6,r1                 ;891
000038  dce9              BGT      |L6.14|
;;;899    			}
;;;900    		}
;;;901    	}while(flag);
00003a  2d00              CMP      r5,#0
00003c  d1e4              BNE      |L6.8|
;;;902    
;;;903    	uiSum = 0;
00003e  2400              MOVS     r4,#0
;;;904    	for (i = 0; i < _ucCount / 3; i++)
000040  2100              MOVS     r1,#0
000042  e008              B        |L6.86|
                  |L6.68|
;;;905    	{
;;;906    		uiSum += _pBuf[_ucCount / 3 + i];
000044  2603              MOVS     r6,#3
000046  fb93f6f6          SDIV     r6,r3,r6
00004a  440e              ADD      r6,r6,r1
00004c  f8326016          LDRH     r6,[r2,r6,LSL #1]
000050  4434              ADD      r4,r4,r6
000052  1c4e              ADDS     r6,r1,#1              ;904
000054  b2f1              UXTB     r1,r6                 ;904
                  |L6.86|
000056  2603              MOVS     r6,#3                 ;904
000058  fb93f6f6          SDIV     r6,r3,r6              ;904
00005c  428e              CMP      r6,r1                 ;904
00005e  dcf1              BGT      |L6.68|
;;;907    	}
;;;908    	usTemp = uiSum / (_ucCount / 3);
000060  2603              MOVS     r6,#3
000062  fb93f6f6          SDIV     r6,r3,r6
000066  fbb4f6f6          UDIV     r6,r4,r6
00006a  b2b0              UXTH     r0,r6
;;;909    	return usTemp;
;;;910    #endif
;;;911    }
00006c  bdf0              POP      {r4-r7,pc}
;;;912    
                          ENDP


                          AREA ||i.TOUCH_DispPoint||, CODE, READONLY, ALIGN=2

                  TOUCH_DispPoint PROC
;;;920    */
;;;921    static void TOUCH_DispPoint(uint8_t _ucIndex)
000000  b5fe              PUSH     {r1-r7,lr}
;;;922    {
000002  4604              MOV      r4,r0
;;;923    	FONT_T tFont16;			/* 定义一个字体结构体变量，用于设置字体参数 */
;;;924    
;;;925    	/* 设置字体参数 */
;;;926    	{
;;;927    		tFont16.FontCode = FC_ST_16;	/* 字体代码 16点阵 */
000004  2001              MOVS     r0,#1
000006  f88d0004          STRB     r0,[sp,#4]
;;;928    		tFont16.FrontColor = CL_WHITE;		/* 字体颜色 0 或 1 */
00000a  f64f70ff          MOV      r0,#0xffff
00000e  f8ad0006          STRH     r0,[sp,#6]
;;;929    		tFont16.BackColor = CL_BLUE;	/* 文字背景颜色 */
000012  201f              MOVS     r0,#0x1f
000014  f8ad0008          STRH     r0,[sp,#8]
;;;930    		tFont16.Space = 0;			/* 文字间距，单位 = 像素 */
000018  2000              MOVS     r0,#0
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;931    	}
;;;932    
;;;933    /*
;;;934    	第1个点 ： x1 = CALIB_OFFSET, y1 = CALIB_OFFSET
;;;935    	第2个点 ： x2 = LCD_GetHeight() - CALIB_OFFSET, y2 = LCD_GetWidth - CALIB_OFFSET
;;;936    */
;;;937    	if (_ucIndex == 0)
00001e  2c00              CMP      r4,#0
000020  d136              BNE      |L7.144|
;;;938    	{
;;;939    		LCD_ClrScr(CL_BLUE);  		/* 清屏，背景蓝色 */
000022  201f              MOVS     r0,#0x1f
000024  f7fffffe          BL       LCD_ClrScr
;;;940    
;;;941    		/* 在屏幕边沿绘制2个矩形框(用于检测面板边缘像素是否正常) */
;;;942    		LCD_DrawRect(0, 0, LCD_GetHeight(), LCD_GetWidth(), CL_WHITE);
000028  f7fffffe          BL       LCD_GetWidth
00002c  4605              MOV      r5,r0
00002e  f7fffffe          BL       LCD_GetHeight
000032  4606              MOV      r6,r0
000034  f64f70ff          MOV      r0,#0xffff
000038  462b              MOV      r3,r5
00003a  4632              MOV      r2,r6
00003c  2100              MOVS     r1,#0
00003e  9000              STR      r0,[sp,#0]
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       LCD_DrawRect
;;;943    		LCD_DrawRect(2, 2, LCD_GetHeight() - 4, LCD_GetWidth() - 4, CL_YELLOW);
000046  f7fffffe          BL       LCD_GetWidth
00004a  1f00              SUBS     r0,r0,#4
00004c  b285              UXTH     r5,r0
00004e  f7fffffe          BL       LCD_GetHeight
000052  1f00              SUBS     r0,r0,#4
000054  b286              UXTH     r6,r0
000056  f64f70e0          MOV      r0,#0xffe0
00005a  462b              MOV      r3,r5
00005c  4632              MOV      r2,r6
00005e  2102              MOVS     r1,#2
000060  9000              STR      r0,[sp,#0]
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       LCD_DrawRect
;;;944    		
;;;945    		LCD_DispStr(50, 10, "触摸屏四点校准，十秒内不校准将自动返回主界面", &tFont16);		/* 在(8,3)坐标处显示一串汉字 */
000068  ab01              ADD      r3,sp,#4
00006a  a22e              ADR      r2,|L7.292|
00006c  210a              MOVS     r1,#0xa
00006e  2032              MOVS     r0,#0x32
000070  f7fffffe          BL       LCD_DispStr
;;;946    		LCD_DispStr(50, 27, "电阻屏需要校准，电容屏无需校准", &tFont16);
000074  ab01              ADD      r3,sp,#4
000076  a237              ADR      r2,|L7.340|
000078  211b              MOVS     r1,#0x1b
00007a  2032              MOVS     r0,#0x32
00007c  f7fffffe          BL       LCD_DispStr
;;;947    
;;;948    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_WHITE);
000080  f64f73ff          MOV      r3,#0xffff
000084  2206              MOVS     r2,#6
000086  2114              MOVS     r1,#0x14
000088  4608              MOV      r0,r1
00008a  f7fffffe          BL       LCD_DrawCircle
00008e  e048              B        |L7.290|
                  |L7.144|
;;;949    	}
;;;950    	else if (_ucIndex == 1)
000090  2c01              CMP      r4,#1
000092  d115              BNE      |L7.192|
;;;951    	{
;;;952    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_BLUE);			/* 擦除第1个点 */
000094  231f              MOVS     r3,#0x1f
000096  2206              MOVS     r2,#6
000098  2114              MOVS     r1,#0x14
00009a  4608              MOV      r0,r1
00009c  f7fffffe          BL       LCD_DrawCircle
;;;953    
;;;954    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_WHITE);
0000a0  f7fffffe          BL       LCD_GetHeight
0000a4  3814              SUBS     r0,r0,#0x14
0000a6  b285              UXTH     r5,r0
0000a8  f7fffffe          BL       LCD_GetWidth
0000ac  3814              SUBS     r0,r0,#0x14
0000ae  b286              UXTH     r6,r0
0000b0  f64f73ff          MOV      r3,#0xffff
0000b4  2206              MOVS     r2,#6
0000b6  4629              MOV      r1,r5
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       LCD_DrawCircle
0000be  e030              B        |L7.290|
                  |L7.192|
;;;955    	}
;;;956    	else if (_ucIndex == 2)
0000c0  2c02              CMP      r4,#2
0000c2  d119              BNE      |L7.248|
;;;957    	{
;;;958    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_BLUE);			/* 擦除第2个点 */
0000c4  f7fffffe          BL       LCD_GetHeight
0000c8  3814              SUBS     r0,r0,#0x14
0000ca  b285              UXTH     r5,r0
0000cc  f7fffffe          BL       LCD_GetWidth
0000d0  3814              SUBS     r0,r0,#0x14
0000d2  b286              UXTH     r6,r0
0000d4  231f              MOVS     r3,#0x1f
0000d6  2206              MOVS     r2,#6
0000d8  4629              MOV      r1,r5
0000da  4630              MOV      r0,r6
0000dc  f7fffffe          BL       LCD_DrawCircle
;;;959    
;;;960    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_WHITE);
0000e0  f7fffffe          BL       LCD_GetHeight
0000e4  3814              SUBS     r0,r0,#0x14
0000e6  b285              UXTH     r5,r0
0000e8  f64f73ff          MOV      r3,#0xffff
0000ec  2206              MOVS     r2,#6
0000ee  4629              MOV      r1,r5
0000f0  2014              MOVS     r0,#0x14
0000f2  f7fffffe          BL       LCD_DrawCircle
0000f6  e014              B        |L7.290|
                  |L7.248|
;;;961    	}
;;;962    	else
;;;963    	{
;;;964    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_BLUE);			/* 擦除第3个点 */
0000f8  f7fffffe          BL       LCD_GetHeight
0000fc  3814              SUBS     r0,r0,#0x14
0000fe  b285              UXTH     r5,r0
000100  231f              MOVS     r3,#0x1f
000102  2206              MOVS     r2,#6
000104  4629              MOV      r1,r5
000106  2014              MOVS     r0,#0x14
000108  f7fffffe          BL       LCD_DrawCircle
;;;965    
;;;966    		LCD_DrawCircle(TP_X4, TP_Y4, 6, CL_WHITE);
00010c  f7fffffe          BL       LCD_GetWidth
000110  3814              SUBS     r0,r0,#0x14
000112  b285              UXTH     r5,r0
000114  f64f73ff          MOV      r3,#0xffff
000118  2206              MOVS     r2,#6
00011a  2114              MOVS     r1,#0x14
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       LCD_DrawCircle
                  |L7.290|
;;;967    	}
;;;968    }
000122  bdfe              POP      {r1-r7,pc}
;;;969    
                          ENDP

                  |L7.292|
000124  b4a5c3fe          DCB      180,165,195,254,198,193,203,196,181,227,208,163,215,188,163
000128  c6c1cbc4
00012c  b5e3d0a3
000130  d7bca3  
000133  accaaec3          DCB      172,202,174,195,235,196,218,178,187,208,163,215,188,189,171
000137  ebc4dab2
00013b  bbd0a3d7
00013f  bcbdab  
000142  d7d4b6af          DCB      215,212,182,175,183,181,187,216,214,247,189,231,195,230,0
000146  b7b5bbd8
00014a  d6f7bde7
00014e  c3e600  
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L7.340|
000154  b5e7d7e8          DCB      181,231,215,232,198,193,208,232,210,170,208,163,215,188,163
000158  c6c1d0e8
00015c  d2aad0a3
000160  d7bca3  
000163  acb5e7c8          DCB      172,181,231,200,221,198,193,206,222,208,232,208,163,215,188
000167  ddc6c1ce
00016b  ded0e8d0
00016f  a3d7bc  
000172  00                DCB      0
000173  00                DCB      0

                          AREA ||i.TOUCH_GetKey||, CODE, READONLY, ALIGN=2

                  TOUCH_GetKey PROC
;;;379    */
;;;380    uint8_t TOUCH_GetKey(int16_t *_pX, int16_t *_pY)
000000  b510              PUSH     {r4,lr}
;;;381    {
000002  4602              MOV      r2,r0
;;;382    	uint8_t ret;
;;;383    
;;;384    	if (g_tTP.Read == g_tTP.Write)
000004  4815              LDR      r0,|L8.92|
000006  f890008e          LDRB     r0,[r0,#0x8e]  ; g_tTP
00000a  4c14              LDR      r4,|L8.92|
00000c  f894408f          LDRB     r4,[r4,#0x8f]  ; g_tTP
000010  42a0              CMP      r0,r4
000012  d101              BNE      |L8.24|
;;;385    	{
;;;386    		return TOUCH_NONE;
000014  2000              MOVS     r0,#0
                  |L8.22|
;;;387    	}
;;;388    	else
;;;389    	{
;;;390    		ret = g_tTP.Event[g_tTP.Read];
;;;391    		*_pX = g_tTP.XBuf[g_tTP.Read];
;;;392    		*_pY = g_tTP.YBuf[g_tTP.Read];
;;;393    
;;;394    		if (++g_tTP.Read >= TOUCH_FIFO_SIZE)
;;;395    		{
;;;396    			g_tTP.Read = 0;
;;;397    		}
;;;398    		return ret;
;;;399    	}
;;;400    }
000016  bd10              POP      {r4,pc}
                  |L8.24|
000018  4810              LDR      r0,|L8.92|
00001a  f890408e          LDRB     r4,[r0,#0x8e]         ;390  ; g_tTP
00001e  3029              ADDS     r0,r0,#0x29           ;390
000020  5d03              LDRB     r3,[r0,r4]            ;390
000022  3829              SUBS     r0,r0,#0x29           ;391
000024  f890408e          LDRB     r4,[r0,#0x8e]         ;391  ; g_tTP
000028  303e              ADDS     r0,r0,#0x3e           ;391
00002a  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;391
00002e  8010              STRH     r0,[r2,#0]            ;391
000030  480a              LDR      r0,|L8.92|
000032  f890408e          LDRB     r4,[r0,#0x8e]         ;392  ; g_tTP
000036  3066              ADDS     r0,r0,#0x66           ;392
000038  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;392
00003c  8008              STRH     r0,[r1,#0]            ;392
00003e  4807              LDR      r0,|L8.92|
000040  f890008e          LDRB     r0,[r0,#0x8e]         ;394  ; g_tTP
000044  1c40              ADDS     r0,r0,#1              ;394
000046  b2c0              UXTB     r0,r0                 ;394
000048  4c04              LDR      r4,|L8.92|
00004a  f884008e          STRB     r0,[r4,#0x8e]         ;394
00004e  2814              CMP      r0,#0x14              ;394
000050  db02              BLT      |L8.88|
000052  2000              MOVS     r0,#0                 ;396
000054  f884008e          STRB     r0,[r4,#0x8e]         ;396
                  |L8.88|
000058  4618              MOV      r0,r3                 ;398
00005a  e7dc              B        |L8.22|
;;;401    
                          ENDP

                  |L8.92|
                          DCD      g_tTP

                          AREA ||i.TOUCH_GetX||, CODE, READONLY, ALIGN=1

                  TOUCH_GetX PROC
;;;842    */
;;;843    int16_t TOUCH_GetX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
;;;845    	return TOUCH_TransX(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4604              MOV      r4,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  4605              MOV      r5,r0
00000e  4621              MOV      r1,r4
000010  f7fffffe          BL       TOUCH_TransX
;;;846    }
000014  bd70              POP      {r4-r6,pc}
;;;847    
                          ENDP


                          AREA ||i.TOUCH_GetY||, CODE, READONLY, ALIGN=1

                  TOUCH_GetY PROC
;;;855    */
;;;856    int16_t TOUCH_GetY(void)
000000  b570              PUSH     {r4-r6,lr}
;;;857    {
;;;858    	return TOUCH_TransY(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4604              MOV      r4,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  4605              MOV      r5,r0
00000e  4621              MOV      r1,r4
000010  f7fffffe          BL       TOUCH_TransY
;;;859    }
000014  bd70              POP      {r4-r6,pc}
;;;860    
                          ENDP


                          AREA ||i.TOUCH_InRect||, CODE, READONLY, ALIGN=1

                  TOUCH_InRect PROC
;;;426    */
;;;427    uint8_t TOUCH_InRect(uint16_t _usX, uint16_t _usY,
000000  b570              PUSH     {r4-r6,lr}
;;;428    	uint16_t _usRectX, uint16_t _usRectY, uint16_t _usRectH, uint16_t _usRectW)
;;;429    {
000002  4604              MOV      r4,r0
000004  e9dd5604          LDRD     r5,r6,[sp,#0x10]
;;;430    	if ((_usX > _usRectX) && (_usX < _usRectX + _usRectW)
000008  4294              CMP      r4,r2
00000a  dd09              BLE      |L11.32|
00000c  1990              ADDS     r0,r2,r6
00000e  42a0              CMP      r0,r4
000010  dd06              BLE      |L11.32|
;;;431    		&& (_usY > _usRectY) && (_usY < _usRectY + _usRectH))
000012  4299              CMP      r1,r3
000014  dd04              BLE      |L11.32|
000016  1958              ADDS     r0,r3,r5
000018  4288              CMP      r0,r1
00001a  dd01              BLE      |L11.32|
;;;432    	{
;;;433    		return 1;
00001c  2001              MOVS     r0,#1
                  |L11.30|
;;;434    	}
;;;435    	else
;;;436    	{
;;;437    		return 0;
;;;438    	}
;;;439    }
00001e  bd70              POP      {r4-r6,pc}
                  |L11.32|
000020  2000              MOVS     r0,#0                 ;437
000022  e7fc              B        |L11.30|
;;;440    
                          ENDP


                          AREA ||i.TOUCH_InitHard||, CODE, READONLY, ALIGN=2

                  TOUCH_InitHard PROC
;;;112    */
;;;113    void TOUCH_InitHard(void)
000000  b570              PUSH     {r4-r6,lr}
;;;114    {
;;;115    	uint16_t i;
;;;116    	
;;;117        g_tTP.Enable = 0;
000002  2000              MOVS     r0,#0
000004  491f              LDR      r1,|L12.132|
000006  f8810028          STRB     r0,[r1,#0x28]
;;;118        g_tTP.Write = g_tTP.Read = 0;	
00000a  f881008e          STRB     r0,[r1,#0x8e]
00000e  f881008f          STRB     r0,[r1,#0x8f]
;;;119    
;;;120    	/* 50ms，等待GT811复位就绪，才能探测GT811芯片 ID */
;;;121    	for (i = 0; i < 5; i++)
000012  2400              MOVS     r4,#0
000014  e01b              B        |L12.78|
                  |L12.22|
;;;122    	{
;;;123    		if (i2c_CheckDevice(GT811_I2C_ADDR) == 0)
000016  20ba              MOVS     r0,#0xba
000018  f7fffffe          BL       i2c_CheckDevice
00001c  b910              CBNZ     r0,|L12.36|
;;;124    		{
;;;125    			GT811_InitHard();
00001e  f7fffffe          BL       GT811_InitHard
                  |L12.34|
;;;126    			return;		/* 2015-04-21 break 修改为 return */
;;;127    		}
;;;128    
;;;129    		/* FT系列电容触摸触摸 : 4.3寸id = 0x55    5.0寸id = 0x0A  7.0寸id = 0x06 */
;;;130    		if (i2c_CheckDevice(FT5X06_I2C_ADDR) == 0)
;;;131    		{
;;;132    			uint8_t id;
;;;133    			
;;;134    			/*
;;;135    			系统上电后要先做一段时间的延迟，因为FT系列电容触摸芯片上电后可以直接检查出芯片，但是读
;;;136    			取的ID号是不对，需要延迟一段时间后再读取才是正确的。
;;;137    			*/
;;;138    			bsp_DelayMS(100);
;;;139    				
;;;140    			id = FT5X06_ReadID();
;;;141    			
;;;142    			if (id == 0x55)
;;;143    			{
;;;144    				//g_TouchType = CT_FT5X06;
;;;145    				//g_LcdType = LCD_43_480X272;		
;;;146    				//touch_printf("检测到4.3寸电容触摸屏\r\n");
;;;147    			}
;;;148    			else if (id == 0x0A)
;;;149    			{
;;;150    				//g_TouchType = CT_FT5X06;
;;;151    				//g_LcdType = LCD_50_800X480;		
;;;152    				//touch_printf("检测到5.0寸电容触摸屏\r\n");				
;;;153    			}
;;;154    			else	/* id == 0x06 表示7寸电容屏（FT芯片） */
;;;155    			{
;;;156    				//g_TouchType = CT_FT5X06;
;;;157    				//g_LcdType = LCD_70_800X480;		
;;;158    				//touch_printf("检测到7.0寸电容触摸屏\r\n");					
;;;159    			}
;;;160    			
;;;161    			FT5X06_InitHard();
;;;162    			return;
;;;163    		}
;;;164    		
;;;165    		bsp_DelayMS(10);
;;;166    	}
;;;167    		
;;;168    	if (g_ChipID == IC_8875)
;;;169    	{
;;;170    		RA8875_TouchInit();
;;;171    
;;;172    		g_tTP.usMaxAdc = 1023;	/* 10位ADC */
;;;173    	}
;;;174    	else
;;;175    	{	
;;;176    		TSC2046_InitHard();
;;;177    
;;;178    		g_tTP.usMaxAdc = 4095;	/* 12位ADC */
;;;179    	}
;;;180    
;;;181    	TOUCH_LoadParam();	/* 读取校准参数 */
;;;182    
;;;183    	g_tTP.Enable = 1;
;;;184    }
000022  bd70              POP      {r4-r6,pc}
                  |L12.36|
000024  2070              MOVS     r0,#0x70              ;130
000026  f7fffffe          BL       i2c_CheckDevice
00002a  b958              CBNZ     r0,|L12.68|
00002c  2064              MOVS     r0,#0x64              ;138
00002e  f7fffffe          BL       bsp_DelayMS
000032  f7fffffe          BL       FT5X06_ReadID
000036  4605              MOV      r5,r0                 ;140
000038  2d55              CMP      r5,#0x55              ;142
00003a  d000              BEQ      |L12.62|
00003c  bf00              NOP                            ;148
                  |L12.62|
00003e  f7fffffe          BL       FT5X06_InitHard
000042  e7ee              B        |L12.34|
                  |L12.68|
000044  200a              MOVS     r0,#0xa               ;165
000046  f7fffffe          BL       bsp_DelayMS
00004a  1c60              ADDS     r0,r4,#1              ;121
00004c  b284              UXTH     r4,r0                 ;121
                  |L12.78|
00004e  2c05              CMP      r4,#5                 ;121
000050  dbe1              BLT      |L12.22|
000052  480d              LDR      r0,|L12.136|
000054  8800              LDRH     r0,[r0,#0]            ;168  ; g_ChipID
000056  2875              CMP      r0,#0x75              ;168
000058  d106              BNE      |L12.104|
00005a  f7fffffe          BL       RA8875_TouchInit
00005e  f24030ff          MOV      r0,#0x3ff             ;172
000062  4908              LDR      r1,|L12.132|
000064  8448              STRH     r0,[r1,#0x22]         ;172
000066  e005              B        |L12.116|
                  |L12.104|
000068  f7fffffe          BL       TSC2046_InitHard
00006c  f64070ff          MOV      r0,#0xfff             ;178
000070  4904              LDR      r1,|L12.132|
000072  8448              STRH     r0,[r1,#0x22]         ;178
                  |L12.116|
000074  f7fffffe          BL       TOUCH_LoadParam
000078  2001              MOVS     r0,#1                 ;183
00007a  4902              LDR      r1,|L12.132|
00007c  f8810028          STRB     r0,[r1,#0x28]         ;183
000080  bf00              NOP      
000082  e7ce              B        |L12.34|
;;;185    
                          ENDP

                  |L12.132|
                          DCD      g_tTP
                  |L12.136|
                          DCD      g_ChipID

                          AREA ||i.TOUCH_LoadParam||, CODE, READONLY, ALIGN=2

                  TOUCH_LoadParam PROC
;;;1190   extern void LoadParam(void);
;;;1191   static void TOUCH_LoadParam(void)
000000  b510              PUSH     {r4,lr}
;;;1192   {
;;;1193   #if 1
;;;1194   	LoadParam();	/* 从Flash中读取参数 */
000002  f7fffffe          BL       LoadParam
;;;1195   
;;;1196   	g_tTP.usAdcX1 = g_tParam.usAdcX1;
000006  481a              LDR      r0,|L13.112|
000008  8900              LDRH     r0,[r0,#8]  ; g_tParam
00000a  491a              LDR      r1,|L13.116|
00000c  8008              STRH     r0,[r1,#0]
;;;1197   	g_tTP.usAdcY1 = g_tParam.usAdcY1;
00000e  4818              LDR      r0,|L13.112|
000010  8940              LDRH     r0,[r0,#0xa]  ; g_tParam
000012  8048              STRH     r0,[r1,#2]
;;;1198   	g_tTP.usAdcX2 = g_tParam.usAdcX2;
000014  4816              LDR      r0,|L13.112|
000016  8980              LDRH     r0,[r0,#0xc]  ; g_tParam
000018  8088              STRH     r0,[r1,#4]
;;;1199   	g_tTP.usAdcY2 = g_tParam.usAdcY2;
00001a  4815              LDR      r0,|L13.112|
00001c  89c0              LDRH     r0,[r0,#0xe]  ; g_tParam
00001e  80c8              STRH     r0,[r1,#6]
;;;1200   	g_tTP.usAdcX3 = g_tParam.usAdcX3;
000020  4813              LDR      r0,|L13.112|
000022  8a00              LDRH     r0,[r0,#0x10]  ; g_tParam
000024  8108              STRH     r0,[r1,#8]
;;;1201   	g_tTP.usAdcY3 = g_tParam.usAdcY3;
000026  4812              LDR      r0,|L13.112|
000028  8a40              LDRH     r0,[r0,#0x12]  ; g_tParam
00002a  8148              STRH     r0,[r1,#0xa]
;;;1202   	g_tTP.usAdcX4 = g_tParam.usAdcX4;
00002c  4810              LDR      r0,|L13.112|
00002e  8a80              LDRH     r0,[r0,#0x14]  ; g_tParam
000030  8188              STRH     r0,[r1,#0xc]
;;;1203   	g_tTP.usAdcY4 = g_tParam.usAdcY4;
000032  480f              LDR      r0,|L13.112|
000034  8ac0              LDRH     r0,[r0,#0x16]  ; g_tParam
000036  81c8              STRH     r0,[r1,#0xe]
;;;1204   
;;;1205   	g_tTP.usLcdX1 = g_tParam.usLcdX1;
000038  480d              LDR      r0,|L13.112|
00003a  8b00              LDRH     r0,[r0,#0x18]  ; g_tParam
00003c  8208              STRH     r0,[r1,#0x10]
;;;1206   	g_tTP.usLcdY1 = g_tParam.usLcdY1;
00003e  480c              LDR      r0,|L13.112|
000040  8b40              LDRH     r0,[r0,#0x1a]  ; g_tParam
000042  8248              STRH     r0,[r1,#0x12]
;;;1207   	g_tTP.usLcdX2 = g_tParam.usLcdX2;
000044  480a              LDR      r0,|L13.112|
000046  8b80              LDRH     r0,[r0,#0x1c]  ; g_tParam
000048  8288              STRH     r0,[r1,#0x14]
;;;1208   	g_tTP.usLcdY2 = g_tParam.usLcdY2;
00004a  4809              LDR      r0,|L13.112|
00004c  8bc0              LDRH     r0,[r0,#0x1e]  ; g_tParam
00004e  82c8              STRH     r0,[r1,#0x16]
;;;1209   	g_tTP.usLcdX3 = g_tParam.usLcdX3;
000050  4807              LDR      r0,|L13.112|
000052  8c00              LDRH     r0,[r0,#0x20]  ; g_tParam
000054  8308              STRH     r0,[r1,#0x18]
;;;1210   	g_tTP.usLcdY3 = g_tParam.usLcdY3;
000056  4806              LDR      r0,|L13.112|
000058  8c40              LDRH     r0,[r0,#0x22]  ; g_tParam
00005a  8348              STRH     r0,[r1,#0x1a]
;;;1211   	g_tTP.usLcdX4 = g_tParam.usLcdX4;
00005c  4804              LDR      r0,|L13.112|
00005e  8c80              LDRH     r0,[r0,#0x24]  ; g_tParam
000060  8388              STRH     r0,[r1,#0x1c]
;;;1212   	g_tTP.usLcdY4 = g_tParam.usLcdY4;
000062  4803              LDR      r0,|L13.112|
000064  8cc0              LDRH     r0,[r0,#0x26]  ; g_tParam
000066  83c8              STRH     r0,[r1,#0x1e]
;;;1213   
;;;1214   	g_tTP.XYChange = g_tParam.XYChange;
000068  4801              LDR      r0,|L13.112|
00006a  7980              LDRB     r0,[r0,#6]  ; g_tParam
00006c  8408              STRH     r0,[r1,#0x20]
;;;1215   #endif
;;;1216   }
00006e  bd10              POP      {r4,pc}
;;;1217   
                          ENDP

                  |L13.112|
                          DCD      g_tParam
                  |L13.116|
                          DCD      g_tTP

                          AREA ||i.TOUCH_MoveValid||, CODE, READONLY, ALIGN=2

                  TOUCH_MoveValid PROC
;;;449    */
;;;450    uint8_t TOUCH_MoveValid(uint16_t _usX1, uint16_t _usY1, uint16_t _usX2, uint16_t _usY2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;451    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;452    	int16_t iX, iY;
;;;453    	static uint8_t s_invalid_count = 0;
;;;454    
;;;455    	iX = TOUCH_Abs(_usX1 - _usX2);
000006  1aa0              SUBS     r0,r4,r2
000008  f7fffffe          BL       TOUCH_Abs
00000c  b206              SXTH     r6,r0
;;;456    	iY = TOUCH_Abs(_usY1 - _usY2);
00000e  1ae8              SUBS     r0,r5,r3
000010  f7fffffe          BL       TOUCH_Abs
000014  b207              SXTH     r7,r0
;;;457    
;;;458    	if ((iX < 25) && (iY < 25))
000016  2e19              CMP      r6,#0x19
000018  da06              BGE      |L14.40|
00001a  2f19              CMP      r7,#0x19
00001c  da04              BGE      |L14.40|
;;;459    	{
;;;460    		s_invalid_count = 0;
00001e  2000              MOVS     r0,#0
000020  4908              LDR      r1,|L14.68|
000022  7008              STRB     r0,[r1,#0]
;;;461    		return 1;
000024  2001              MOVS     r0,#1
                  |L14.38|
;;;462    	}
;;;463    	else
;;;464    	{
;;;465    		if (++s_invalid_count >= 3)
;;;466    		{
;;;467    			s_invalid_count = 0;
;;;468    			return 1;
;;;469    		}
;;;470    		return 0;
;;;471    	}
;;;472    }
000026  bdf0              POP      {r4-r7,pc}
                  |L14.40|
000028  4806              LDR      r0,|L14.68|
00002a  7800              LDRB     r0,[r0,#0]            ;465  ; s_invalid_count
00002c  1c40              ADDS     r0,r0,#1              ;465
00002e  b2c0              UXTB     r0,r0                 ;465
000030  4904              LDR      r1,|L14.68|
000032  7008              STRB     r0,[r1,#0]            ;465
000034  2803              CMP      r0,#3                 ;465
000036  db03              BLT      |L14.64|
000038  2000              MOVS     r0,#0                 ;467
00003a  7008              STRB     r0,[r1,#0]            ;467
00003c  2001              MOVS     r0,#1                 ;468
00003e  e7f2              B        |L14.38|
                  |L14.64|
000040  2000              MOVS     r0,#0                 ;470
000042  e7f0              B        |L14.38|
;;;473    
                          ENDP

                  |L14.68|
                          DCD      s_invalid_count

                          AREA ||i.TOUCH_PressValid||, CODE, READONLY, ALIGN=2

                  TOUCH_PressValid PROC
;;;978    */
;;;979    static uint8_t	TOUCH_PressValid(uint16_t _usX, uint16_t _usY)
000000  4602              MOV      r2,r0
;;;980    {
;;;981    	if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
000002  2a02              CMP      r2,#2
000004  dd0b              BLE      |L15.30|
000006  2902              CMP      r1,#2
000008  dd09              BLE      |L15.30|
;;;982    		|| (_usX >= g_tTP.usMaxAdc - ADC_VALID_OFFSET)
00000a  4807              LDR      r0,|L15.40|
00000c  8c40              LDRH     r0,[r0,#0x22]  ; g_tTP
00000e  1e80              SUBS     r0,r0,#2
000010  4290              CMP      r0,r2
000012  dd04              BLE      |L15.30|
;;;983    		|| (_usY >= g_tTP.usMaxAdc - ADC_VALID_OFFSET))
000014  4804              LDR      r0,|L15.40|
000016  8c40              LDRH     r0,[r0,#0x22]  ; g_tTP
000018  1e80              SUBS     r0,r0,#2
00001a  4288              CMP      r0,r1
00001c  dc01              BGT      |L15.34|
                  |L15.30|
;;;984    	{
;;;985    		return 0;
00001e  2000              MOVS     r0,#0
                  |L15.32|
;;;986    	}
;;;987    	else
;;;988    	{
;;;989    		return 1;
;;;990    	}
;;;991    }
000020  4770              BX       lr
                  |L15.34|
000022  2001              MOVS     r0,#1                 ;989
000024  e7fc              B        |L15.32|
;;;992    
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      g_tTP

                          AREA ||i.TOUCH_PutKey||, CODE, READONLY, ALIGN=2

                  TOUCH_PutKey PROC
;;;231    */
;;;232    void TOUCH_PutKey(uint8_t _ucEvent, uint16_t _usX, uint16_t _usY)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;233    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;234    	uint16_t xx, yy;
;;;235    	uint16_t x = 0, y = 0;
00000a  f04f0900          MOV      r9,#0
00000e  46ca              MOV      r10,r9
;;;236    
;;;237    	g_tTP.Event[g_tTP.Write] = _ucEvent;
000010  4887              LDR      r0,|L16.560|
000012  f890108f          LDRB     r1,[r0,#0x8f]  ; g_tTP
000016  3029              ADDS     r0,r0,#0x29
000018  f8008001          STRB     r8,[r0,r1]
;;;238    
;;;239    	if (g_GT811.Enable == 1)	/* 电容屏 (无需校准) */
00001c  4885              LDR      r0,|L16.564|
00001e  7800              LDRB     r0,[r0,#0]  ; g_GT811
000020  2801              CMP      r0,#1
000022  d102              BNE      |L16.42|
;;;240    	{
;;;241    		xx = _usX;
000024  4634              MOV      r4,r6
;;;242    		yy = _usY;
000026  463d              MOV      r5,r7
000028  e010              B        |L16.76|
                  |L16.42|
;;;243    	}
;;;244    	else if (g_tFT5X06.Enable == 1)
00002a  4883              LDR      r0,|L16.568|
00002c  7840              LDRB     r0,[r0,#1]  ; g_tFT5X06
00002e  2801              CMP      r0,#1
000030  d102              BNE      |L16.56|
;;;245    	{
;;;246    		xx = _usX;
000032  4634              MOV      r4,r6
;;;247    		yy = _usY;
000034  463d              MOV      r5,r7
000036  e009              B        |L16.76|
                  |L16.56|
;;;248    	}	
;;;249    	else	/* 电阻屏 */
;;;250    	{
;;;251    		xx = TOUCH_TransX(_usX, _usY);
000038  4639              MOV      r1,r7
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       TOUCH_TransX
000040  b284              UXTH     r4,r0
;;;252    		yy = TOUCH_TransY(_usX, _usY);
000042  4639              MOV      r1,r7
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       TOUCH_TransY
00004a  b285              UXTH     r5,r0
                  |L16.76|
;;;253    	}
;;;254    	
;;;255    	/* 横屏和竖屏方向识别 */
;;;256    	if (g_tParam.TouchDirection > 3)
00004c  487b              LDR      r0,|L16.572|
00004e  7940              LDRB     r0,[r0,#5]  ; g_tParam
000050  2803              CMP      r0,#3
000052  dd02              BLE      |L16.90|
;;;257    	{
;;;258    		g_tParam.TouchDirection  = 0;
000054  2000              MOVS     r0,#0
000056  4979              LDR      r1,|L16.572|
000058  7148              STRB     r0,[r1,#5]
                  |L16.90|
;;;259    	}
;;;260    	switch (g_tParam.TouchDirection)
00005a  4878              LDR      r0,|L16.572|
00005c  7940              LDRB     r0,[r0,#5]  ; g_tParam
00005e  b130              CBZ      r0,|L16.110|
000060  2801              CMP      r0,#1
000062  d033              BEQ      |L16.204|
000064  2802              CMP      r0,#2
000066  d060              BEQ      |L16.298|
000068  2803              CMP      r0,#3
00006a  d175              BNE      |L16.344|
00006c  e08d              B        |L16.394|
                  |L16.110|
;;;261    	{
;;;262    		case 0:	/* 校准触摸时，屏幕方向为0 */
;;;263    			if (g_LcdDirection == 0)		/* 横屏 */
00006e  4874              LDR      r0,|L16.576|
000070  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000072  b910              CBNZ     r0,|L16.122|
;;;264    			{
;;;265    				x = xx;
000074  46a1              MOV      r9,r4
;;;266    				y = yy;
000076  46aa              MOV      r10,r5
000078  e027              B        |L16.202|
                  |L16.122|
;;;267    			}
;;;268    			else if (g_LcdDirection == 1)	/* 横屏180°*/
00007a  4871              LDR      r0,|L16.576|
00007c  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00007e  2801              CMP      r0,#1
000080  d10c              BNE      |L16.156|
;;;269    			{
;;;270    				x = g_LcdWidth - xx - 1;
000082  4870              LDR      r0,|L16.580|
000084  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000086  1b00              SUBS     r0,r0,r4
000088  1e40              SUBS     r0,r0,#1
00008a  fa1ff980          UXTH     r9,r0
;;;271    				y = g_LcdHeight - yy - 1;
00008e  486e              LDR      r0,|L16.584|
000090  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000092  1b40              SUBS     r0,r0,r5
000094  1e40              SUBS     r0,r0,#1
000096  fa1ffa80          UXTH     r10,r0
00009a  e016              B        |L16.202|
                  |L16.156|
;;;272    			}
;;;273    			else if (g_LcdDirection == 2)	/* 竖屏 */
00009c  4868              LDR      r0,|L16.576|
00009e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000a0  2802              CMP      r0,#2
0000a2  d107              BNE      |L16.180|
;;;274    			{
;;;275    				y = xx;
0000a4  46a2              MOV      r10,r4
;;;276    				x = g_LcdWidth - yy - 1;
0000a6  4867              LDR      r0,|L16.580|
0000a8  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
0000aa  1b40              SUBS     r0,r0,r5
0000ac  1e40              SUBS     r0,r0,#1
0000ae  fa1ff980          UXTH     r9,r0
0000b2  e00a              B        |L16.202|
                  |L16.180|
;;;277    			}
;;;278    			else if (g_LcdDirection == 3)	/* 竖屏180° */
0000b4  4862              LDR      r0,|L16.576|
0000b6  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000b8  2803              CMP      r0,#3
0000ba  d106              BNE      |L16.202|
;;;279    			{
;;;280    				y = g_LcdHeight - xx - 1;
0000bc  4862              LDR      r0,|L16.584|
0000be  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0000c0  1b00              SUBS     r0,r0,r4
0000c2  1e40              SUBS     r0,r0,#1
0000c4  fa1ffa80          UXTH     r10,r0
;;;281    				x = yy;
0000c8  46a9              MOV      r9,r5
                  |L16.202|
;;;282    			}
;;;283    			break;
0000ca  e091              B        |L16.496|
                  |L16.204|
;;;284    
;;;285    		case 1:	/* 校准触摸时，屏幕方向为1 */
;;;286    			if (g_LcdDirection == 0)		/* 横屏 */
0000cc  485c              LDR      r0,|L16.576|
0000ce  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000d0  b960              CBNZ     r0,|L16.236|
;;;287    			{
;;;288    				x = g_LcdWidth - xx - 1;
0000d2  485c              LDR      r0,|L16.580|
0000d4  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
0000d6  1b00              SUBS     r0,r0,r4
0000d8  1e40              SUBS     r0,r0,#1
0000da  fa1ff980          UXTH     r9,r0
;;;289    				y = g_LcdHeight - yy - 1;
0000de  485a              LDR      r0,|L16.584|
0000e0  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0000e2  1b40              SUBS     r0,r0,r5
0000e4  1e40              SUBS     r0,r0,#1
0000e6  fa1ffa80          UXTH     r10,r0
0000ea  e01d              B        |L16.296|
                  |L16.236|
;;;290    			}
;;;291    			else if (g_LcdDirection == 1)	/* 横屏180°*/
0000ec  4854              LDR      r0,|L16.576|
0000ee  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000f0  2801              CMP      r0,#1
0000f2  d102              BNE      |L16.250|
;;;292    			{
;;;293    				x = xx;
0000f4  46a1              MOV      r9,r4
;;;294    				y = yy;
0000f6  46aa              MOV      r10,r5
0000f8  e016              B        |L16.296|
                  |L16.250|
;;;295    			}
;;;296    			else if (g_LcdDirection == 2)	/* 竖屏 */
0000fa  4851              LDR      r0,|L16.576|
0000fc  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000fe  2802              CMP      r0,#2
000100  d107              BNE      |L16.274|
;;;297    			{
;;;298    				y = g_LcdHeight - xx - 1;
000102  4851              LDR      r0,|L16.584|
000104  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000106  1b00              SUBS     r0,r0,r4
000108  1e40              SUBS     r0,r0,#1
00010a  fa1ffa80          UXTH     r10,r0
;;;299    				x = yy;
00010e  46a9              MOV      r9,r5
000110  e00a              B        |L16.296|
                  |L16.274|
;;;300    			}
;;;301    			else if (g_LcdDirection == 3)	/* 竖屏180° */
000112  484b              LDR      r0,|L16.576|
000114  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000116  2803              CMP      r0,#3
000118  d106              BNE      |L16.296|
;;;302    			{
;;;303    				y = xx;
00011a  46a2              MOV      r10,r4
;;;304    				x = g_LcdWidth - yy - 1;
00011c  4849              LDR      r0,|L16.580|
00011e  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000120  1b40              SUBS     r0,r0,r5
000122  1e40              SUBS     r0,r0,#1
000124  fa1ff980          UXTH     r9,r0
                  |L16.296|
;;;305    			}
;;;306    			break;
000128  e062              B        |L16.496|
                  |L16.298|
;;;307    
;;;308    		case 2:	/* 校准触摸时，屏幕方向为2 */
;;;309    			if (g_LcdDirection == 0)		/* 横屏 */
00012a  4845              LDR      r0,|L16.576|
00012c  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00012e  b938              CBNZ     r0,|L16.320|
;;;310    			{
;;;311    				y = xx;
000130  46a2              MOV      r10,r4
;;;312    				x = g_LcdWidth - yy - 1;
000132  4844              LDR      r0,|L16.580|
000134  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000136  1b40              SUBS     r0,r0,r5
000138  1e40              SUBS     r0,r0,#1
00013a  fa1ff980          UXTH     r9,r0
00013e  e023              B        |L16.392|
                  |L16.320|
;;;313    			}
;;;314    			else if (g_LcdDirection == 1)	/* 横屏180°*/
000140  483f              LDR      r0,|L16.576|
000142  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000144  2801              CMP      r0,#1
000146  d108              BNE      |L16.346|
;;;315    			{
;;;316    				y = g_LcdHeight - xx - 1;
000148  483f              LDR      r0,|L16.584|
00014a  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
00014c  1b00              SUBS     r0,r0,r4
00014e  1e40              SUBS     r0,r0,#1
000150  fa1ffa80          UXTH     r10,r0
;;;317    				x = yy;
000154  46a9              MOV      r9,r5
000156  e017              B        |L16.392|
                  |L16.344|
000158  e046              B        |L16.488|
                  |L16.346|
;;;318    			}
;;;319    			else if (g_LcdDirection == 2)	/* 竖屏 */
00015a  4839              LDR      r0,|L16.576|
00015c  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00015e  2802              CMP      r0,#2
000160  d102              BNE      |L16.360|
;;;320    			{
;;;321    				x = xx;
000162  46a1              MOV      r9,r4
;;;322    				y = yy;
000164  46aa              MOV      r10,r5
000166  e00f              B        |L16.392|
                  |L16.360|
;;;323    			}
;;;324    			else if (g_LcdDirection == 3)	/* 竖屏180° */
000168  4835              LDR      r0,|L16.576|
00016a  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00016c  2803              CMP      r0,#3
00016e  d10b              BNE      |L16.392|
;;;325    			{
;;;326    				x = g_LcdWidth - xx - 1;
000170  4834              LDR      r0,|L16.580|
000172  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000174  1b00              SUBS     r0,r0,r4
000176  1e40              SUBS     r0,r0,#1
000178  fa1ff980          UXTH     r9,r0
;;;327    				y = g_LcdHeight - yy - 1;
00017c  4832              LDR      r0,|L16.584|
00017e  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000180  1b40              SUBS     r0,r0,r5
000182  1e40              SUBS     r0,r0,#1
000184  fa1ffa80          UXTH     r10,r0
                  |L16.392|
;;;328    			}
;;;329    			break;
000188  e032              B        |L16.496|
                  |L16.394|
;;;330    
;;;331    		case 3:	/* 校准触摸时，屏幕方向为3 */
;;;332    			if (g_LcdDirection == 0)		/* 横屏 */
00018a  482d              LDR      r0,|L16.576|
00018c  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00018e  b938              CBNZ     r0,|L16.416|
;;;333    			{
;;;334    				y = xx;
000190  46a2              MOV      r10,r4
;;;335    				x = g_LcdWidth - yy - 1;
000192  482c              LDR      r0,|L16.580|
000194  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000196  1b40              SUBS     r0,r0,r5
000198  1e40              SUBS     r0,r0,#1
00019a  fa1ff980          UXTH     r9,r0
00019e  e022              B        |L16.486|
                  |L16.416|
;;;336    			}
;;;337    			else if (g_LcdDirection == 1)	/* 横屏180°*/
0001a0  4827              LDR      r0,|L16.576|
0001a2  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0001a4  2801              CMP      r0,#1
0001a6  d107              BNE      |L16.440|
;;;338    			{
;;;339    				y = g_LcdHeight - xx - 1;
0001a8  4827              LDR      r0,|L16.584|
0001aa  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0001ac  1b00              SUBS     r0,r0,r4
0001ae  1e40              SUBS     r0,r0,#1
0001b0  fa1ffa80          UXTH     r10,r0
;;;340    				x = yy;
0001b4  46a9              MOV      r9,r5
0001b6  e016              B        |L16.486|
                  |L16.440|
;;;341    			}
;;;342    			else if (g_LcdDirection == 2)	/* 竖屏 */
0001b8  4821              LDR      r0,|L16.576|
0001ba  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0001bc  2802              CMP      r0,#2
0001be  d10c              BNE      |L16.474|
;;;343    			{
;;;344    				x = g_LcdWidth - xx - 1;
0001c0  4820              LDR      r0,|L16.580|
0001c2  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
0001c4  1b00              SUBS     r0,r0,r4
0001c6  1e40              SUBS     r0,r0,#1
0001c8  fa1ff980          UXTH     r9,r0
;;;345    				y = g_LcdHeight - yy - 1;
0001cc  481e              LDR      r0,|L16.584|
0001ce  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0001d0  1b40              SUBS     r0,r0,r5
0001d2  1e40              SUBS     r0,r0,#1
0001d4  fa1ffa80          UXTH     r10,r0
0001d8  e005              B        |L16.486|
                  |L16.474|
;;;346    			}
;;;347    			else if (g_LcdDirection == 3)	/* 竖屏180° */
0001da  4819              LDR      r0,|L16.576|
0001dc  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0001de  2803              CMP      r0,#3
0001e0  d101              BNE      |L16.486|
;;;348    			{
;;;349    				x = xx;
0001e2  46a1              MOV      r9,r4
;;;350    				y = yy;
0001e4  46aa              MOV      r10,r5
                  |L16.486|
;;;351    			}
;;;352    			break;
0001e6  e003              B        |L16.496|
                  |L16.488|
;;;353    
;;;354    		default:
;;;355    			g_tParam.TouchDirection = 0;	/* 方向参数无效时，纠正为缺省的横屏 */
0001e8  2000              MOVS     r0,#0
0001ea  4914              LDR      r1,|L16.572|
0001ec  7148              STRB     r0,[r1,#5]
;;;356    			break;
0001ee  bf00              NOP      
                  |L16.496|
0001f0  bf00              NOP                            ;283
;;;357    	}
;;;358    
;;;359    	g_tTP.XBuf[g_tTP.Write] = x;
0001f2  fa0ff189          SXTH     r1,r9
0001f6  480e              LDR      r0,|L16.560|
0001f8  f890208f          LDRB     r2,[r0,#0x8f]  ; g_tTP
0001fc  303e              ADDS     r0,r0,#0x3e
0001fe  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;360    	g_tTP.YBuf[g_tTP.Write] = y;
000202  fa0ff18a          SXTH     r1,r10
000206  383e              SUBS     r0,r0,#0x3e
000208  f890208f          LDRB     r2,[r0,#0x8f]  ; g_tTP
00020c  3066              ADDS     r0,r0,#0x66
00020e  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;361    
;;;362    	if (++g_tTP.Write  >= TOUCH_FIFO_SIZE)
000212  3866              SUBS     r0,r0,#0x66
000214  f890008f          LDRB     r0,[r0,#0x8f]  ; g_tTP
000218  1c40              ADDS     r0,r0,#1
00021a  b2c0              UXTB     r0,r0
00021c  4904              LDR      r1,|L16.560|
00021e  f881008f          STRB     r0,[r1,#0x8f]
000222  2814              CMP      r0,#0x14
000224  db02              BLT      |L16.556|
;;;363    	{
;;;364    		g_tTP.Write = 0;
000226  2000              MOVS     r0,#0
000228  f881008f          STRB     r0,[r1,#0x8f]
                  |L16.556|
;;;365    	}
;;;366    }
00022c  e8bd87f0          POP      {r4-r10,pc}
;;;367    
                          ENDP

                  |L16.560|
                          DCD      g_tTP
                  |L16.564|
                          DCD      g_GT811
                  |L16.568|
                          DCD      g_tFT5X06
                  |L16.572|
                          DCD      g_tParam
                  |L16.576|
                          DCD      g_LcdDirection
                  |L16.580|
                          DCD      g_LcdWidth
                  |L16.584|
                          DCD      g_LcdHeight

                          AREA ||i.TOUCH_ReadAdcX||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcX PROC
;;;193    */
;;;194    uint16_t TOUCH_ReadAdcX(void)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196    	uint16_t usAdc;
;;;197    
;;;198    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;199    	usAdc = g_tTP.usAdcNowX;
000008  4803              LDR      r0,|L17.24|
00000a  8c84              LDRH     r4,[r0,#0x24]  ; g_tTP
;;;200    	__set_PRIMASK(0);  		/* 开中断 */
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       __set_PRIMASK
;;;201    
;;;202    	return usAdc;
000012  4620              MOV      r0,r4
;;;203    }
000014  bd10              POP      {r4,pc}
;;;204    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      g_tTP

                          AREA ||i.TOUCH_ReadAdcY||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcY PROC
;;;212    */
;;;213    uint16_t TOUCH_ReadAdcY(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
;;;215    	uint16_t usAdc;
;;;216    
;;;217    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;218    	usAdc = g_tTP.usAdcNowY;
000008  4803              LDR      r0,|L18.24|
00000a  8cc4              LDRH     r4,[r0,#0x26]  ; g_tTP
;;;219    	__set_PRIMASK(0);  		/* 开中断 */
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       __set_PRIMASK
;;;220    
;;;221    	return usAdc;
000012  4620              MOV      r0,r4
;;;222    }
000014  bd10              POP      {r4,pc}
;;;223    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      g_tTP

                          AREA ||i.TOUCH_SaveParam||, CODE, READONLY, ALIGN=2

                  TOUCH_SaveParam PROC
;;;1152   extern void SaveParam(void);
;;;1153   static void TOUCH_SaveParam(void)
000000  b510              PUSH     {r4,lr}
;;;1154   {
;;;1155   #if 1
;;;1156   	g_tParam.usAdcX1 = g_tTP.usAdcX1;
000002  481d              LDR      r0,|L19.120|
000004  8800              LDRH     r0,[r0,#0]  ; g_tTP
000006  491d              LDR      r1,|L19.124|
000008  8108              STRH     r0,[r1,#8]
;;;1157   	g_tParam.usAdcY1 = g_tTP.usAdcY1;
00000a  481b              LDR      r0,|L19.120|
00000c  8840              LDRH     r0,[r0,#2]  ; g_tTP
00000e  8148              STRH     r0,[r1,#0xa]
;;;1158   	g_tParam.usAdcX2 = g_tTP.usAdcX2;
000010  4819              LDR      r0,|L19.120|
000012  8880              LDRH     r0,[r0,#4]  ; g_tTP
000014  8188              STRH     r0,[r1,#0xc]
;;;1159   	g_tParam.usAdcY2 = g_tTP.usAdcY2;
000016  4818              LDR      r0,|L19.120|
000018  88c0              LDRH     r0,[r0,#6]  ; g_tTP
00001a  81c8              STRH     r0,[r1,#0xe]
;;;1160   	g_tParam.usAdcX3 = g_tTP.usAdcX3;
00001c  4816              LDR      r0,|L19.120|
00001e  8900              LDRH     r0,[r0,#8]  ; g_tTP
000020  8208              STRH     r0,[r1,#0x10]
;;;1161   	g_tParam.usAdcY3 = g_tTP.usAdcY3;
000022  4815              LDR      r0,|L19.120|
000024  8940              LDRH     r0,[r0,#0xa]  ; g_tTP
000026  8248              STRH     r0,[r1,#0x12]
;;;1162   	g_tParam.usAdcX4 = g_tTP.usAdcX4;
000028  4813              LDR      r0,|L19.120|
00002a  8980              LDRH     r0,[r0,#0xc]  ; g_tTP
00002c  8288              STRH     r0,[r1,#0x14]
;;;1163   	g_tParam.usAdcY4 = g_tTP.usAdcY4;
00002e  4812              LDR      r0,|L19.120|
000030  89c0              LDRH     r0,[r0,#0xe]  ; g_tTP
000032  82c8              STRH     r0,[r1,#0x16]
;;;1164   
;;;1165   	g_tParam.usLcdX1 = g_tTP.usLcdX1;
000034  4810              LDR      r0,|L19.120|
000036  8a00              LDRH     r0,[r0,#0x10]  ; g_tTP
000038  8308              STRH     r0,[r1,#0x18]
;;;1166   	g_tParam.usLcdY1 = g_tTP.usLcdY1;
00003a  480f              LDR      r0,|L19.120|
00003c  8a40              LDRH     r0,[r0,#0x12]  ; g_tTP
00003e  8348              STRH     r0,[r1,#0x1a]
;;;1167   	g_tParam.usLcdX2 = g_tTP.usLcdX2;
000040  480d              LDR      r0,|L19.120|
000042  8a80              LDRH     r0,[r0,#0x14]  ; g_tTP
000044  8388              STRH     r0,[r1,#0x1c]
;;;1168   	g_tParam.usLcdY2 = g_tTP.usLcdY2;
000046  480c              LDR      r0,|L19.120|
000048  8ac0              LDRH     r0,[r0,#0x16]  ; g_tTP
00004a  83c8              STRH     r0,[r1,#0x1e]
;;;1169   	g_tParam.usLcdX3 = g_tTP.usLcdX3;
00004c  480a              LDR      r0,|L19.120|
00004e  8b00              LDRH     r0,[r0,#0x18]  ; g_tTP
000050  8408              STRH     r0,[r1,#0x20]
;;;1170   	g_tParam.usLcdY3 = g_tTP.usLcdY3;
000052  4809              LDR      r0,|L19.120|
000054  8b40              LDRH     r0,[r0,#0x1a]  ; g_tTP
000056  8448              STRH     r0,[r1,#0x22]
;;;1171   	g_tParam.usLcdX4 = g_tTP.usLcdX4;
000058  4807              LDR      r0,|L19.120|
00005a  8b80              LDRH     r0,[r0,#0x1c]  ; g_tTP
00005c  8488              STRH     r0,[r1,#0x24]
;;;1172   	g_tParam.usLcdY4 = g_tTP.usLcdY4;
00005e  4806              LDR      r0,|L19.120|
000060  8bc0              LDRH     r0,[r0,#0x1e]  ; g_tTP
000062  84c8              STRH     r0,[r1,#0x26]
;;;1173   
;;;1174   	g_tParam.XYChange = g_tTP.XYChange;
000064  4804              LDR      r0,|L19.120|
000066  f8900020          LDRB     r0,[r0,#0x20]  ; g_tTP
00006a  7188              STRB     r0,[r1,#6]
;;;1175   
;;;1176   	g_tParam.TouchDirection = g_LcdDirection;	/* 2014-09-11 添加屏幕方向, 用于屏幕旋转时无需再次校准 */
00006c  4804              LDR      r0,|L19.128|
00006e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000070  7148              STRB     r0,[r1,#5]
;;;1177   
;;;1178   	SaveParam();	/* 将参数写入Flash */
000072  f7fffffe          BL       SaveParam
;;;1179   #endif
;;;1180   }
000076  bd10              POP      {r4,pc}
;;;1181   
                          ENDP

                  |L19.120|
                          DCD      g_tTP
                  |L19.124|
                          DCD      g_tParam
                  |L19.128|
                          DCD      g_LcdDirection

                          AREA ||i.TOUCH_Scan||, CODE, READONLY, ALIGN=2

                  TOUCH_Scan PROC
;;;506    GUI_PID_STATE State;
;;;507    void TOUCH_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
;;;509    	uint16_t usAdcX;
;;;510    	uint16_t usAdcY;
;;;511    	static uint16_t s_usXBuf[SAMPLE_COUNT];
;;;512    	static uint16_t s_usYBuf[SAMPLE_COUNT];
;;;513    	static uint8_t s_ucPos = 0;
;;;514    	static uint8_t s_count = 0;
;;;515    	static uint8_t s_down = 0;
;;;516    	static uint16_t s_usSaveAdcX, s_usSaveAdcY; /* 用于触笔抬起事件，保存按下和移动的最后采样值 */
;;;517    
;;;518    	if (g_GT811.Enable == 1)
000002  4868              LDR      r0,|L20.420|
000004  7800              LDRB     r0,[r0,#0]  ; g_GT811
000006  2801              CMP      r0,#1
000008  d102              BNE      |L20.16|
;;;519    	{
;;;520    		GT811_Timer1ms();	/* 电容触摸屏程序计数器 */
00000a  f7fffffe          BL       GT811_Timer1ms
                  |L20.14|
;;;521    		return;
;;;522    	}
;;;523    	
;;;524    	if (g_tFT5X06.Enable == 1)
;;;525    	{
;;;526    		FT5X06_Timer1ms();	/* 电容触摸屏程序计数器 */
;;;527    		return;
;;;528    	}
;;;529    	
;;;530    	if (g_tTP.Enable == 0)
;;;531    	{
;;;532    		return;
;;;533    	}
;;;534    
;;;535    	/* 获得原始的ADC值，未滤波 */
;;;536    	if (g_ChipID == IC_8875)
;;;537    	{
;;;538    		/* 如果主程序正在访问RA8875,则丢弃本次触摸采集，避免影响显示 */
;;;539    		if (RA8875_IsBusy())
;;;540    		{
;;;541    			return;
;;;542    		}
;;;543    
;;;544    		usAdcX = RA8875_TouchReadX();
;;;545    		usAdcY = RA8875_TouchReadY();
;;;546    	}
;;;547    	else
;;;548    	{
;;;549    		if (TSC2046_PenInt())
;;;550    		{
;;;551    			/* 如果主程序正在访问其他SPI外设，则丢弃本次触摸采集 */
;;;552    			if (bsp_SpiBusBusy())
;;;553    			{
;;;554    				return;
;;;555    			}
;;;556    
;;;557    			usAdcX = TSC2046_ReadAdc(ADC_CH_X);
;;;558    			usAdcY = TSC2046_ReadAdc(ADC_CH_Y);
;;;559    		}
;;;560    		else
;;;561    		{
;;;562    			usAdcX = 0;
;;;563    			usAdcY = 0;
;;;564    		}
;;;565    	}
;;;566    
;;;567    	if (TOUCH_PressValid(usAdcX, usAdcY))
;;;568    	{
;;;569    		/* 按压30ms之后才开始采集数据 */
;;;570    		if (s_count >= DOWN_VALID)
;;;571    		{
;;;572    			s_usXBuf[s_ucPos] = usAdcX;
;;;573    			s_usYBuf[s_ucPos] = usAdcY;
;;;574    
;;;575    			/* 采集10ms数据进行滤波 */
;;;576    			if (++s_ucPos >= SAMPLE_COUNT)
;;;577    			{
;;;578    				s_ucPos = 0;
;;;579    				/* 对ADC采样值进行软件滤波 */
;;;580    				g_tTP.usAdcNowX = TOUCH_DataFilter(s_usXBuf, SAMPLE_COUNT);
;;;581    				g_tTP.usAdcNowY = TOUCH_DataFilter(s_usYBuf, SAMPLE_COUNT);
;;;582    
;;;583    				if (s_down == 0)
;;;584    				{
;;;585    					s_down = 1;
;;;586    
;;;587    					/* 触摸按下事件 */
;;;588    					State.x = TOUCH_TransX( g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;589    					State.y = TOUCH_TransY( g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;590    					State.Pressed = 1;
;;;591    					GUI_PID_StoreState(&State);
;;;592    
;;;593    					/* 用于触笔抬起事件，保存按下和移动的最后采样值 */
;;;594    					s_usSaveAdcX = g_tTP.usAdcNowX;
;;;595    					s_usSaveAdcY = g_tTP.usAdcNowY;
;;;596    
;;;597    				}
;;;598    				else
;;;599    				{
;;;600    					if (TOUCH_MoveValid(s_usSaveAdcX, s_usSaveAdcY, g_tTP.usAdcNowX, g_tTP.usAdcNowY))
;;;601    					{
;;;602    						/* 触摸移动事件 */
;;;603    						State.x = TOUCH_TransX( g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;604    						State.y = TOUCH_TransY( g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;605    						State.Pressed = 1;
;;;606    						GUI_PID_StoreState(&State);
;;;607    
;;;608    						/* 用于触笔抬起事件，保存按下和移动的最后采样值 */
;;;609    						s_usSaveAdcX = g_tTP.usAdcNowX;
;;;610    						s_usSaveAdcY = g_tTP.usAdcNowY;
;;;611    					}
;;;612    					else
;;;613    					{
;;;614    						g_tTP.usAdcNowX = 0; /* for debug stop */
;;;615    					}
;;;616    				}
;;;617    
;;;618    			}
;;;619    		}
;;;620    		else
;;;621    		{
;;;622    			s_count++;
;;;623    		}
;;;624    	}
;;;625    	else
;;;626    	{
;;;627    		if (s_count > 0)
;;;628    		{
;;;629    			if (--s_count == 0)
;;;630    			{
;;;631    				/* 触摸释放事件 */
;;;632    				/* State.x和State.y的数值无需更新，State是全局变量，保存的就是最近一次的数值 */
;;;633    				State.Pressed = 0;
;;;634    				GUI_PID_StoreState(&State);
;;;635    				s_count = 0;
;;;636    				s_down = 0;
;;;637    
;;;638    				g_tTP.usAdcNowX = 0;
;;;639    				g_tTP.usAdcNowY = 0;
;;;640    			}
;;;641    		}
;;;642    		s_ucPos = 0;
;;;643    	}
;;;644    }
00000e  bd70              POP      {r4-r6,pc}
                  |L20.16|
000010  4865              LDR      r0,|L20.424|
000012  7840              LDRB     r0,[r0,#1]            ;524  ; g_tFT5X06
000014  2801              CMP      r0,#1                 ;524
000016  d102              BNE      |L20.30|
000018  f7fffffe          BL       FT5X06_Timer1ms
00001c  e7f7              B        |L20.14|
                  |L20.30|
00001e  4863              LDR      r0,|L20.428|
000020  f8900028          LDRB     r0,[r0,#0x28]         ;530  ; g_tTP
000024  b900              CBNZ     r0,|L20.40|
000026  e7f2              B        |L20.14|
                  |L20.40|
000028  4861              LDR      r0,|L20.432|
00002a  8800              LDRH     r0,[r0,#0]            ;536  ; g_ChipID
00002c  2875              CMP      r0,#0x75              ;536
00002e  d10a              BNE      |L20.70|
000030  f7fffffe          BL       RA8875_IsBusy
000034  b100              CBZ      r0,|L20.56|
000036  e7ea              B        |L20.14|
                  |L20.56|
000038  f7fffffe          BL       RA8875_TouchReadX
00003c  4605              MOV      r5,r0                 ;544
00003e  f7fffffe          BL       RA8875_TouchReadY
000042  4604              MOV      r4,r0                 ;545
000044  e011              B        |L20.106|
                  |L20.70|
000046  f7fffffe          BL       TSC2046_PenInt
00004a  b160              CBZ      r0,|L20.102|
00004c  f7fffffe          BL       bsp_SpiBusBusy
000050  b100              CBZ      r0,|L20.84|
000052  e7dc              B        |L20.14|
                  |L20.84|
000054  2001              MOVS     r0,#1                 ;557
000056  f7fffffe          BL       TSC2046_ReadAdc
00005a  4605              MOV      r5,r0                 ;557
00005c  2005              MOVS     r0,#5                 ;558
00005e  f7fffffe          BL       TSC2046_ReadAdc
000062  4604              MOV      r4,r0                 ;558
000064  e001              B        |L20.106|
                  |L20.102|
000066  2500              MOVS     r5,#0                 ;562
000068  2400              MOVS     r4,#0                 ;563
                  |L20.106|
00006a  4621              MOV      r1,r4                 ;567
00006c  4628              MOV      r0,r5                 ;567
00006e  f7fffffe          BL       TOUCH_PressValid
000072  2800              CMP      r0,#0                 ;567
000074  d077              BEQ      |L20.358|
000076  484f              LDR      r0,|L20.436|
000078  7800              LDRB     r0,[r0,#0]            ;570  ; s_count
00007a  281e              CMP      r0,#0x1e              ;570
00007c  db6d              BLT      |L20.346|
00007e  484e              LDR      r0,|L20.440|
000080  494e              LDR      r1,|L20.444|
000082  7809              LDRB     r1,[r1,#0]            ;572  ; s_ucPos
000084  f8205011          STRH     r5,[r0,r1,LSL #1]     ;572
000088  484d              LDR      r0,|L20.448|
00008a  494c              LDR      r1,|L20.444|
00008c  7809              LDRB     r1,[r1,#0]            ;573  ; s_ucPos
00008e  f8204011          STRH     r4,[r0,r1,LSL #1]     ;573
000092  484a              LDR      r0,|L20.444|
000094  7800              LDRB     r0,[r0,#0]            ;576  ; s_ucPos
000096  1c40              ADDS     r0,r0,#1              ;576
000098  b2c0              UXTB     r0,r0                 ;576
00009a  4948              LDR      r1,|L20.444|
00009c  7008              STRB     r0,[r1,#0]            ;576
00009e  280a              CMP      r0,#0xa               ;576
0000a0  db7d              BLT      |L20.414|
0000a2  2000              MOVS     r0,#0                 ;578
0000a4  7008              STRB     r0,[r1,#0]            ;578
0000a6  210a              MOVS     r1,#0xa               ;580
0000a8  4843              LDR      r0,|L20.440|
0000aa  f7fffffe          BL       TOUCH_DataFilter
0000ae  493f              LDR      r1,|L20.428|
0000b0  8488              STRH     r0,[r1,#0x24]         ;580
0000b2  210a              MOVS     r1,#0xa               ;581
0000b4  4842              LDR      r0,|L20.448|
0000b6  f7fffffe          BL       TOUCH_DataFilter
0000ba  493c              LDR      r1,|L20.428|
0000bc  84c8              STRH     r0,[r1,#0x26]         ;581
0000be  4841              LDR      r0,|L20.452|
0000c0  7800              LDRB     r0,[r0,#0]            ;583  ; s_down
0000c2  b9f0              CBNZ     r0,|L20.258|
0000c4  2001              MOVS     r0,#1                 ;585
0000c6  493f              LDR      r1,|L20.452|
0000c8  7008              STRB     r0,[r1,#0]            ;585
0000ca  4a38              LDR      r2,|L20.428|
0000cc  8cd1              LDRH     r1,[r2,#0x26]         ;588  ; g_tTP
0000ce  8c90              LDRH     r0,[r2,#0x24]         ;588  ; g_tTP
0000d0  f7fffffe          BL       TOUCH_TransX
0000d4  493c              LDR      r1,|L20.456|
0000d6  6008              STR      r0,[r1,#0]            ;588  ; State
0000d8  4a34              LDR      r2,|L20.428|
0000da  8cd1              LDRH     r1,[r2,#0x26]         ;589  ; g_tTP
0000dc  8c90              LDRH     r0,[r2,#0x24]         ;589  ; g_tTP
0000de  f7fffffe          BL       TOUCH_TransY
0000e2  4939              LDR      r1,|L20.456|
0000e4  6048              STR      r0,[r1,#4]            ;589  ; State
0000e6  2001              MOVS     r0,#1                 ;590
0000e8  7208              STRB     r0,[r1,#8]            ;590
0000ea  4608              MOV      r0,r1                 ;591
0000ec  f7fffffe          BL       GUI_PID_StoreState
0000f0  482e              LDR      r0,|L20.428|
0000f2  8c80              LDRH     r0,[r0,#0x24]         ;594  ; g_tTP
0000f4  4935              LDR      r1,|L20.460|
0000f6  8008              STRH     r0,[r1,#0]            ;594
0000f8  482c              LDR      r0,|L20.428|
0000fa  8cc0              LDRH     r0,[r0,#0x26]         ;595  ; g_tTP
0000fc  4934              LDR      r1,|L20.464|
0000fe  8008              STRH     r0,[r1,#0]            ;595
000100  e04d              B        |L20.414|
                  |L20.258|
000102  482a              LDR      r0,|L20.428|
000104  8cc3              LDRH     r3,[r0,#0x26]         ;600  ; g_tTP
000106  8c82              LDRH     r2,[r0,#0x24]         ;600  ; g_tTP
000108  4831              LDR      r0,|L20.464|
00010a  8801              LDRH     r1,[r0,#0]            ;600  ; s_usSaveAdcY
00010c  482f              LDR      r0,|L20.460|
00010e  8800              LDRH     r0,[r0,#0]            ;600  ; s_usSaveAdcX
000110  f7fffffe          BL       TOUCH_MoveValid
000114  b1d8              CBZ      r0,|L20.334|
000116  4a25              LDR      r2,|L20.428|
000118  8cd1              LDRH     r1,[r2,#0x26]         ;603  ; g_tTP
00011a  8c90              LDRH     r0,[r2,#0x24]         ;603  ; g_tTP
00011c  f7fffffe          BL       TOUCH_TransX
000120  4929              LDR      r1,|L20.456|
000122  6008              STR      r0,[r1,#0]            ;603  ; State
000124  4a21              LDR      r2,|L20.428|
000126  8cd1              LDRH     r1,[r2,#0x26]         ;604  ; g_tTP
000128  8c90              LDRH     r0,[r2,#0x24]         ;604  ; g_tTP
00012a  f7fffffe          BL       TOUCH_TransY
00012e  4926              LDR      r1,|L20.456|
000130  6048              STR      r0,[r1,#4]            ;604  ; State
000132  2001              MOVS     r0,#1                 ;605
000134  7208              STRB     r0,[r1,#8]            ;605
000136  4608              MOV      r0,r1                 ;606
000138  f7fffffe          BL       GUI_PID_StoreState
00013c  481b              LDR      r0,|L20.428|
00013e  8c80              LDRH     r0,[r0,#0x24]         ;609  ; g_tTP
000140  4922              LDR      r1,|L20.460|
000142  8008              STRH     r0,[r1,#0]            ;609
000144  4819              LDR      r0,|L20.428|
000146  8cc0              LDRH     r0,[r0,#0x26]         ;610  ; g_tTP
000148  4921              LDR      r1,|L20.464|
00014a  8008              STRH     r0,[r1,#0]            ;610
00014c  e027              B        |L20.414|
                  |L20.334|
00014e  2000              MOVS     r0,#0                 ;614
000150  4916              LDR      r1,|L20.428|
000152  8488              STRH     r0,[r1,#0x24]         ;614
000154  e023              B        |L20.414|
000156  e006              B        |L20.358|
000158  e7ff              B        |L20.346|
                  |L20.346|
00015a  4816              LDR      r0,|L20.436|
00015c  7800              LDRB     r0,[r0,#0]            ;622  ; s_count
00015e  1c40              ADDS     r0,r0,#1              ;622
000160  4914              LDR      r1,|L20.436|
000162  7008              STRB     r0,[r1,#0]            ;622
000164  e01b              B        |L20.414|
                  |L20.358|
000166  4813              LDR      r0,|L20.436|
000168  7800              LDRB     r0,[r0,#0]            ;627  ; s_count
00016a  2800              CMP      r0,#0                 ;627
00016c  dd14              BLE      |L20.408|
00016e  4811              LDR      r0,|L20.436|
000170  7800              LDRB     r0,[r0,#0]            ;629  ; s_count
000172  1e40              SUBS     r0,r0,#1              ;629
000174  b2c0              UXTB     r0,r0                 ;629
000176  490f              LDR      r1,|L20.436|
000178  7008              STRB     r0,[r1,#0]            ;629
00017a  b968              CBNZ     r0,|L20.408|
00017c  2000              MOVS     r0,#0                 ;633
00017e  4912              LDR      r1,|L20.456|
000180  7208              STRB     r0,[r1,#8]            ;633
000182  4608              MOV      r0,r1                 ;634
000184  f7fffffe          BL       GUI_PID_StoreState
000188  2000              MOVS     r0,#0                 ;635
00018a  490a              LDR      r1,|L20.436|
00018c  7008              STRB     r0,[r1,#0]            ;635
00018e  490d              LDR      r1,|L20.452|
000190  7008              STRB     r0,[r1,#0]            ;636
000192  4906              LDR      r1,|L20.428|
000194  8488              STRH     r0,[r1,#0x24]         ;638
000196  84c8              STRH     r0,[r1,#0x26]         ;639
                  |L20.408|
000198  2000              MOVS     r0,#0                 ;642
00019a  4908              LDR      r1,|L20.444|
00019c  7008              STRB     r0,[r1,#0]            ;642
                  |L20.414|
00019e  bf00              NOP      
0001a0  e735              B        |L20.14|
;;;645    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L20.420|
                          DCD      g_GT811
                  |L20.424|
                          DCD      g_tFT5X06
                  |L20.428|
                          DCD      g_tTP
                  |L20.432|
                          DCD      g_ChipID
                  |L20.436|
                          DCD      s_count
                  |L20.440|
                          DCD      s_usXBuf
                  |L20.444|
                          DCD      s_ucPos
                  |L20.448|
                          DCD      s_usYBuf
                  |L20.452|
                          DCD      s_down
                  |L20.456|
                          DCD      State
                  |L20.460|
                          DCD      s_usSaveAdcX
                  |L20.464|
                          DCD      s_usSaveAdcY

                          AREA ||i.TOUCH_TransX||, CODE, READONLY, ALIGN=2

                  TOUCH_TransX PROC
;;;666    */
;;;667    static int16_t TOUCH_TransX(uint16_t _usAdcX, uint16_t _usAdcY)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;668    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;669    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;670    	uint16_t x;
;;;671    	int32_t y;
;;;672    
;;;673    	if (g_tTP.XYChange == 0)
;;;674    	{
;;;675    		x = _usAdcX;
;;;676    		if (x == 0)
;;;677    		{
;;;678    			y = 0;
;;;679    		}
;;;680    		else
;;;681    		{
;;;682    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_X1, g_tTP.usAdcX2, TP_X2, x);
;;;683    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdX1, g_tTP.usAdcX2, g_tTP.usLcdX2, x);
;;;684    		}
;;;685    	}
;;;686    	else
;;;687    	{
;;;688    		x = _usAdcY;
;;;689    		if (x == 0)
;;;690    		{
;;;691    			y = 0;
;;;692    		}
;;;693    		else
;;;694    		{
;;;695    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_X1, g_tTP.usAdcY2, TP_X2, x);
;;;696    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdX1, g_tTP.usAdcY2, g_tTP.usLcdX2, x);
;;;697    		}
;;;698    	}
;;;699    	return y;
;;;700    #else		/* 4点校准 */
;;;701    	uint16_t x, x1, x2;
;;;702    	int32_t y;
;;;703    
;;;704    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
000008  482a              LDR      r0,|L21.180|
00000a  8c00              LDRH     r0,[r0,#0x20]  ; g_tTP
00000c  b9f8              CBNZ     r0,|L21.78|
;;;705    	{
;;;706    		x = _usAdcX;
00000e  4626              MOV      r6,r4
;;;707    
;;;708    		/* 根据 Y ADC 实时计算直线方程的参考点x1, x2
;;;709    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_X1, AdcX4, TP_X4, _usAdcY)
;;;710    			if  _usAdcY = usAdcY2 then  取点 = (AdcX3, TP_X3, AdcX2, TP_X2, _usAdcY)
;;;711    
;;;712    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;713    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;714    		*/
;;;715    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX3, _usAdcY);
000010  f8dfc0a0          LDR      r12,|L21.180|
000014  9500              STR      r5,[sp,#0]
000016  f8bc3008          LDRH     r3,[r12,#8]  ; g_tTP
00001a  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
00001e  f8bc1000          LDRH     r1,[r12,#0]  ; g_tTP
000022  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
000026  f7fffffe          BL       CalTwoPoint
00002a  fa1ff880          UXTH     r8,r0
;;;716    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX4, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
00002e  f8dfc084          LDR      r12,|L21.180|
000032  9500              STR      r5,[sp,#0]
000034  f8bc3004          LDRH     r3,[r12,#4]  ; g_tTP
000038  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
00003c  f8bc100c          LDRH     r1,[r12,#0xc]  ; g_tTP
000040  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
000044  f7fffffe          BL       CalTwoPoint
000048  fa1ff980          UXTH     r9,r0
00004c  e01e              B        |L21.140|
                  |L21.78|
;;;717    	}
;;;718    	else						/* X Y 坐标交换 */
;;;719    	{
;;;720    		x = _usAdcY;
00004e  462e              MOV      r6,r5
;;;721    
;;;722    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;723    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_X1, AdcY4, TP_X4, _usAdcX)
;;;724    			if  _usAdcX = usAdcX2 then  取点 = (AdcY3, TP_X3, AdcY2, TP_X2, _usAdcX)
;;;725    
;;;726    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;727    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;728    		*/
;;;729    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY3, _usAdcX);
000050  f8dfc060          LDR      r12,|L21.180|
000054  9400              STR      r4,[sp,#0]
000056  f8bc300a          LDRH     r3,[r12,#0xa]  ; g_tTP
00005a  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
00005e  f8bc1002          LDRH     r1,[r12,#2]  ; g_tTP
000062  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
000066  f7fffffe          BL       CalTwoPoint
00006a  fa1ff880          UXTH     r8,r0
;;;730    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY4, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
00006e  f8dfc044          LDR      r12,|L21.180|
000072  9400              STR      r4,[sp,#0]
000074  f8bc3006          LDRH     r3,[r12,#6]  ; g_tTP
000078  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
00007c  f8bc100e          LDRH     r1,[r12,#0xe]  ; g_tTP
000080  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
000084  f7fffffe          BL       CalTwoPoint
000088  fa1ff980          UXTH     r9,r0
                  |L21.140|
;;;731    	}
;;;732    
;;;733    	if (x == 0)
00008c  b90e              CBNZ     r6,|L21.146|
;;;734    	{
;;;735    		y = 0;
00008e  2700              MOVS     r7,#0
000090  e00c              B        |L21.172|
                  |L21.146|
;;;736    	}
;;;737    	else
;;;738    	{
;;;739    		/* 根据2点直线方程，计算坐标 */
;;;740    		y = CalTwoPoint(x1, TP_X1, x2, TP_X2, x);
000092  f7fffffe          BL       LCD_GetWidth
000096  3814              SUBS     r0,r0,#0x14
000098  fa1ffa80          UXTH     r10,r0
00009c  4653              MOV      r3,r10
00009e  464a              MOV      r2,r9
0000a0  2114              MOVS     r1,#0x14
0000a2  4640              MOV      r0,r8
0000a4  9600              STR      r6,[sp,#0]
0000a6  f7fffffe          BL       CalTwoPoint
0000aa  4607              MOV      r7,r0
                  |L21.172|
;;;741    		//CalTwoPoint(x1, g_tTP.usLcdX1, x2, g_tTP.usLcd2, x);
;;;742    	}
;;;743    	return y;
0000ac  b238              SXTH     r0,r7
;;;744    #endif
;;;745    }
0000ae  e8bd8ff8          POP      {r3-r11,pc}
;;;746    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L21.180|
                          DCD      g_tTP

                          AREA ||i.TOUCH_TransY||, CODE, READONLY, ALIGN=2

                  TOUCH_TransY PROC
;;;754    */
;;;755    static int16_t TOUCH_TransY(uint16_t _usAdcX, uint16_t _usAdcY)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;756    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;757    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;758    	int32_t x;
;;;759    	int32_t y;
;;;760    
;;;761    	if (g_tTP.XYChange == 0)
;;;762    	{
;;;763    		x = _usAdcY;
;;;764    		if (x == 0)
;;;765    		{
;;;766    			y = 0;
;;;767    		}
;;;768    		else
;;;769    		{
;;;770    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_Y1, g_tTP.usAdcY2, TP_Y2, x);
;;;771    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdY1, g_tTP.usAdcY2, g_tTP.usLcdY2, x);
;;;772    		}
;;;773    	}
;;;774    	else
;;;775    	{
;;;776    		x = _usAdcX;
;;;777    		if (x == 0)
;;;778    		{
;;;779    			y = 0;
;;;780    		}
;;;781    		else
;;;782    		{
;;;783    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_Y1, g_tTP.usAdcX2, TP_Y2, x);
;;;784    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdY1, g_tTP.usAdcX2, g_tTP.usLcdY2, x);
;;;785    		}
;;;786    	}
;;;787    	return y;
;;;788    #else		/* 4点校准 */
;;;789    	int32_t x, x1, x2;
;;;790    	int32_t y;
;;;791    
;;;792    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
000008  482a              LDR      r0,|L22.180|
00000a  8c00              LDRH     r0,[r0,#0x20]  ; g_tTP
00000c  b9e8              CBNZ     r0,|L22.74|
;;;793    	{
;;;794    		x = _usAdcY;
00000e  462e              MOV      r6,r5
;;;795    
;;;796    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;797    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_Y1, AdcY3, TP_Y3, _usAdcX)
;;;798    			if  _usAdcX = usAdcX2 then  取点 = (AdcY4, TP_Y4, AdcY2, TP_Y2, _usAdcX)
;;;799    
;;;800    			其中 TP_Y1 = TP_Y4;  TP_Y3 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;801    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;802    		*/
;;;803    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY4, _usAdcX);
000010  f8dfc0a0          LDR      r12,|L22.180|
000014  9400              STR      r4,[sp,#0]
000016  f8bc300e          LDRH     r3,[r12,#0xe]  ; g_tTP
00001a  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
00001e  f8bc1002          LDRH     r1,[r12,#2]  ; g_tTP
000022  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
000026  f7fffffe          BL       CalTwoPoint
00002a  4681              MOV      r9,r0
;;;804    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY3, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
00002c  f8dfc084          LDR      r12,|L22.180|
000030  9400              STR      r4,[sp,#0]
000032  f8bc3006          LDRH     r3,[r12,#6]  ; g_tTP
000036  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
00003a  f8bc100a          LDRH     r1,[r12,#0xa]  ; g_tTP
00003e  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
000042  f7fffffe          BL       CalTwoPoint
000046  4607              MOV      r7,r0
000048  e01c              B        |L22.132|
                  |L22.74|
;;;805    	}
;;;806    	else						/* X Y 坐标交换 */
;;;807    	{
;;;808    		x = _usAdcX;
00004a  4626              MOV      r6,r4
;;;809    
;;;810    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;811    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_Y1, AdcX3, TP_Y3, _usAdcY)
;;;812    			if  _usAdcY = usAdcY2 then  取点 = (AdcX4, TP_Y4, AdcX2, TP_Y2, _usAdcY)
;;;813    
;;;814    			其中 TP_Y1 = TP_Y3;  TP_Y4 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;815    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;816    		*/
;;;817    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX4, _usAdcY);
00004c  f8dfc064          LDR      r12,|L22.180|
000050  9500              STR      r5,[sp,#0]
000052  f8bc300c          LDRH     r3,[r12,#0xc]  ; g_tTP
000056  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
00005a  f8bc1000          LDRH     r1,[r12,#0]  ; g_tTP
00005e  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
000062  f7fffffe          BL       CalTwoPoint
000066  4681              MOV      r9,r0
;;;818    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX3, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
000068  f8dfc048          LDR      r12,|L22.180|
00006c  9500              STR      r5,[sp,#0]
00006e  f8bc3004          LDRH     r3,[r12,#4]  ; g_tTP
000072  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
000076  f8bc1008          LDRH     r1,[r12,#8]  ; g_tTP
00007a  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
00007e  f7fffffe          BL       CalTwoPoint
000082  4607              MOV      r7,r0
                  |L22.132|
;;;819    	}
;;;820    
;;;821    	if (x == 0)
000084  b916              CBNZ     r6,|L22.140|
;;;822    	{
;;;823    		y = 0;
000086  f04f0800          MOV      r8,#0
00008a  e00e              B        |L22.170|
                  |L22.140|
;;;824    	}
;;;825    	else
;;;826    	{
;;;827    		/* 根据2点直线方程，计算坐标 */
;;;828    		y = CalTwoPoint(x1, TP_Y1, x2, TP_Y2, x);
00008c  f7fffffe          BL       LCD_GetHeight
000090  3814              SUBS     r0,r0,#0x14
000092  fa1ffa80          UXTH     r10,r0
000096  b2b0              UXTH     r0,r6
000098  b2ba              UXTH     r2,r7
00009a  9000              STR      r0,[sp,#0]
00009c  fa1ff089          UXTH     r0,r9
0000a0  4653              MOV      r3,r10
0000a2  2114              MOVS     r1,#0x14
0000a4  f7fffffe          BL       CalTwoPoint
0000a8  4680              MOV      r8,r0
                  |L22.170|
;;;829    		//y = CalTwoPoint(x1, g_tTP.usLcdY1, x2, g_tTP.usLcdY2, x);
;;;830    	}
;;;831    	return y;
0000aa  fa0ff088          SXTH     r0,r8
;;;832    #endif
;;;833    }
0000ae  e8bd8ff8          POP      {r3-r11,pc}
;;;834    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L22.180|
                          DCD      g_tTP

                          AREA ||i.TOUCH_WaitRelease||, CODE, READONLY, ALIGN=1

                  TOUCH_WaitRelease PROC
;;;1000   */
;;;1001   static void TOUCH_WaitRelease(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1002   {
;;;1003   	uint8_t usCount = 0;
000002  2400              MOVS     r4,#0
;;;1004   
;;;1005   	for (;;)
000004  bf00              NOP      
                  |L23.6|
;;;1006   	{
;;;1007   		if (TOUCH_PressValid(TOUCH_ReadAdcX(), TOUCH_ReadAdcY()) == 0)
000006  f7fffffe          BL       TOUCH_ReadAdcY
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       TOUCH_ReadAdcX
000010  4606              MOV      r6,r0
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       TOUCH_PressValid
000018  b928              CBNZ     r0,|L23.38|
;;;1008   		{
;;;1009   			if (++usCount > 5)
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c0              UXTB     r0,r0
00001e  4604              MOV      r4,r0
000020  2805              CMP      r0,#5
000022  dd01              BLE      |L23.40|
;;;1010   			{
;;;1011   				break;
000024  e004              B        |L23.48|
                  |L23.38|
;;;1012   			}
;;;1013   		}
;;;1014   		else
;;;1015   		{
;;;1016   			usCount = 0;
000026  2400              MOVS     r4,#0
                  |L23.40|
;;;1017   		}
;;;1018   		bsp_DelayMS(10);
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       bsp_DelayMS
00002e  e7ea              B        |L23.6|
                  |L23.48|
000030  bf00              NOP                            ;1011
;;;1019   	}
;;;1020   }
000032  bd70              POP      {r4-r6,pc}
;;;1021   
                          ENDP


                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;193     */
;;;194    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;195    {
;;;196      register uint32_t __regPriMask         __ASM("primask");
;;;197      __regPriMask = (priMask);
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tTP
                          %        144
                  State
                          %        12
                  s_usXBuf
                          %        20
                  s_usYBuf
                          %        20

                          AREA ||.data||, DATA, ALIGN=1

                  s_invalid_count
000000  00                DCB      0x00
                  s_ucPos
000001  00                DCB      0x00
                  s_count
000002  00                DCB      0x00
                  s_down
000003  00                DCB      0x00
                  s_usSaveAdcX
000004  0000              DCB      0x00,0x00
                  s_usSaveAdcY
000006  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_touch.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_touch_c_30847bcd____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REVSH|
#line 144
|__asm___11_bsp_touch_c_30847bcd____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____RRX|
#line 300
|__asm___11_bsp_touch_c_30847bcd____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
