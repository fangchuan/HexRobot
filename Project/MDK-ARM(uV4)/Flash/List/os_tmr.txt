; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_tmr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_tmr.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\os_tmr.crf ..\..\uCOS-III\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;103    
;;;104    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;105                       CPU_CHAR             *p_name,
;;;106                       OS_TICK               dly,
;;;107                       OS_TICK               period,
;;;108                       OS_OPT                opt,
;;;109                       OS_TMR_CALLBACK_PTR   p_callback,
;;;110                       void                 *p_callback_arg,
;;;111                       OS_ERR               *p_err)
;;;112    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
000014  9d0d              LDR      r5,[sp,#0x34]
;;;113        CPU_SR_ALLOC();
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;114    
;;;115    
;;;116    
;;;117    #ifdef OS_SAFETY_CRITICAL
;;;118        if (p_err == (OS_ERR *)0) {
;;;119            OS_SAFETY_CRITICAL_EXCEPTION();
;;;120            return;
;;;121        }
;;;122    #endif
;;;123    
;;;124    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;125        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;126           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;127            return;
;;;128        }
;;;129    #endif
;;;130    
;;;131    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;132        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
00001a  4829              LDR      r0,|L1.192|
00001c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00001e  2800              CMP      r0,#0
000020  dd04              BLE      |L1.44|
;;;133           *p_err = OS_ERR_TMR_ISR;
000022  f2473043          MOV      r0,#0x7343
000026  8028              STRH     r0,[r5,#0]
                  |L1.40|
;;;134            return;
;;;135        }
;;;136    #endif
;;;137    
;;;138    #if OS_CFG_ARG_CHK_EN > 0u
;;;139        if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
;;;140           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;141            return;
;;;142        }
;;;143    
;;;144        switch (opt) {
;;;145            case OS_OPT_TMR_PERIODIC:
;;;146                 if (period == (OS_TICK)0) {
;;;147                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;148                     return;
;;;149                 }
;;;150                 break;
;;;151    
;;;152            case OS_OPT_TMR_ONE_SHOT:
;;;153                 if (dly == (OS_TICK)0) {
;;;154                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;155                     return;
;;;156                 }
;;;157                 break;
;;;158    
;;;159            default:
;;;160                *p_err = OS_ERR_OPT_INVALID;
;;;161                 return;
;;;162        }
;;;163    #endif
;;;164    
;;;165        OS_CRITICAL_ENTER();
;;;166        p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
;;;167        p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
;;;168        p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
;;;169        p_tmr->Dly            = (OS_TICK            )dly;
;;;170        p_tmr->Match          = (OS_TICK            )0;
;;;171        p_tmr->Remain         = (OS_TICK            )0;
;;;172        p_tmr->Period         = (OS_TICK            )period;
;;;173        p_tmr->Opt            = (OS_OPT             )opt;
;;;174        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
;;;175        p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
;;;176        p_tmr->NextPtr        = (OS_TMR            *)0;
;;;177        p_tmr->PrevPtr        = (OS_TMR            *)0;
;;;178    
;;;179    #if OS_CFG_DBG_EN > 0u
;;;180        OS_TmrDbgListAdd(p_tmr);
;;;181    #endif
;;;182        OSTmrQty++;                                             /* Keep track of the number of timers created             */
;;;183    
;;;184        OS_CRITICAL_EXIT_NO_SCHED();
;;;185       *p_err = OS_ERR_NONE;
;;;186    }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.44|
00002c  b91c              CBNZ     r4,|L1.54|
00002e  f64550c3          MOV      r0,#0x5dc3            ;140
000032  8028              STRH     r0,[r5,#0]            ;140
000034  e7f8              B        |L1.40|
                  |L1.54|
000036  f1b90f01          CMP      r9,#1                 ;144
00003a  d008              BEQ      |L1.78|
00003c  f1b90f02          CMP      r9,#2                 ;144
000040  d10b              BNE      |L1.90|
000042  b91f              CBNZ     r7,|L1.76|
000044  f2473040          MOV      r0,#0x7340            ;147
000048  8028              STRH     r0,[r5,#0]            ;147
00004a  e7ed              B        |L1.40|
                  |L1.76|
00004c  e009              B        |L1.98|
                  |L1.78|
00004e  b91e              CBNZ     r6,|L1.88|
000050  f247303f          MOV      r0,#0x733f            ;154
000054  8028              STRH     r0,[r5,#0]            ;154
000056  e7e7              B        |L1.40|
                  |L1.88|
000058  e003              B        |L1.98|
                  |L1.90|
00005a  f6456025          MOV      r0,#0x5e25            ;160
00005e  8028              STRH     r0,[r5,#0]            ;160
000060  e7e2              B        |L1.40|
                  |L1.98|
000062  bf00              NOP                            ;150
000064  bf00              NOP                            ;165
000066  bf00              NOP                            ;165
000068  f7fffffe          BL       CPU_SR_Save
00006c  9000              STR      r0,[sp,#0]            ;165
00006e  bf00              NOP                            ;165
000070  bf00              NOP                            ;165
000072  2001              MOVS     r0,#1                 ;166
000074  f884002a          STRB     r0,[r4,#0x2a]         ;166
000078  4812              LDR      r0,|L1.196|
00007a  6020              STR      r0,[r4,#0]            ;167
00007c  f8c48004          STR      r8,[r4,#4]            ;168
000080  6226              STR      r6,[r4,#0x20]         ;169
000082  2000              MOVS     r0,#0                 ;170
000084  61a0              STR      r0,[r4,#0x18]         ;170
000086  61e0              STR      r0,[r4,#0x1c]         ;171
000088  6267              STR      r7,[r4,#0x24]         ;172
00008a  f8a49028          STRH     r9,[r4,#0x28]         ;173
00008e  f8c4a008          STR      r10,[r4,#8]           ;174
000092  f8c4b00c          STR      r11,[r4,#0xc]         ;175
000096  6120              STR      r0,[r4,#0x10]         ;176
000098  6160              STR      r0,[r4,#0x14]         ;177
00009a  4620              MOV      r0,r4                 ;180
00009c  f7fffffe          BL       OS_TmrDbgListAdd
0000a0  4809              LDR      r0,|L1.200|
0000a2  8800              LDRH     r0,[r0,#0]            ;182  ; OSTmrQty
0000a4  1c40              ADDS     r0,r0,#1              ;182
0000a6  4908              LDR      r1,|L1.200|
0000a8  8008              STRH     r0,[r1,#0]            ;182
0000aa  bf00              NOP                            ;184
0000ac  bf00              NOP                            ;184
0000ae  9800              LDR      r0,[sp,#0]            ;184
0000b0  f7fffffe          BL       CPU_SR_Restore
0000b4  bf00              NOP                            ;184
0000b6  bf00              NOP                            ;184
0000b8  2000              MOVS     r0,#0                 ;185
0000ba  8028              STRH     r0,[r5,#0]            ;185
0000bc  bf00              NOP      
0000be  e7b3              B        |L1.40|
;;;187    
                          ENDP

                  |L1.192|
                          DCD      OSIntNestingCtr
                  |L1.196|
                          DCD      0x20524d54
                  |L1.200|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;211    #if OS_CFG_TMR_DEL_EN > 0u
;;;212    CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;213                           OS_ERR  *p_err)
;;;214    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;215        OS_ERR       err;
;;;216        CPU_BOOLEAN  success;
;;;217    
;;;218    
;;;219    
;;;220    #ifdef OS_SAFETY_CRITICAL
;;;221        if (p_err == (OS_ERR *)0) {
;;;222            OS_SAFETY_CRITICAL_EXCEPTION();
;;;223            return (DEF_FALSE);
;;;224        }
;;;225    #endif
;;;226    
;;;227    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;228        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000006  482c              LDR      r0,|L2.184|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd04              BLE      |L2.24|
;;;229           *p_err  = OS_ERR_TMR_ISR;
00000e  f2473043          MOV      r0,#0x7343
000012  8020              STRH     r0,[r4,#0]
;;;230            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;231        }
;;;232    #endif
;;;233    
;;;234    #if OS_CFG_ARG_CHK_EN > 0u
;;;235        if (p_tmr == (OS_TMR *)0) {
;;;236           *p_err = OS_ERR_TMR_INVALID;
;;;237            return (DEF_FALSE);
;;;238        }
;;;239    #endif
;;;240    
;;;241    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;242        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;243           *p_err = OS_ERR_OBJ_TYPE;
;;;244            return (DEF_FALSE);
;;;245        }
;;;246    #endif
;;;247    
;;;248        OSSchedLock(&err);
;;;249    #if OS_CFG_DBG_EN > 0u
;;;250        OS_TmrDbgListRemove(p_tmr);
;;;251    #endif
;;;252        OSTmrQty--;                                             /* One less timer                                         */
;;;253    
;;;254        switch (p_tmr->State) {
;;;255            case OS_TMR_STATE_RUNNING:
;;;256                 OS_TmrUnlink(p_tmr);                           /* Remove from current wheel spoke                        */
;;;257                 OS_TmrClr(p_tmr);
;;;258                 OSSchedUnlock(&err);
;;;259                *p_err   = OS_ERR_NONE;
;;;260                 success = DEF_TRUE;
;;;261                 break;
;;;262    
;;;263            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;264            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;265                 OS_TmrClr(p_tmr);                              /* Clear timer fields                                     */
;;;266                 OSSchedUnlock(&err);
;;;267                *p_err   = OS_ERR_NONE;
;;;268                 success = DEF_TRUE;
;;;269                 break;
;;;270                 
;;;271            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;272                 OSSchedUnlock(&err);
;;;273                *p_err   = OS_ERR_TMR_INACTIVE;
;;;274                 success = DEF_FALSE;
;;;275                 break;
;;;276    
;;;277            default:
;;;278                 OSSchedUnlock(&err);
;;;279                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;280                 success = DEF_FALSE;
;;;281                 break;
;;;282        }
;;;283        return (success);
;;;284    }
000016  bdf8              POP      {r3-r7,pc}
                  |L2.24|
000018  b926              CBNZ     r6,|L2.36|
00001a  f2473042          MOV      r0,#0x7342            ;236
00001e  8020              STRH     r0,[r4,#0]            ;236
000020  2000              MOVS     r0,#0                 ;237
000022  e7f8              B        |L2.22|
                  |L2.36|
000024  4925              LDR      r1,|L2.188|
000026  6830              LDR      r0,[r6,#0]            ;242
000028  4288              CMP      r0,r1                 ;242
00002a  d004              BEQ      |L2.54|
00002c  f64550c4          MOV      r0,#0x5dc4            ;243
000030  8020              STRH     r0,[r4,#0]            ;243
000032  2000              MOVS     r0,#0                 ;244
000034  e7ef              B        |L2.22|
                  |L2.54|
000036  4668              MOV      r0,sp                 ;248
000038  f7fffffe          BL       OSSchedLock
00003c  4630              MOV      r0,r6                 ;250
00003e  f7fffffe          BL       OS_TmrDbgListRemove
000042  481f              LDR      r0,|L2.192|
000044  8800              LDRH     r0,[r0,#0]            ;252  ; OSTmrQty
000046  1e40              SUBS     r0,r0,#1              ;252
000048  491d              LDR      r1,|L2.192|
00004a  8008              STRH     r0,[r1,#0]            ;252
00004c  f896002a          LDRB     r0,[r6,#0x2a]         ;254
000050  b1f0              CBZ      r0,|L2.144|
000052  2801              CMP      r0,#1                 ;254
000054  d011              BEQ      |L2.122|
000056  2802              CMP      r0,#2                 ;254
000058  d002              BEQ      |L2.96|
00005a  2803              CMP      r0,#3                 ;254
00005c  d120              BNE      |L2.160|
00005e  e00d              B        |L2.124|
                  |L2.96|
000060  4630              MOV      r0,r6                 ;256
000062  f7fffffe          BL       OS_TmrUnlink
000066  4630              MOV      r0,r6                 ;257
000068  f7fffffe          BL       OS_TmrClr
00006c  4668              MOV      r0,sp                 ;258
00006e  f7fffffe          BL       OSSchedUnlock
000072  2000              MOVS     r0,#0                 ;259
000074  8020              STRH     r0,[r4,#0]            ;259
000076  2501              MOVS     r5,#1                 ;260
000078  e01a              B        |L2.176|
                  |L2.122|
00007a  bf00              NOP                            ;264
                  |L2.124|
00007c  4630              MOV      r0,r6                 ;265
00007e  f7fffffe          BL       OS_TmrClr
000082  4668              MOV      r0,sp                 ;266
000084  f7fffffe          BL       OSSchedUnlock
000088  2000              MOVS     r0,#0                 ;267
00008a  8020              STRH     r0,[r4,#0]            ;267
00008c  2501              MOVS     r5,#1                 ;268
00008e  e00f              B        |L2.176|
                  |L2.144|
000090  4668              MOV      r0,sp                 ;272
000092  f7fffffe          BL       OSSchedUnlock
000096  f247303d          MOV      r0,#0x733d            ;273
00009a  8020              STRH     r0,[r4,#0]            ;273
00009c  2500              MOVS     r5,#0                 ;274
00009e  e007              B        |L2.176|
                  |L2.160|
0000a0  4668              MOV      r0,sp                 ;278
0000a2  f7fffffe          BL       OSSchedUnlock
0000a6  f2473041          MOV      r0,#0x7341            ;279
0000aa  8020              STRH     r0,[r4,#0]            ;279
0000ac  2500              MOVS     r5,#0                 ;280
0000ae  bf00              NOP                            ;281
                  |L2.176|
0000b0  bf00              NOP                            ;261
0000b2  4628              MOV      r0,r5                 ;283
0000b4  e7af              B        |L2.22|
;;;285    #endif
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      OSIntNestingCtr
                  |L2.188|
                          DCD      0x20524d54
                  |L2.192|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;310    
;;;311    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;312                             OS_ERR  *p_err)
;;;313    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;314        OS_TICK  remain;
;;;315        OS_ERR   err;
;;;316    
;;;317    
;;;318    
;;;319    #ifdef OS_SAFETY_CRITICAL
;;;320        if (p_err == (OS_ERR *)0) {
;;;321            OS_SAFETY_CRITICAL_EXCEPTION();
;;;322            return ((OS_TICK)0);
;;;323        }
;;;324    #endif
;;;325    
;;;326    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;327        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000006  482d              LDR      r0,|L3.188|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd04              BLE      |L3.24|
;;;328           *p_err = OS_ERR_TMR_ISR;
00000e  f2473043          MOV      r0,#0x7343
000012  8030              STRH     r0,[r6,#0]
;;;329            return ((OS_TICK)0);
000014  2000              MOVS     r0,#0
                  |L3.22|
;;;330        }
;;;331    #endif
;;;332    
;;;333    #if OS_CFG_ARG_CHK_EN > 0u
;;;334        if (p_tmr == (OS_TMR *)0) {
;;;335           *p_err = OS_ERR_TMR_INVALID;
;;;336            return ((OS_TICK)0);
;;;337        }
;;;338    #endif
;;;339    
;;;340    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;341        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;342           *p_err = OS_ERR_OBJ_TYPE;
;;;343            return ((OS_TICK)0);
;;;344        }
;;;345    #endif
;;;346    
;;;347        OSSchedLock(&err);
;;;348        switch (p_tmr->State) {
;;;349            case OS_TMR_STATE_RUNNING:
;;;350                 remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
;;;351                               - OSTmrTickCtr;
;;;352                 p_tmr->Remain = remain;
;;;353                 OSSchedUnlock(&err);
;;;354                *p_err         = OS_ERR_NONE;
;;;355                 break;
;;;356    
;;;357            case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
;;;358                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;359                     if (p_tmr->Dly == 0u) {
;;;360                         remain = p_tmr->Period;
;;;361                     } else {
;;;362                         remain = p_tmr->Dly;
;;;363                     }
;;;364                 } else {
;;;365                     remain = p_tmr->Dly;
;;;366                 }
;;;367                 p_tmr->Remain = remain;
;;;368                 OSSchedUnlock(&err);
;;;369                *p_err         = OS_ERR_NONE;
;;;370                 break;
;;;371    
;;;372            case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
;;;373                 OSSchedUnlock(&err);
;;;374                *p_err  = OS_ERR_NONE;
;;;375                 remain = (OS_TICK)0;
;;;376                 break;
;;;377    
;;;378            case OS_TMR_STATE_UNUSED:
;;;379                 OSSchedUnlock(&err);
;;;380                *p_err  = OS_ERR_TMR_INACTIVE;
;;;381                 remain = (OS_TICK)0;
;;;382                 break;
;;;383    
;;;384            default:
;;;385                 OSSchedUnlock(&err);
;;;386                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;387                 remain = (OS_TICK)0;
;;;388                 break;
;;;389        }
;;;390        return (remain);
;;;391    }
000016  bdf8              POP      {r3-r7,pc}
                  |L3.24|
000018  b924              CBNZ     r4,|L3.36|
00001a  f2473042          MOV      r0,#0x7342            ;335
00001e  8030              STRH     r0,[r6,#0]            ;335
000020  2000              MOVS     r0,#0                 ;336
000022  e7f8              B        |L3.22|
                  |L3.36|
000024  4926              LDR      r1,|L3.192|
000026  6820              LDR      r0,[r4,#0]            ;341
000028  4288              CMP      r0,r1                 ;341
00002a  d004              BEQ      |L3.54|
00002c  f64550c4          MOV      r0,#0x5dc4            ;342
000030  8030              STRH     r0,[r6,#0]            ;342
000032  2000              MOVS     r0,#0                 ;343
000034  e7ef              B        |L3.22|
                  |L3.54|
000036  4668              MOV      r0,sp                 ;347
000038  f7fffffe          BL       OSSchedLock
00003c  f894002a          LDRB     r0,[r4,#0x2a]         ;348
000040  b348              CBZ      r0,|L3.150|
000042  2801              CMP      r0,#1                 ;348
000044  d00f              BEQ      |L3.102|
000046  2802              CMP      r0,#2                 ;348
000048  d002              BEQ      |L3.80|
00004a  2803              CMP      r0,#3                 ;348
00004c  d12b              BNE      |L3.166|
00004e  e01b              B        |L3.136|
                  |L3.80|
000050  491c              LDR      r1,|L3.196|
000052  69a0              LDR      r0,[r4,#0x18]         ;350
000054  6809              LDR      r1,[r1,#0]            ;350  ; OSTmrTickCtr
000056  1a45              SUBS     r5,r0,r1              ;350
000058  61e5              STR      r5,[r4,#0x1c]         ;352
00005a  4668              MOV      r0,sp                 ;353
00005c  f7fffffe          BL       OSSchedUnlock
000060  2000              MOVS     r0,#0                 ;354
000062  8030              STRH     r0,[r6,#0]            ;354
000064  e027              B        |L3.182|
                  |L3.102|
000066  8d20              LDRH     r0,[r4,#0x28]         ;358
000068  2802              CMP      r0,#2                 ;358
00006a  d105              BNE      |L3.120|
00006c  6a20              LDR      r0,[r4,#0x20]         ;359
00006e  b908              CBNZ     r0,|L3.116|
000070  6a65              LDR      r5,[r4,#0x24]         ;360
000072  e002              B        |L3.122|
                  |L3.116|
000074  6a25              LDR      r5,[r4,#0x20]         ;362
000076  e000              B        |L3.122|
                  |L3.120|
000078  6a25              LDR      r5,[r4,#0x20]         ;365
                  |L3.122|
00007a  61e5              STR      r5,[r4,#0x1c]         ;367
00007c  4668              MOV      r0,sp                 ;368
00007e  f7fffffe          BL       OSSchedUnlock
000082  2000              MOVS     r0,#0                 ;369
000084  8030              STRH     r0,[r6,#0]            ;369
000086  e016              B        |L3.182|
                  |L3.136|
000088  4668              MOV      r0,sp                 ;373
00008a  f7fffffe          BL       OSSchedUnlock
00008e  2000              MOVS     r0,#0                 ;374
000090  8030              STRH     r0,[r6,#0]            ;374
000092  2500              MOVS     r5,#0                 ;375
000094  e00f              B        |L3.182|
                  |L3.150|
000096  4668              MOV      r0,sp                 ;379
000098  f7fffffe          BL       OSSchedUnlock
00009c  f247303d          MOV      r0,#0x733d            ;380
0000a0  8030              STRH     r0,[r6,#0]            ;380
0000a2  2500              MOVS     r5,#0                 ;381
0000a4  e007              B        |L3.182|
                  |L3.166|
0000a6  4668              MOV      r0,sp                 ;385
0000a8  f7fffffe          BL       OSSchedUnlock
0000ac  f2473041          MOV      r0,#0x7341            ;386
0000b0  8030              STRH     r0,[r6,#0]            ;386
0000b2  2500              MOVS     r5,#0                 ;387
0000b4  bf00              NOP                            ;388
                  |L3.182|
0000b6  bf00              NOP                            ;355
0000b8  4628              MOV      r0,r5                 ;390
0000ba  e7ac              B        |L3.22|
;;;392    
                          ENDP

                  |L3.188|
                          DCD      OSIntNestingCtr
                  |L3.192|
                          DCD      0x20524d54
                  |L3.196|
                          DCD      OSTmrTickCtr

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;420    
;;;421    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;422                             OS_ERR  *p_err)
;;;423    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;424        OS_ERR       err;
;;;425        CPU_BOOLEAN  success;
;;;426    
;;;427    
;;;428    
;;;429    #ifdef OS_SAFETY_CRITICAL
;;;430        if (p_err == (OS_ERR *)0) {
;;;431            OS_SAFETY_CRITICAL_EXCEPTION();
;;;432            return (DEF_FALSE);
;;;433        }
;;;434    #endif
;;;435    
;;;436    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;437        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000006  4829              LDR      r0,|L4.172|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd04              BLE      |L4.24|
;;;438           *p_err = OS_ERR_TMR_ISR;
00000e  f2473043          MOV      r0,#0x7343
000012  8020              STRH     r0,[r4,#0]
;;;439            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L4.22|
;;;440        }
;;;441    #endif
;;;442    
;;;443    #if OS_CFG_ARG_CHK_EN > 0u
;;;444        if (p_tmr == (OS_TMR *)0) {
;;;445           *p_err = OS_ERR_TMR_INVALID;
;;;446            return (DEF_FALSE);
;;;447        }
;;;448    #endif
;;;449    
;;;450    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;451        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;452           *p_err = OS_ERR_OBJ_TYPE;
;;;453            return (DEF_FALSE);
;;;454        }
;;;455    #endif
;;;456    
;;;457        OSSchedLock(&err);
;;;458        switch (p_tmr->State) {
;;;459            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;460                 OS_TmrUnlink(p_tmr);                           /* ... Stop the timer                                     */
;;;461                 OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
;;;462                 OSSchedUnlock(&err);
;;;463                *p_err   = OS_ERR_NONE;
;;;464                 success = DEF_TRUE;
;;;465                 break;
;;;466    
;;;467            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;468            case OS_TMR_STATE_COMPLETED:
;;;469                 OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
;;;470                 OSSchedUnlock(&err);
;;;471                *p_err   = OS_ERR_NONE;
;;;472                 success = DEF_TRUE;
;;;473                 break;
;;;474    
;;;475            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;476                 OSSchedUnlock(&err);
;;;477                *p_err   = OS_ERR_TMR_INACTIVE;
;;;478                 success = DEF_FALSE;
;;;479                 break;
;;;480    
;;;481            default:
;;;482                 OSSchedUnlock(&err);
;;;483                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;484                 success = DEF_FALSE;
;;;485                 break;
;;;486        }
;;;487        return (success);
;;;488    }
000016  bdf8              POP      {r3-r7,pc}
                  |L4.24|
000018  b926              CBNZ     r6,|L4.36|
00001a  f2473042          MOV      r0,#0x7342            ;445
00001e  8020              STRH     r0,[r4,#0]            ;445
000020  2000              MOVS     r0,#0                 ;446
000022  e7f8              B        |L4.22|
                  |L4.36|
000024  4922              LDR      r1,|L4.176|
000026  6830              LDR      r0,[r6,#0]            ;451
000028  4288              CMP      r0,r1                 ;451
00002a  d004              BEQ      |L4.54|
00002c  f64550c4          MOV      r0,#0x5dc4            ;452
000030  8020              STRH     r0,[r4,#0]            ;452
000032  2000              MOVS     r0,#0                 ;453
000034  e7ef              B        |L4.22|
                  |L4.54|
000036  4668              MOV      r0,sp                 ;457
000038  f7fffffe          BL       OSSchedLock
00003c  f896002a          LDRB     r0,[r6,#0x2a]         ;458
000040  b300              CBZ      r0,|L4.132|
000042  2801              CMP      r0,#1                 ;458
000044  d012              BEQ      |L4.108|
000046  2802              CMP      r0,#2                 ;458
000048  d002              BEQ      |L4.80|
00004a  2803              CMP      r0,#3                 ;458
00004c  d122              BNE      |L4.148|
00004e  e00e              B        |L4.110|
                  |L4.80|
000050  4630              MOV      r0,r6                 ;460
000052  f7fffffe          BL       OS_TmrUnlink
000056  2100              MOVS     r1,#0                 ;461
000058  4630              MOV      r0,r6                 ;461
00005a  f7fffffe          BL       OS_TmrLink
00005e  4668              MOV      r0,sp                 ;462
000060  f7fffffe          BL       OSSchedUnlock
000064  2000              MOVS     r0,#0                 ;463
000066  8020              STRH     r0,[r4,#0]            ;463
000068  2501              MOVS     r5,#1                 ;464
00006a  e01b              B        |L4.164|
                  |L4.108|
00006c  bf00              NOP                            ;468
                  |L4.110|
00006e  2100              MOVS     r1,#0                 ;469
000070  4630              MOV      r0,r6                 ;469
000072  f7fffffe          BL       OS_TmrLink
000076  4668              MOV      r0,sp                 ;470
000078  f7fffffe          BL       OSSchedUnlock
00007c  2000              MOVS     r0,#0                 ;471
00007e  8020              STRH     r0,[r4,#0]            ;471
000080  2501              MOVS     r5,#1                 ;472
000082  e00f              B        |L4.164|
                  |L4.132|
000084  4668              MOV      r0,sp                 ;476
000086  f7fffffe          BL       OSSchedUnlock
00008a  f247303d          MOV      r0,#0x733d            ;477
00008e  8020              STRH     r0,[r4,#0]            ;477
000090  2500              MOVS     r5,#0                 ;478
000092  e007              B        |L4.164|
                  |L4.148|
000094  4668              MOV      r0,sp                 ;482
000096  f7fffffe          BL       OSSchedUnlock
00009a  f2473041          MOV      r0,#0x7341            ;483
00009e  8020              STRH     r0,[r4,#0]            ;483
0000a0  2500              MOVS     r5,#0                 ;484
0000a2  bf00              NOP                            ;485
                  |L4.164|
0000a4  bf00              NOP                            ;465
0000a6  4628              MOV      r0,r5                 ;487
0000a8  e7b5              B        |L4.22|
;;;489    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L4.172|
                          DCD      OSIntNestingCtr
                  |L4.176|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;515    
;;;516    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;517                             OS_ERR  *p_err)
;;;518    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;519        OS_STATE  state;
;;;520        CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;521    
;;;522    
;;;523    
;;;524    #ifdef OS_SAFETY_CRITICAL
;;;525        if (p_err == (OS_ERR *)0) {
;;;526            OS_SAFETY_CRITICAL_EXCEPTION();
;;;527            return (OS_TMR_STATE_UNUSED);
;;;528        }
;;;529    #endif
;;;530    
;;;531    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;532        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
00000a  481f              LDR      r0,|L5.136|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  2800              CMP      r0,#0
000010  dd05              BLE      |L5.30|
;;;533           *p_err = OS_ERR_TMR_ISR;
000012  f2473043          MOV      r0,#0x7343
000016  8020              STRH     r0,[r4,#0]
;;;534            return (OS_TMR_STATE_UNUSED);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;535        }
;;;536    #endif
;;;537    
;;;538    #if OS_CFG_ARG_CHK_EN > 0u
;;;539        if (p_tmr == (OS_TMR *)0) {
;;;540           *p_err = OS_ERR_TMR_INVALID;
;;;541            return (OS_TMR_STATE_UNUSED);
;;;542        }
;;;543    #endif
;;;544    
;;;545    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;546        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;547           *p_err = OS_ERR_OBJ_TYPE;
;;;548            return (OS_TMR_STATE_UNUSED);
;;;549        }
;;;550    #endif
;;;551    
;;;552        CPU_CRITICAL_ENTER();
;;;553        state = p_tmr->State;
;;;554        switch (state) {
;;;555            case OS_TMR_STATE_UNUSED:
;;;556            case OS_TMR_STATE_STOPPED:
;;;557            case OS_TMR_STATE_COMPLETED:
;;;558            case OS_TMR_STATE_RUNNING:
;;;559                *p_err = OS_ERR_NONE;
;;;560                 break;
;;;561    
;;;562            default:
;;;563                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;564                 break;
;;;565        }
;;;566        CPU_CRITICAL_EXIT();
;;;567        return (state);
;;;568    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  b925              CBNZ     r5,|L5.42|
000020  f2473042          MOV      r0,#0x7342            ;540
000024  8020              STRH     r0,[r4,#0]            ;540
000026  2000              MOVS     r0,#0                 ;541
000028  e7f7              B        |L5.26|
                  |L5.42|
00002a  4918              LDR      r1,|L5.140|
00002c  6828              LDR      r0,[r5,#0]            ;546
00002e  4288              CMP      r0,r1                 ;546
000030  d004              BEQ      |L5.60|
000032  f64550c4          MOV      r0,#0x5dc4            ;547
000036  8020              STRH     r0,[r4,#0]            ;547
000038  2000              MOVS     r0,#0                 ;548
00003a  e7ee              B        |L5.26|
                  |L5.60|
00003c  bf00              NOP                            ;552
00003e  bf00              NOP                            ;552
000040  f7fffffe          BL       CPU_SR_Save
000044  4607              MOV      r7,r0                 ;552
000046  bf00              NOP                            ;552
000048  bf00              NOP                            ;552
00004a  f895602a          LDRB     r6,[r5,#0x2a]         ;553
00004e  b136              CBZ      r6,|L5.94|
000050  2e01              CMP      r6,#1                 ;554
000052  d005              BEQ      |L5.96|
000054  2e02              CMP      r6,#2                 ;554
000056  d005              BEQ      |L5.100|
000058  2e03              CMP      r6,#3                 ;554
00005a  d106              BNE      |L5.106|
00005c  e001              B        |L5.98|
                  |L5.94|
00005e  bf00              NOP                            ;556
                  |L5.96|
000060  bf00              NOP                            ;557
                  |L5.98|
000062  bf00              NOP                            ;558
                  |L5.100|
000064  2000              MOVS     r0,#0                 ;559
000066  8020              STRH     r0,[r4,#0]            ;559
000068  e003              B        |L5.114|
                  |L5.106|
00006a  f2473041          MOV      r0,#0x7341            ;563
00006e  8020              STRH     r0,[r4,#0]            ;563
000070  bf00              NOP                            ;564
                  |L5.114|
000072  bf00              NOP                            ;560
000074  bf00              NOP                            ;566
000076  bf00              NOP                            ;566
000078  4638              MOV      r0,r7                 ;566
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  bf00              NOP                            ;566
000080  bf00              NOP                            ;566
000082  4630              MOV      r0,r6                 ;567
000084  e7c9              B        |L5.26|
;;;569    
                          ENDP

000086  0000              DCW      0x0000
                  |L5.136|
                          DCD      OSIntNestingCtr
                  |L5.140|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;606    
;;;607    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;608                            OS_OPT   opt,
;;;609                            void    *p_callback_arg,
;;;610                            OS_ERR  *p_err)
;;;611    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;612        OS_TMR_CALLBACK_PTR  p_fnct;
;;;613        OS_ERR               err;
;;;614        CPU_BOOLEAN          success;
;;;615    
;;;616    
;;;617    
;;;618    #ifdef OS_SAFETY_CRITICAL
;;;619        if (p_err == (OS_ERR *)0) {
;;;620            OS_SAFETY_CRITICAL_EXCEPTION();
;;;621            return (DEF_FALSE);
;;;622        }
;;;623    #endif
;;;624    
;;;625    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;626        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
00000c  483a              LDR      r0,|L6.248|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  2800              CMP      r0,#0
000012  dd05              BLE      |L6.32|
;;;627           *p_err = OS_ERR_TMR_ISR;
000014  f2473043          MOV      r0,#0x7343
000018  8020              STRH     r0,[r4,#0]
;;;628            return (DEF_FALSE);
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;629        }
;;;630    #endif
;;;631    
;;;632    #if OS_CFG_ARG_CHK_EN > 0u
;;;633        if (p_tmr == (OS_TMR *)0) {
;;;634           *p_err = OS_ERR_TMR_INVALID;
;;;635            return (DEF_FALSE);
;;;636        }
;;;637    #endif
;;;638    
;;;639    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;640        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
;;;641           *p_err = OS_ERR_OBJ_TYPE;
;;;642            return (DEF_FALSE);
;;;643        }
;;;644    #endif
;;;645    
;;;646        OSSchedLock(&err);
;;;647        switch (p_tmr->State) {
;;;648            case OS_TMR_STATE_RUNNING:
;;;649                 OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
;;;650                *p_err = OS_ERR_NONE;
;;;651                 switch (opt) {
;;;652                     case OS_OPT_TMR_CALLBACK:
;;;653                          p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
;;;654                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
;;;655                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
;;;656                          } else {
;;;657                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;658                          }
;;;659                          break;
;;;660    
;;;661                     case OS_OPT_TMR_CALLBACK_ARG:
;;;662                          p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
;;;663                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
;;;664                            (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
;;;665                          } else {
;;;666                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;667                          }
;;;668                          break;
;;;669    
;;;670                     case OS_OPT_TMR_NONE:
;;;671                          break;
;;;672    
;;;673                     default:
;;;674                         OSSchedUnlock(&err);
;;;675                        *p_err = OS_ERR_OPT_INVALID;
;;;676                         return (DEF_FALSE);
;;;677                 }
;;;678                 OSSchedUnlock(&err);
;;;679                 success = DEF_TRUE;
;;;680                 break;
;;;681    
;;;682            case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
;;;683            case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
;;;684                 OSSchedUnlock(&err);
;;;685                *p_err   = OS_ERR_TMR_STOPPED;
;;;686                 success = DEF_TRUE;
;;;687                 break;
;;;688    
;;;689            case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
;;;690                 OSSchedUnlock(&err);
;;;691                *p_err   = OS_ERR_TMR_INACTIVE;
;;;692                 success = DEF_FALSE;
;;;693                 break;
;;;694    
;;;695            default:
;;;696                 OSSchedUnlock(&err);
;;;697                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;698                 success = DEF_FALSE;
;;;699                 break;
;;;700        }
;;;701        return (success);
;;;702    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L6.32|
000020  b925              CBNZ     r5,|L6.44|
000022  f2473042          MOV      r0,#0x7342            ;634
000026  8020              STRH     r0,[r4,#0]            ;634
000028  2000              MOVS     r0,#0                 ;635
00002a  e7f7              B        |L6.28|
                  |L6.44|
00002c  4933              LDR      r1,|L6.252|
00002e  6828              LDR      r0,[r5,#0]            ;640
000030  4288              CMP      r0,r1                 ;640
000032  d004              BEQ      |L6.62|
000034  f64550c4          MOV      r0,#0x5dc4            ;641
000038  8020              STRH     r0,[r4,#0]            ;641
00003a  2000              MOVS     r0,#0                 ;642
00003c  e7ee              B        |L6.28|
                  |L6.62|
00003e  4668              MOV      r0,sp                 ;646
000040  f7fffffe          BL       OSSchedLock
000044  f895002a          LDRB     r0,[r5,#0x2a]         ;647
000048  2800              CMP      r0,#0                 ;647
00004a  d041              BEQ      |L6.208|
00004c  2801              CMP      r0,#1                 ;647
00004e  d037              BEQ      |L6.192|
000050  2802              CMP      r0,#2                 ;647
000052  d002              BEQ      |L6.90|
000054  2803              CMP      r0,#3                 ;647
000056  d143              BNE      |L6.224|
000058  e031              B        |L6.190|
                  |L6.90|
00005a  4628              MOV      r0,r5                 ;649
00005c  f7fffffe          BL       OS_TmrUnlink
000060  2000              MOVS     r0,#0                 ;650
000062  8020              STRH     r0,[r4,#0]            ;650
000064  f1b80f00          CMP      r8,#0                 ;651
000068  d01a              BEQ      |L6.160|
00006a  f1b80f03          CMP      r8,#3                 ;651
00006e  d003              BEQ      |L6.120|
000070  f1b80f04          CMP      r8,#4                 ;651
000074  d115              BNE      |L6.162|
000076  e009              B        |L6.140|
                  |L6.120|
000078  68ae              LDR      r6,[r5,#8]            ;653
00007a  b11e              CBZ      r6,|L6.132|
00007c  4628              MOV      r0,r5                 ;655
00007e  68e9              LDR      r1,[r5,#0xc]          ;655
000080  47b0              BLX      r6                    ;655
000082  e002              B        |L6.138|
                  |L6.132|
000084  f2473044          MOV      r0,#0x7344            ;657
000088  8020              STRH     r0,[r4,#0]            ;657
                  |L6.138|
00008a  e012              B        |L6.178|
                  |L6.140|
00008c  68ae              LDR      r6,[r5,#8]            ;662
00008e  b11e              CBZ      r6,|L6.152|
000090  4649              MOV      r1,r9                 ;664
000092  4628              MOV      r0,r5                 ;664
000094  47b0              BLX      r6                    ;664
000096  e002              B        |L6.158|
                  |L6.152|
000098  f2473044          MOV      r0,#0x7344            ;666
00009c  8020              STRH     r0,[r4,#0]            ;666
                  |L6.158|
00009e  e008              B        |L6.178|
                  |L6.160|
0000a0  e007              B        |L6.178|
                  |L6.162|
0000a2  4668              MOV      r0,sp                 ;674
0000a4  f7fffffe          BL       OSSchedUnlock
0000a8  f6456025          MOV      r0,#0x5e25            ;675
0000ac  8020              STRH     r0,[r4,#0]            ;675
0000ae  2000              MOVS     r0,#0                 ;676
0000b0  e7b4              B        |L6.28|
                  |L6.178|
0000b2  bf00              NOP                            ;659
0000b4  4668              MOV      r0,sp                 ;678
0000b6  f7fffffe          BL       OSSchedUnlock
0000ba  2701              MOVS     r7,#1                 ;679
0000bc  e018              B        |L6.240|
                  |L6.190|
0000be  bf00              NOP                            ;683
                  |L6.192|
0000c0  4668              MOV      r0,sp                 ;684
0000c2  f7fffffe          BL       OSSchedUnlock
0000c6  f2473049          MOV      r0,#0x7349            ;685
0000ca  8020              STRH     r0,[r4,#0]            ;685
0000cc  2701              MOVS     r7,#1                 ;686
0000ce  e00f              B        |L6.240|
                  |L6.208|
0000d0  4668              MOV      r0,sp                 ;690
0000d2  f7fffffe          BL       OSSchedUnlock
0000d6  f247303d          MOV      r0,#0x733d            ;691
0000da  8020              STRH     r0,[r4,#0]            ;691
0000dc  2700              MOVS     r7,#0                 ;692
0000de  e007              B        |L6.240|
                  |L6.224|
0000e0  4668              MOV      r0,sp                 ;696
0000e2  f7fffffe          BL       OSSchedUnlock
0000e6  f2473041          MOV      r0,#0x7341            ;697
0000ea  8020              STRH     r0,[r4,#0]            ;697
0000ec  2700              MOVS     r7,#0                 ;698
0000ee  bf00              NOP                            ;699
                  |L6.240|
0000f0  bf00              NOP                            ;680
0000f2  4638              MOV      r0,r7                 ;701
0000f4  e792              B        |L6.28|
;;;703    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L6.248|
                          DCD      OSIntNestingCtr
                  |L6.252|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;719    
;;;720    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;721    {
;;;722        p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
000002  f880102a          STRB     r1,[r0,#0x2a]
;;;723        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4907              LDR      r1,|L7.36|
000008  6001              STR      r1,[r0,#0]
;;;724        p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
00000a  a107              ADR      r1,|L7.40|
00000c  6041              STR      r1,[r0,#4]
;;;725        p_tmr->Dly            = (OS_TICK            )0;
00000e  2100              MOVS     r1,#0
000010  6201              STR      r1,[r0,#0x20]
;;;726        p_tmr->Match          = (OS_TICK            )0;
000012  6181              STR      r1,[r0,#0x18]
;;;727        p_tmr->Remain         = (OS_TICK            )0;
000014  61c1              STR      r1,[r0,#0x1c]
;;;728        p_tmr->Period         = (OS_TICK            )0;
000016  6241              STR      r1,[r0,#0x24]
;;;729        p_tmr->Opt            = (OS_OPT             )0;
000018  8501              STRH     r1,[r0,#0x28]
;;;730        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
00001a  6081              STR      r1,[r0,#8]
;;;731        p_tmr->CallbackPtrArg = (void              *)0;
00001c  60c1              STR      r1,[r0,#0xc]
;;;732        p_tmr->NextPtr        = (OS_TMR            *)0;
00001e  6101              STR      r1,[r0,#0x10]
;;;733        p_tmr->PrevPtr        = (OS_TMR            *)0;
000020  6141              STR      r1,[r0,#0x14]
;;;734    }
000022  4770              BX       lr
;;;735    
                          ENDP

                  |L7.36|
                          DCD      0x454e4f4e
                  |L7.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;752    #if OS_CFG_DBG_EN > 0u
;;;753    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;754    {
;;;755        p_tmr->DbgPrevPtr               = (OS_TMR *)0;
000002  62c1              STR      r1,[r0,#0x2c]
;;;756        if (OSTmrDbgListPtr == (OS_TMR *)0) {
000004  4907              LDR      r1,|L8.36|
000006  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000008  b911              CBNZ     r1,|L8.16|
;;;757            p_tmr->DbgNextPtr           = (OS_TMR *)0;
00000a  2100              MOVS     r1,#0
00000c  6301              STR      r1,[r0,#0x30]
00000e  e005              B        |L8.28|
                  |L8.16|
;;;758        } else {
;;;759            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
000010  4904              LDR      r1,|L8.36|
000012  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000014  6301              STR      r1,[r0,#0x30]
;;;760            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
000016  4903              LDR      r1,|L8.36|
000018  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
00001a  62c8              STR      r0,[r1,#0x2c]
                  |L8.28|
;;;761        }
;;;762        OSTmrDbgListPtr                 =  p_tmr;
00001c  4901              LDR      r1,|L8.36|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;763    }
000020  4770              BX       lr
;;;764    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;766    
;;;767    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  6ac2              LDR      r2,[r0,#0x2c]
;;;768    {
;;;769        OS_TMR  *p_tmr_next;
;;;770        OS_TMR  *p_tmr_prev;
;;;771    
;;;772    
;;;773        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;774        p_tmr_next = p_tmr->DbgNextPtr;
000002  6b01              LDR      r1,[r0,#0x30]
;;;775    
;;;776        if (p_tmr_prev == (OS_TMR *)0) {
000004  b93a              CBNZ     r2,|L9.22|
;;;777            OSTmrDbgListPtr = p_tmr_next;
000006  4b09              LDR      r3,|L9.44|
000008  6019              STR      r1,[r3,#0]  ; OSTmrDbgListPtr
;;;778            if (p_tmr_next != (OS_TMR *)0) {
00000a  b109              CBZ      r1,|L9.16|
;;;779                p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
00000c  2300              MOVS     r3,#0
00000e  62cb              STR      r3,[r1,#0x2c]
                  |L9.16|
;;;780            }
;;;781            p_tmr->DbgNextPtr = (OS_TMR *)0;
000010  2300              MOVS     r3,#0
000012  6303              STR      r3,[r0,#0x30]
000014  e009              B        |L9.42|
                  |L9.22|
;;;782    
;;;783        } else if (p_tmr_next == (OS_TMR *)0) {
000016  b919              CBNZ     r1,|L9.32|
;;;784            p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
000018  2300              MOVS     r3,#0
00001a  6313              STR      r3,[r2,#0x30]
;;;785            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
00001c  62c3              STR      r3,[r0,#0x2c]
00001e  e004              B        |L9.42|
                  |L9.32|
;;;786    
;;;787        } else {
;;;788            p_tmr_prev->DbgNextPtr =  p_tmr_next;
000020  6311              STR      r1,[r2,#0x30]
;;;789            p_tmr_next->DbgPrevPtr =  p_tmr_prev;
000022  62ca              STR      r2,[r1,#0x2c]
;;;790            p_tmr->DbgNextPtr      = (OS_TMR *)0;
000024  2300              MOVS     r3,#0
000026  6303              STR      r3,[r0,#0x30]
;;;791            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
000028  62c3              STR      r3,[r0,#0x2c]
                  |L9.42|
;;;792        }
;;;793    }
00002a  4770              BX       lr
;;;794    #endif
                          ENDP

                  |L9.44|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;816    
;;;817    void  OS_TmrInit (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;818    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;819        OS_TMR_SPOKE_IX   i;
;;;820        OS_TMR_SPOKE     *p_spoke;
;;;821    
;;;822    
;;;823    
;;;824    #ifdef OS_SAFETY_CRITICAL
;;;825        if (p_err == (OS_ERR *)0) {
;;;826            OS_SAFETY_CRITICAL_EXCEPTION();
;;;827            return;
;;;828        }
;;;829    #endif
;;;830    
;;;831    #if OS_CFG_DBG_EN > 0u
;;;832        OSTmrDbgListPtr = (OS_TMR *)0;
000006  2000              MOVS     r0,#0
000008  4931              LDR      r1,|L10.208|
00000a  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;833    #endif
;;;834    
;;;835        if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
00000c  4831              LDR      r0,|L10.212|
00000e  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskRate_Hz
000010  b140              CBZ      r0,|L10.36|
;;;836            OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
000012  4831              LDR      r0,|L10.216|
000014  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000016  492f              LDR      r1,|L10.212|
000018  6809              LDR      r1,[r1,#0]  ; OSCfg_TmrTaskRate_Hz
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  492f              LDR      r1,|L10.220|
000020  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
000022  e006              B        |L10.50|
                  |L10.36|
;;;837        } else {
;;;838            OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
000024  482c              LDR      r0,|L10.216|
000026  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000028  210a              MOVS     r1,#0xa
00002a  fbb0f0f1          UDIV     r0,r0,r1
00002e  492b              LDR      r1,|L10.220|
000030  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
                  |L10.50|
;;;839        }
;;;840        OSTmrUpdateCtr   = OSTmrUpdateCnt;
000032  482a              LDR      r0,|L10.220|
000034  6800              LDR      r0,[r0,#0]  ; OSTmrUpdateCnt
000036  492a              LDR      r1,|L10.224|
000038  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCtr
;;;841    
;;;842        OSTmrTickCtr     = (OS_TICK)0;
00003a  2000              MOVS     r0,#0
00003c  4929              LDR      r1,|L10.228|
00003e  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;843    
;;;844        OSTmrTaskTimeMax = (CPU_TS)0;
000040  4929              LDR      r1,|L10.232|
000042  6008              STR      r0,[r1,#0]  ; OSTmrTaskTimeMax
;;;845    
;;;846        for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
000044  2500              MOVS     r5,#0
000046  e008              B        |L10.90|
                  |L10.72|
;;;847            p_spoke                = &OSCfg_TmrWheel[i];
000048  4828              LDR      r0,|L10.236|
00004a  eb0006c5          ADD      r6,r0,r5,LSL #3
;;;848            p_spoke->NbrEntries    = (OS_OBJ_QTY)0;
00004e  2000              MOVS     r0,#0
000050  80b0              STRH     r0,[r6,#4]
;;;849            p_spoke->NbrEntriesMax = (OS_OBJ_QTY)0;
000052  80f0              STRH     r0,[r6,#6]
;;;850            p_spoke->FirstPtr      = (OS_TMR   *)0;
000054  6030              STR      r0,[r6,#0]
000056  1c68              ADDS     r0,r5,#1              ;846
000058  b285              UXTH     r5,r0                 ;846
                  |L10.90|
00005a  4825              LDR      r0,|L10.240|
00005c  8800              LDRH     r0,[r0,#0]            ;846  ; OSCfg_TmrWheelSize
00005e  4285              CMP      r5,r0                 ;846
000060  dbf2              BLT      |L10.72|
;;;851        }
;;;852    
;;;853                                                                /* ---------------- CREATE THE TIMER TASK --------------- */
;;;854        if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
000062  4824              LDR      r0,|L10.244|
000064  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskStkBasePtr
000066  b920              CBNZ     r0,|L10.114|
;;;855           *p_err = OS_ERR_TMR_STK_INVALID;
000068  f2473047          MOV      r0,#0x7347
00006c  8020              STRH     r0,[r4,#0]
                  |L10.110|
;;;856            return;
;;;857        }
;;;858    
;;;859        if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
;;;860           *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
;;;861            return;
;;;862        }
;;;863    
;;;864        if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
;;;865           *p_err = OS_ERR_TMR_PRIO_INVALID;
;;;866            return;
;;;867        }
;;;868    
;;;869        OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
;;;870                     (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;871                     (OS_TASK_PTR )OS_TmrTask,
;;;872                     (void       *)0,
;;;873                     (OS_PRIO     )OSCfg_TmrTaskPrio,
;;;874                     (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,
;;;875                     (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,
;;;876                     (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,
;;;877                     (OS_MSG_QTY  )0,
;;;878                     (OS_TICK     )0,
;;;879                     (void       *)0,
;;;880                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;881                     (OS_ERR     *)p_err);
;;;882    }
00006e  b00a              ADD      sp,sp,#0x28
000070  bd70              POP      {r4-r6,pc}
                  |L10.114|
000072  4821              LDR      r0,|L10.248|
000074  6800              LDR      r0,[r0,#0]            ;859  ; OSCfg_TmrTaskStkSize
000076  4921              LDR      r1,|L10.252|
000078  6809              LDR      r1,[r1,#0]            ;859  ; OSCfg_StkSizeMin
00007a  4288              CMP      r0,r1                 ;859
00007c  d203              BCS      |L10.134|
00007e  f2473048          MOV      r0,#0x7348            ;860
000082  8020              STRH     r0,[r4,#0]            ;860
000084  e7f3              B        |L10.110|
                  |L10.134|
000086  481e              LDR      r0,|L10.256|
000088  7800              LDRB     r0,[r0,#0]            ;864  ; OSCfg_TmrTaskPrio
00008a  283f              CMP      r0,#0x3f              ;864
00008c  d303              BCC      |L10.150|
00008e  f2473046          MOV      r0,#0x7346            ;865
000092  8020              STRH     r0,[r4,#0]            ;865
000094  e7eb              B        |L10.110|
                  |L10.150|
000096  200b              MOVS     r0,#0xb               ;869
000098  2100              MOVS     r1,#0                 ;869
00009a  9105              STR      r1,[sp,#0x14]         ;869
00009c  e9cd0407          STRD     r0,r4,[sp,#0x1c]      ;869
0000a0  9106              STR      r1,[sp,#0x18]         ;869
0000a2  4608              MOV      r0,r1                 ;869
0000a4  4914              LDR      r1,|L10.248|
0000a6  6809              LDR      r1,[r1,#0]            ;869  ; OSCfg_TmrTaskStkSize
0000a8  4a16              LDR      r2,|L10.260|
0000aa  6812              LDR      r2,[r2,#0]            ;869  ; OSCfg_TmrTaskStkLimit
0000ac  4b11              LDR      r3,|L10.244|
0000ae  681b              LDR      r3,[r3,#0]            ;869  ; OSCfg_TmrTaskStkBasePtr
0000b0  e9cd3201          STRD     r3,r2,[sp,#4]         ;869
0000b4  e9cd1003          STRD     r1,r0,[sp,#0xc]       ;869
0000b8  4811              LDR      r0,|L10.256|
0000ba  7800              LDRB     r0,[r0,#0]            ;869  ; OSCfg_TmrTaskPrio
0000bc  2300              MOVS     r3,#0                 ;869
0000be  4a12              LDR      r2,|L10.264|
0000c0  a112              ADR      r1,|L10.268|
0000c2  9000              STR      r0,[sp,#0]            ;869
0000c4  4817              LDR      r0,|L10.292|
0000c6  f7fffffe          BL       OSTaskCreate
0000ca  bf00              NOP      
0000cc  e7cf              B        |L10.110|
;;;883    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L10.208|
                          DCD      OSTmrDbgListPtr
                  |L10.212|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L10.216|
                          DCD      OSCfg_TickRate_Hz
                  |L10.220|
                          DCD      OSTmrUpdateCnt
                  |L10.224|
                          DCD      OSTmrUpdateCtr
                  |L10.228|
                          DCD      OSTmrTickCtr
                  |L10.232|
                          DCD      OSTmrTaskTimeMax
                  |L10.236|
                          DCD      OSCfg_TmrWheel
                  |L10.240|
                          DCD      OSCfg_TmrWheelSize
                  |L10.244|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L10.248|
                          DCD      OSCfg_TmrTaskStkSize
                  |L10.252|
                          DCD      OSCfg_StkSizeMin
                  |L10.256|
                          DCD      OSCfg_TmrTaskPrio
                  |L10.260|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L10.264|
                          DCD      OS_TmrTask
                  |L10.268|
00010c  75432f4f          DCB      "uC/OS-III Timer Task",0
000110  532d4949
000114  49205469
000118  6d657220
00011c  5461736b
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L10.292|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLink||, CODE, READONLY, ALIGN=2

                  OS_TmrLink PROC
;;;905    
;;;906    void  OS_TmrLink (OS_TMR  *p_tmr,
000000  b5f0              PUSH     {r4-r7,lr}
;;;907                      OS_OPT   opt)
;;;908    {
000002  460c              MOV      r4,r1
;;;909        OS_TMR_SPOKE     *p_spoke;
;;;910        OS_TMR           *p_tmr0;
;;;911        OS_TMR           *p_tmr1;
;;;912        OS_TMR_SPOKE_IX   spoke;
;;;913    
;;;914    
;;;915    
;;;916        p_tmr->State = OS_TMR_STATE_RUNNING;
000004  2602              MOVS     r6,#2
000006  f880602a          STRB     r6,[r0,#0x2a]
;;;917        if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
00000a  2c01              CMP      r4,#1
00000c  d105              BNE      |L11.26|
;;;918            p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
00000e  4f2d              LDR      r7,|L11.196|
000010  6a46              LDR      r6,[r0,#0x24]
000012  683f              LDR      r7,[r7,#0]  ; OSTmrTickCtr
000014  443e              ADD      r6,r6,r7
000016  6186              STR      r6,[r0,#0x18]
000018  e00c              B        |L11.52|
                  |L11.26|
;;;919        } else {
;;;920            if (p_tmr->Dly == (OS_TICK)0) {
00001a  6a06              LDR      r6,[r0,#0x20]
00001c  b92e              CBNZ     r6,|L11.42|
;;;921                p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
00001e  4f29              LDR      r7,|L11.196|
000020  6a46              LDR      r6,[r0,#0x24]
000022  683f              LDR      r7,[r7,#0]  ; OSTmrTickCtr
000024  443e              ADD      r6,r6,r7
000026  6186              STR      r6,[r0,#0x18]
000028  e004              B        |L11.52|
                  |L11.42|
;;;922            } else {
;;;923                p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
00002a  4f26              LDR      r7,|L11.196|
00002c  6a06              LDR      r6,[r0,#0x20]
00002e  683f              LDR      r7,[r7,#0]  ; OSTmrTickCtr
000030  443e              ADD      r6,r6,r7
000032  6186              STR      r6,[r0,#0x18]
                  |L11.52|
;;;924            }
;;;925        }
;;;926        spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
000034  4f24              LDR      r7,|L11.200|
000036  883f              LDRH     r7,[r7,#0]  ; OSCfg_TmrWheelSize
000038  6986              LDR      r6,[r0,#0x18]
00003a  fbb6fcf7          UDIV     r12,r6,r7
00003e  fb07661c          MLS      r6,r7,r12,r6
000042  b2b5              UXTH     r5,r6
;;;927        p_spoke = &OSCfg_TmrWheel[spoke];
000044  4e21              LDR      r6,|L11.204|
000046  eb0602c5          ADD      r2,r6,r5,LSL #3
;;;928    
;;;929        if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
00004a  6816              LDR      r6,[r2,#0]
00004c  b936              CBNZ     r6,|L11.92|
;;;930            p_tmr->NextPtr      = (OS_TMR *)0;
00004e  2600              MOVS     r6,#0
000050  6106              STR      r6,[r0,#0x10]
;;;931            p_tmr->PrevPtr      = (OS_TMR *)0;
000052  6146              STR      r6,[r0,#0x14]
;;;932            p_spoke->FirstPtr   = p_tmr;
000054  6010              STR      r0,[r2,#0]
;;;933            p_spoke->NbrEntries = 1u;
000056  2601              MOVS     r6,#1
000058  8096              STRH     r6,[r2,#4]
00005a  e02c              B        |L11.182|
                  |L11.92|
;;;934        } else {
;;;935            p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
00005c  4f19              LDR      r7,|L11.196|
00005e  6986              LDR      r6,[r0,#0x18]
000060  683f              LDR      r7,[r7,#0]  ; OSTmrTickCtr
000062  1bf6              SUBS     r6,r6,r7
000064  61c6              STR      r6,[r0,#0x1c]
;;;936                           - OSTmrTickCtr;
;;;937            p_tmr1         = p_spoke->FirstPtr;                 /* Point to current first timer in the list               */
000066  6811              LDR      r1,[r2,#0]
;;;938            while (p_tmr1 != (OS_TMR *)0) {
000068  e020              B        |L11.172|
                  |L11.106|
;;;939                p_tmr1->Remain = p_tmr1->Match                  /* Compute time remaining of current timer in list        */
00006a  4f16              LDR      r7,|L11.196|
00006c  698e              LDR      r6,[r1,#0x18]
00006e  683f              LDR      r7,[r7,#0]  ; OSTmrTickCtr
000070  1bf6              SUBS     r6,r6,r7
000072  61ce              STR      r6,[r1,#0x1c]
;;;940                               - OSTmrTickCtr;
;;;941                if (p_tmr->Remain > p_tmr1->Remain) {           /* Do we need to insert AFTER current timer in list?      */
000074  69c6              LDR      r6,[r0,#0x1c]
000076  69cf              LDR      r7,[r1,#0x1c]
000078  42be              CMP      r6,r7
00007a  d909              BLS      |L11.144|
;;;942                    if (p_tmr1->NextPtr  != (OS_TMR *)0) {      /* Yes, are we pointing at the last timer in the list?    */
00007c  690e              LDR      r6,[r1,#0x10]
00007e  b10e              CBZ      r6,|L11.132|
;;;943                        p_tmr1            = p_tmr1->NextPtr;    /* No,  Point to next timer in the list                   */
000080  6909              LDR      r1,[r1,#0x10]
000082  e013              B        |L11.172|
                  |L11.132|
;;;944                    } else {
;;;945                        p_tmr->NextPtr    = (OS_TMR *)0;
000084  2600              MOVS     r6,#0
000086  6106              STR      r6,[r0,#0x10]
;;;946                        p_tmr->PrevPtr    =  p_tmr1;
000088  6141              STR      r1,[r0,#0x14]
;;;947                        p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
00008a  6108              STR      r0,[r1,#0x10]
;;;948                        p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
00008c  2100              MOVS     r1,#0
00008e  e00d              B        |L11.172|
                  |L11.144|
;;;949                    }
;;;950                } else {                                        /* Insert before the current timer                        */
;;;951                    if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
000090  694e              LDR      r6,[r1,#0x14]
000092  b92e              CBNZ     r6,|L11.160|
;;;952                        p_tmr->PrevPtr    = (OS_TMR *)0;
000094  2600              MOVS     r6,#0
000096  6146              STR      r6,[r0,#0x14]
;;;953                        p_tmr->NextPtr    = p_tmr1;
000098  6101              STR      r1,[r0,#0x10]
;;;954                        p_tmr1->PrevPtr   = p_tmr;
00009a  6148              STR      r0,[r1,#0x14]
;;;955                        p_spoke->FirstPtr = p_tmr;
00009c  6010              STR      r0,[r2,#0]
00009e  e004              B        |L11.170|
                  |L11.160|
;;;956                    } else {                                    /* Insert in between 2 timers already in the list         */
;;;957                        p_tmr0            = p_tmr1->PrevPtr;
0000a0  694b              LDR      r3,[r1,#0x14]
;;;958                        p_tmr->PrevPtr    = p_tmr0;
0000a2  6143              STR      r3,[r0,#0x14]
;;;959                        p_tmr->NextPtr    = p_tmr1;
0000a4  6101              STR      r1,[r0,#0x10]
;;;960                        p_tmr0->NextPtr   = p_tmr;
0000a6  6118              STR      r0,[r3,#0x10]
;;;961                        p_tmr1->PrevPtr   = p_tmr;
0000a8  6148              STR      r0,[r1,#0x14]
                  |L11.170|
;;;962                    }
;;;963                    p_tmr1 = (OS_TMR *)0;                       /* Break loop                                             */
0000aa  2100              MOVS     r1,#0
                  |L11.172|
0000ac  2900              CMP      r1,#0                 ;938
0000ae  d1dc              BNE      |L11.106|
;;;964                }
;;;965            }
;;;966            p_spoke->NbrEntries++;
0000b0  8896              LDRH     r6,[r2,#4]
0000b2  1c76              ADDS     r6,r6,#1
0000b4  8096              STRH     r6,[r2,#4]
                  |L11.182|
;;;967        }
;;;968        if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {     /* Keep track of maximum number of entries in each spoke  */
0000b6  88d6              LDRH     r6,[r2,#6]
0000b8  8897              LDRH     r7,[r2,#4]
0000ba  42be              CMP      r6,r7
0000bc  da01              BGE      |L11.194|
;;;969            p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
0000be  8896              LDRH     r6,[r2,#4]
0000c0  80d6              STRH     r6,[r2,#6]
                  |L11.194|
;;;970        }
;;;971    }
0000c2  bdf0              POP      {r4-r7,pc}
;;;972    
                          ENDP

                  |L11.196|
                          DCD      OSTmrTickCtr
                  |L11.200|
                          DCD      OSCfg_TmrWheelSize
                  |L11.204|
                          DCD      OSCfg_TmrWheel

                          AREA ||i.OS_TmrResetPeak||, CODE, READONLY, ALIGN=2

                  OS_TmrResetPeak PROC
;;;987    
;;;988    void  OS_TmrResetPeak (void)
000000  2000              MOVS     r0,#0
;;;989    {
;;;990        OS_TMR_SPOKE     *p_spoke;
;;;991        OS_TMR_SPOKE_IX   i;
;;;992    
;;;993    
;;;994    
;;;995        for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
000002  e006              B        |L12.18|
                  |L12.4|
;;;996            p_spoke                = (OS_TMR_SPOKE *)&OSCfg_TmrWheel[i];
000004  4a05              LDR      r2,|L12.28|
000006  eb0201c0          ADD      r1,r2,r0,LSL #3
;;;997            p_spoke->NbrEntriesMax = (OS_OBJ_QTY    )0u;
00000a  2200              MOVS     r2,#0
00000c  80ca              STRH     r2,[r1,#6]
00000e  1c42              ADDS     r2,r0,#1              ;995
000010  b290              UXTH     r0,r2                 ;995
                  |L12.18|
000012  4a03              LDR      r2,|L12.32|
000014  8812              LDRH     r2,[r2,#0]            ;995  ; OSCfg_TmrWheelSize
000016  4290              CMP      r0,r2                 ;995
000018  dbf4              BLT      |L12.4|
;;;998        }
;;;999    }
00001a  4770              BX       lr
;;;1000   
                          ENDP

                  |L12.28|
                          DCD      OSCfg_TmrWheel
                  |L12.32|
                          DCD      OSCfg_TmrWheelSize

                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;1063   
;;;1064   void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;1065   {
;;;1066       CPU_BOOLEAN          done;
;;;1067       OS_ERR               err;
;;;1068       OS_TMR_CALLBACK_PTR  p_fnct;
;;;1069       OS_TMR_SPOKE        *p_spoke;
;;;1070       OS_TMR              *p_tmr;
;;;1071       OS_TMR              *p_tmr_next;
;;;1072       OS_TMR_SPOKE_IX      spoke;
;;;1073       CPU_TS               ts;
;;;1074       CPU_TS               ts_start;
;;;1075       CPU_TS               ts_end;
;;;1076   
;;;1077   
;;;1078   
;;;1079       p_arg = p_arg;                                               /* Not using 'p_arg', prevent compiler warning       */
000002  bf00              NOP      
;;;1080       while (DEF_ON) {
000004  e053              B        |L13.174|
                  |L13.6|
;;;1081           (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
000006  ab01              ADD      r3,sp,#4
000008  466a              MOV      r2,sp
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       OSTaskSemPend
;;;1082                               (OS_OPT  )OS_OPT_PEND_BLOCKING,
;;;1083                               (CPU_TS *)&ts,
;;;1084                               (OS_ERR *)&err);
;;;1085   
;;;1086           OSSchedLock(&err);
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       OSSchedLock
;;;1087           ts_start = OS_TS_GET();
000018  f7fffffe          BL       CPU_TS_TmrRd
00001c  4606              MOV      r6,r0
;;;1088           OSTmrTickCtr++;                                          /* Increment the current time                        */
00001e  4824              LDR      r0,|L13.176|
000020  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
000022  1c40              ADDS     r0,r0,#1
000024  4922              LDR      r1,|L13.176|
000026  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1089           spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
00002c  4921              LDR      r1,|L13.180|
00002e  8809              LDRH     r1,[r1,#0]  ; OSCfg_TmrWheelSize
000030  fbb0f2f1          UDIV     r2,r0,r1
000034  fb010012          MLS      r0,r1,r2,r0
000038  fa1ffa80          UXTH     r10,r0
;;;1090           p_spoke  = &OSCfg_TmrWheel[spoke];
00003c  481e              LDR      r0,|L13.184|
00003e  eb0008ca          ADD      r8,r0,r10,LSL #3
;;;1091           p_tmr    = p_spoke->FirstPtr;
000042  f8d84000          LDR      r4,[r8,#0]
;;;1092           done     = DEF_FALSE;
000046  f04f0b00          MOV      r11,#0
;;;1093           while (done == DEF_FALSE) {
00004a  e021              B        |L13.144|
                  |L13.76|
;;;1094               if (p_tmr != (OS_TMR *)0) {
00004c  b1f4              CBZ      r4,|L13.140|
;;;1095                   p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
00004e  f8d49010          LDR      r9,[r4,#0x10]
;;;1096                                                                    /* ... timer could get unlinked from the wheel.      */
;;;1097                   if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
000052  4917              LDR      r1,|L13.176|
000054  69a0              LDR      r0,[r4,#0x18]
000056  6809              LDR      r1,[r1,#0]  ; OSTmrTickCtr
000058  4288              CMP      r0,r1
00005a  d114              BNE      |L13.134|
;;;1098                       OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       OS_TmrUnlink
;;;1099                       if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
000062  8d20              LDRH     r0,[r4,#0x28]
000064  2802              CMP      r0,#2
000066  d104              BNE      |L13.114|
;;;1100                           OS_TmrLink(p_tmr,
000068  2101              MOVS     r1,#1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OS_TmrLink
000070  e002              B        |L13.120|
                  |L13.114|
;;;1101                                      OS_OPT_LINK_PERIODIC);        /* Recalculate new position of timer in wheel        */
;;;1102                       } else {
;;;1103                           p_tmr->State = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
000072  2003              MOVS     r0,#3
000074  f884002a          STRB     r0,[r4,#0x2a]
                  |L13.120|
;;;1104                       }
;;;1105                       p_fnct = p_tmr->CallbackPtr;                 /* Execute callback function if available            */
000078  68a5              LDR      r5,[r4,#8]
;;;1106                       if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
00007a  b115              CBZ      r5,|L13.130|
;;;1107                           (*p_fnct)((void *)p_tmr,
00007c  4620              MOV      r0,r4
00007e  68e1              LDR      r1,[r4,#0xc]
000080  47a8              BLX      r5
                  |L13.130|
;;;1108                                     p_tmr->CallbackPtrArg);
;;;1109                       }
;;;1110                       p_tmr = p_tmr_next;                          /* See if next timer matches                         */
000082  464c              MOV      r4,r9
000084  e004              B        |L13.144|
                  |L13.134|
;;;1111                   } else {
;;;1112                       done  = DEF_TRUE;
000086  f04f0b01          MOV      r11,#1
00008a  e001              B        |L13.144|
                  |L13.140|
;;;1113                   }
;;;1114               } else {
;;;1115                   done = DEF_TRUE;
00008c  f04f0b01          MOV      r11,#1
                  |L13.144|
000090  f1bb0f00          CMP      r11,#0                ;1093
000094  d0da              BEQ      |L13.76|
;;;1116               }
;;;1117           }
;;;1118           ts_end = OS_TS_GET() - ts_start;                         /* Measure execution time of timer task              */
000096  f7fffffe          BL       CPU_TS_TmrRd
00009a  1b87              SUBS     r7,r0,r6
;;;1119           OSSchedUnlock(&err);
00009c  a801              ADD      r0,sp,#4
00009e  f7fffffe          BL       OSSchedUnlock
;;;1120           if (OSTmrTaskTimeMax < ts_end) {
0000a2  4806              LDR      r0,|L13.188|
0000a4  6800              LDR      r0,[r0,#0]  ; OSTmrTaskTimeMax
0000a6  42b8              CMP      r0,r7
0000a8  d201              BCS      |L13.174|
;;;1121               OSTmrTaskTimeMax = ts_end;
0000aa  4804              LDR      r0,|L13.188|
0000ac  6007              STR      r7,[r0,#0]  ; OSTmrTaskTimeMax
                  |L13.174|
0000ae  e7aa              B        |L13.6|
;;;1122           }
;;;1123       }
;;;1124   }
;;;1125   
                          ENDP

                  |L13.176|
                          DCD      OSTmrTickCtr
                  |L13.180|
                          DCD      OSCfg_TmrWheelSize
                  |L13.184|
                          DCD      OSCfg_TmrWheel
                  |L13.188|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;1016   
;;;1017   void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1018   {
;;;1019       OS_TMR_SPOKE    *p_spoke;
;;;1020       OS_TMR          *p_tmr1;
;;;1021       OS_TMR          *p_tmr2;
;;;1022       OS_TMR_SPOKE_IX  spoke;
;;;1023   
;;;1024   
;;;1025   
;;;1026       spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
000002  4e11              LDR      r6,|L14.72|
000004  8836              LDRH     r6,[r6,#0]  ; OSCfg_TmrWheelSize
000006  6985              LDR      r5,[r0,#0x18]
000008  fbb5f7f6          UDIV     r7,r5,r6
00000c  fb065517          MLS      r5,r6,r7,r5
000010  b2ac              UXTH     r4,r5
;;;1027       p_spoke = &OSCfg_TmrWheel[spoke];
000012  4d0e              LDR      r5,|L14.76|
000014  eb0502c4          ADD      r2,r5,r4,LSL #3
;;;1028   
;;;1029       if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
000018  6815              LDR      r5,[r2,#0]
00001a  4285              CMP      r5,r0
00001c  d105              BNE      |L14.42|
;;;1030           p_tmr1            = (OS_TMR *)p_tmr->NextPtr;
00001e  6901              LDR      r1,[r0,#0x10]
;;;1031           p_spoke->FirstPtr = (OS_TMR *)p_tmr1;
000020  6011              STR      r1,[r2,#0]
;;;1032           if (p_tmr1 != (OS_TMR *)0) {
000022  b139              CBZ      r1,|L14.52|
;;;1033               p_tmr1->PrevPtr = (OS_TMR *)0;
000024  2500              MOVS     r5,#0
000026  614d              STR      r5,[r1,#0x14]
000028  e004              B        |L14.52|
                  |L14.42|
;;;1034           }
;;;1035       } else {
;;;1036           p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
00002a  6941              LDR      r1,[r0,#0x14]
;;;1037           p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
00002c  6903              LDR      r3,[r0,#0x10]
;;;1038           p_tmr1->NextPtr = p_tmr2;
00002e  610b              STR      r3,[r1,#0x10]
;;;1039           if (p_tmr2 != (OS_TMR *)0) {
000030  b103              CBZ      r3,|L14.52|
;;;1040               p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
000032  6159              STR      r1,[r3,#0x14]
                  |L14.52|
;;;1041           }
;;;1042       }
;;;1043       p_tmr->State   = OS_TMR_STATE_STOPPED;
000034  2501              MOVS     r5,#1
000036  f880502a          STRB     r5,[r0,#0x2a]
;;;1044       p_tmr->NextPtr = (OS_TMR *)0;
00003a  2500              MOVS     r5,#0
00003c  6105              STR      r5,[r0,#0x10]
;;;1045       p_tmr->PrevPtr = (OS_TMR *)0;
00003e  6145              STR      r5,[r0,#0x14]
;;;1046       p_spoke->NbrEntries--;
000040  8895              LDRH     r5,[r2,#4]
000042  1e6d              SUBS     r5,r5,#1
000044  8095              STRH     r5,[r2,#4]
;;;1047   }
000046  bdf0              POP      {r4-r7,pc}
;;;1048   
                          ENDP

                  |L14.72|
                          DCD      OSCfg_TmrWheelSize
                  |L14.76|
                          DCD      OSCfg_TmrWheel
