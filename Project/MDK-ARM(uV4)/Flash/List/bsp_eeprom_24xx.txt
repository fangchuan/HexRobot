; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\bsp_stm32f4xx\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;31     */
;;;32     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;35     	{
;;;36     		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;37     	}
;;;38     	else
;;;39     	{
;;;40     		/* 失败后，切记发送I2C总线停止信号 */
;;;41     		i2c_Stop();
;;;42     		return 0;
;;;43     	}
;;;44     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;42
000014  e7fa              B        |L1.12|
;;;45     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;56     */
;;;57     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;59     	uint16_t i;
;;;60     
;;;61     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;62     
;;;63     	/* 第1步：发起I2C总线启动信号 */
;;;64     	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;65     
;;;66     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;67     	#if EE_ADDR_A8 == 1
;;;68     		i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;69     	#else
;;;70     		i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;71     	#endif
;;;72     
;;;73     	/* 第3步：发送ACK */
;;;74     	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L2.28|
;;;75     	{
;;;76     		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e02c              B        |L2.118|
                  |L2.28|
;;;77     	}
;;;78     
;;;79     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;80     	if (EE_ADDR_BYTES == 1)
;;;81     	{
;;;82     		i2c_SendByte((uint8_t)_usAddress);
;;;83     		if (i2c_WaitAck() != 0)
;;;84     		{
;;;85     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;86     		}
;;;87     	}
;;;88     	else
;;;89     	{
;;;90     		i2c_SendByte(_usAddress >> 8);
00001c  1228              ASRS     r0,r5,#8
00001e  f7fffffe          BL       i2c_SendByte
;;;91     		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L2.42|
;;;92     		{
;;;93     			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e025              B        |L2.118|
                  |L2.42|
;;;94     		}
;;;95     
;;;96     		i2c_SendByte(_usAddress);
00002a  b2e8              UXTB     r0,r5
00002c  f7fffffe          BL       i2c_SendByte
;;;97     		if (i2c_WaitAck() != 0)
000030  f7fffffe          BL       i2c_WaitAck
000034  b100              CBZ      r0,|L2.56|
;;;98     		{
;;;99     			goto cmd_fail;	/* EEPROM器件无应答 */
000036  e01e              B        |L2.118|
                  |L2.56|
;;;100    		}
;;;101    	}
;;;102    
;;;103    	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;104    	i2c_Start();
000038  f7fffffe          BL       i2c_Start
;;;105    
;;;106    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;107    	#if EE_ADDR_A8 == 1
;;;108    		i2c_SendByte(EE_DEV_ADDR | I2C_RD | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;109    	#else		
;;;110    		i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是写指令 */
00003c  20a1              MOVS     r0,#0xa1
00003e  f7fffffe          BL       i2c_SendByte
;;;111    	#endif	
;;;112    
;;;113    	/* 第8步：发送ACK */
;;;114    	if (i2c_WaitAck() != 0)
000042  f7fffffe          BL       i2c_WaitAck
000046  b100              CBZ      r0,|L2.74|
;;;115    	{
;;;116    		goto cmd_fail;	/* EEPROM器件无应答 */
000048  e015              B        |L2.118|
                  |L2.74|
;;;117    	}
;;;118    
;;;119    	/* 第9步：循环读取数据 */
;;;120    	for (i = 0; i < _usSize; i++)
00004a  2400              MOVS     r4,#0
00004c  e00c              B        |L2.104|
                  |L2.78|
;;;121    	{
;;;122    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
00004e  f7fffffe          BL       i2c_ReadByte
000052  5538              STRB     r0,[r7,r4]
;;;123    
;;;124    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;125    		if (i != _usSize - 1)
000054  1e70              SUBS     r0,r6,#1
000056  42a0              CMP      r0,r4
000058  d002              BEQ      |L2.96|
;;;126    		{
;;;127    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00005a  f7fffffe          BL       i2c_Ack
00005e  e001              B        |L2.100|
                  |L2.96|
;;;128    		}
;;;129    		else
;;;130    		{
;;;131    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000060  f7fffffe          BL       i2c_NAck
                  |L2.100|
000064  1c60              ADDS     r0,r4,#1              ;120
000066  b284              UXTH     r4,r0                 ;120
                  |L2.104|
000068  42b4              CMP      r4,r6                 ;120
00006a  dbf0              BLT      |L2.78|
;;;132    		}
;;;133    	}
;;;134    	/* 发送I2C总线停止信号 */
;;;135    	i2c_Stop();
00006c  f7fffffe          BL       i2c_Stop
;;;136    	return 1;	/* 执行成功 */
000070  2001              MOVS     r0,#1
                  |L2.114|
;;;137    
;;;138    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;139    	/* 发送I2C总线停止信号 */
;;;140    	i2c_Stop();
;;;141    	return 0;
;;;142    }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L2.118|
000076  f7fffffe          BL       i2c_Stop
00007a  2000              MOVS     r0,#0                 ;141
00007c  e7f9              B        |L2.114|
;;;143    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;153    */
;;;154    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;155    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;156    	uint16_t i,m;
;;;157    	uint16_t usAddr;
;;;158    
;;;159    	/*
;;;160    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;161    		对于24xx02，page size = 8
;;;162    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;163    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;164    	*/
;;;165    
;;;166    	usAddr = _usAddress;
00000a  4646              MOV      r6,r8
;;;167    	for (i = 0; i < _usSize; i++)
00000c  2500              MOVS     r5,#0
00000e  e033              B        |L3.120|
                  |L3.16|
;;;168    	{
;;;169    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;170    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000010  b115              CBZ      r5,|L3.24|
000012  f006003f          AND      r0,r6,#0x3f
000016  bb20              CBNZ     r0,|L3.98|
                  |L3.24|
;;;171    		{
;;;172    			/*　第０步：发停止信号，启动内部写操作　*/
;;;173    			i2c_Stop();
000018  f7fffffe          BL       i2c_Stop
;;;174    
;;;175    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;176    				CLK频率为200KHz时，查询次数为30次左右
;;;177    			*/
;;;178    			for (m = 0; m < 1000; m++)
00001c  2400              MOVS     r4,#0
00001e  e00a              B        |L3.54|
                  |L3.32|
;;;179    			{
;;;180    				/* 第1步：发起I2C总线启动信号 */
;;;181    				i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;182    
;;;183    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;184    				
;;;185    				#if EE_ADDR_A8 == 1
;;;186    					i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;187    				#else				
;;;188    					i2c_SendByte(EE_DEV_ADDR | I2C_WR);
000024  20a0              MOVS     r0,#0xa0
000026  f7fffffe          BL       i2c_SendByte
;;;189    				#endif
;;;190    
;;;191    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;192    				if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b900              CBNZ     r0,|L3.50|
;;;193    				{
;;;194    					break;
000030  e004              B        |L3.60|
                  |L3.50|
000032  1c60              ADDS     r0,r4,#1              ;178
000034  b284              UXTH     r4,r0                 ;178
                  |L3.54|
000036  f5b47f7a          CMP      r4,#0x3e8             ;178
00003a  dbf1              BLT      |L3.32|
                  |L3.60|
00003c  bf00              NOP      
;;;195    				}
;;;196    			}
;;;197    			if (m  == 1000)
00003e  f5b47f7a          CMP      r4,#0x3e8
000042  d100              BNE      |L3.70|
;;;198    			{
;;;199    				goto cmd_fail;	/* EEPROM器件写超时 */
000044  e036              B        |L3.180|
                  |L3.70|
;;;200    			}
;;;201    
;;;202    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;203    			if (EE_ADDR_BYTES == 1)
;;;204    			{
;;;205    				i2c_SendByte((uint8_t)usAddr);
;;;206    				if (i2c_WaitAck() != 0)
;;;207    				{
;;;208    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;209    				}
;;;210    			}
;;;211    			else
;;;212    			{
;;;213    				i2c_SendByte(usAddr >> 8);
000046  1230              ASRS     r0,r6,#8
000048  f7fffffe          BL       i2c_SendByte
;;;214    				if (i2c_WaitAck() != 0)
00004c  f7fffffe          BL       i2c_WaitAck
000050  b100              CBZ      r0,|L3.84|
;;;215    				{
;;;216    					goto cmd_fail;	/* EEPROM器件无应答 */
000052  e02f              B        |L3.180|
                  |L3.84|
;;;217    				}
;;;218    
;;;219    				i2c_SendByte(usAddr);
000054  b2f0              UXTB     r0,r6
000056  f7fffffe          BL       i2c_SendByte
;;;220    				if (i2c_WaitAck() != 0)
00005a  f7fffffe          BL       i2c_WaitAck
00005e  b100              CBZ      r0,|L3.98|
;;;221    				{
;;;222    					goto cmd_fail;	/* EEPROM器件无应答 */
000060  e028              B        |L3.180|
                  |L3.98|
;;;223    				}
;;;224    			}
;;;225    		}
;;;226    
;;;227    		/* 第6步：开始写入数据 */
;;;228    		i2c_SendByte(_pWriteBuf[i]);
000062  5d78              LDRB     r0,[r7,r5]
000064  f7fffffe          BL       i2c_SendByte
;;;229    
;;;230    		/* 第7步：发送ACK */
;;;231    		if (i2c_WaitAck() != 0)
000068  f7fffffe          BL       i2c_WaitAck
00006c  b100              CBZ      r0,|L3.112|
;;;232    		{
;;;233    			goto cmd_fail;	/* EEPROM器件无应答 */
00006e  e021              B        |L3.180|
                  |L3.112|
;;;234    		}
;;;235    
;;;236    		usAddr++;	/* 地址增1 */
000070  1c70              ADDS     r0,r6,#1
000072  b286              UXTH     r6,r0
000074  1c68              ADDS     r0,r5,#1              ;167
000076  b285              UXTH     r5,r0                 ;167
                  |L3.120|
000078  454d              CMP      r5,r9                 ;167
00007a  dbc9              BLT      |L3.16|
;;;237    	}
;;;238    
;;;239    	/* 命令执行成功，发送I2C总线停止信号 */
;;;240    	i2c_Stop();
00007c  f7fffffe          BL       i2c_Stop
;;;241    
;;;242    	/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;243    		CLK频率为200KHz时，查询次数为30次左右
;;;244    	*/
;;;245    	for (m = 0; m < 1000; m++)
000080  2400              MOVS     r4,#0
000082  e00a              B        |L3.154|
                  |L3.132|
;;;246    	{
;;;247    		/* 第1步：发起I2C总线启动信号 */
;;;248    		i2c_Start();
000084  f7fffffe          BL       i2c_Start
;;;249    
;;;250    		/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */	
;;;251    		#if EE_ADDR_A8 == 1
;;;252    			i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;253    		#else		
;;;254    			i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000088  20a0              MOVS     r0,#0xa0
00008a  f7fffffe          BL       i2c_SendByte
;;;255    		#endif
;;;256    
;;;257    		/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;258    		if (i2c_WaitAck() == 0)
00008e  f7fffffe          BL       i2c_WaitAck
000092  b900              CBNZ     r0,|L3.150|
;;;259    		{
;;;260    			break;
000094  e004              B        |L3.160|
                  |L3.150|
000096  1c60              ADDS     r0,r4,#1              ;245
000098  b284              UXTH     r4,r0                 ;245
                  |L3.154|
00009a  f5b47f7a          CMP      r4,#0x3e8             ;245
00009e  dbf1              BLT      |L3.132|
                  |L3.160|
0000a0  bf00              NOP      
;;;261    		}
;;;262    	}
;;;263    	if (m  == 1000)
0000a2  f5b47f7a          CMP      r4,#0x3e8
0000a6  d100              BNE      |L3.170|
;;;264    	{
;;;265    		goto cmd_fail;	/* EEPROM器件写超时 */
0000a8  e004              B        |L3.180|
                  |L3.170|
;;;266    	}
;;;267    
;;;268    	/* 命令执行成功，发送I2C总线停止信号 */
;;;269    	i2c_Stop();	
0000aa  f7fffffe          BL       i2c_Stop
;;;270    
;;;271    	return 1;
0000ae  2001              MOVS     r0,#1
                  |L3.176|
;;;272    
;;;273    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;274    	/* 发送I2C总线停止信号 */
;;;275    	i2c_Stop();
;;;276    	return 0;
;;;277    }
0000b0  e8bd87f0          POP      {r4-r10,pc}
                  |L3.180|
0000b4  f7fffffe          BL       i2c_Stop
0000b8  2000              MOVS     r0,#0                 ;276
0000ba  e7f9              B        |L3.176|
;;;278    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 144
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____RRX|
#line 300
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
