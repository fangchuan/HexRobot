; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f4xx_fsmc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\stm32f4xx_fsmc.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=2

                  FSMC_ClearFlag PROC
;;;979      */
;;;980    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  2810              CMP      r0,#0x10
;;;981    {
;;;982     /* Check the parameters */
;;;983      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;984      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;985        
;;;986      if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d107              BNE      |L1.20|
;;;987      {
;;;988        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  438a              BICS     r2,r2,r1
00000c  f04f4320          MOV      r3,#0xa0000000
000010  665a              STR      r2,[r3,#0x64]
000012  e012              B        |L1.58|
                  |L1.20|
;;;989      }  
;;;990      else if(FSMC_Bank == FSMC_Bank3_NAND)
000014  f5b07f80          CMP      r0,#0x100
000018  d107              BNE      |L1.42|
;;;991      {
;;;992        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
00001a  4a08              LDR      r2,|L1.60|
00001c  6812              LDR      r2,[r2,#0]
00001e  438a              BICS     r2,r2,r1
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32084          STR      r2,[r3,#0x84]
000028  e007              B        |L1.58|
                  |L1.42|
;;;993      }
;;;994      /* FSMC_Bank4_PCCARD*/
;;;995      else
;;;996      {
;;;997        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00002a  4a04              LDR      r2,|L1.60|
00002c  3220              ADDS     r2,r2,#0x20
00002e  6812              LDR      r2,[r2,#0]
000030  438a              BICS     r2,r2,r1
000032  f04f4320          MOV      r3,#0xa0000000
000036  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.58|
;;;998      }
;;;999    }
00003a  4770              BX       lr
;;;1000   
                          ENDP

                  |L1.60|
                          DCD      0xa0000084

                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  FSMC_ClearITPendingBit PROC
;;;1065     */
;;;1066   void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  2810              CMP      r0,#0x10
;;;1067   {
;;;1068     /* Check the parameters */
;;;1069     assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;1070     assert_param(IS_FSMC_IT(FSMC_IT));
;;;1071       
;;;1072     if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d108              BNE      |L2.22|
;;;1073     {
;;;1074       FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  ea2202d1          BIC      r2,r2,r1,LSR #3
00000e  f04f4320          MOV      r3,#0xa0000000
000012  665a              STR      r2,[r3,#0x64]
000014  e014              B        |L2.64|
                  |L2.22|
;;;1075     }  
;;;1076     else if(FSMC_Bank == FSMC_Bank3_NAND)
000016  f5b07f80          CMP      r0,#0x100
00001a  d108              BNE      |L2.46|
;;;1077     {
;;;1078       FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
00001c  4a09              LDR      r2,|L2.68|
00001e  6812              LDR      r2,[r2,#0]
000020  ea2202d1          BIC      r2,r2,r1,LSR #3
000024  f04f4320          MOV      r3,#0xa0000000
000028  f8c32084          STR      r2,[r3,#0x84]
00002c  e008              B        |L2.64|
                  |L2.46|
;;;1079     }
;;;1080     /* FSMC_Bank4_PCCARD*/
;;;1081     else
;;;1082     {
;;;1083       FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00002e  4a05              LDR      r2,|L2.68|
000030  3220              ADDS     r2,r2,#0x20
000032  6812              LDR      r2,[r2,#0]
000034  ea2202d1          BIC      r2,r2,r1,LSR #3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  f8c320a4          STR      r2,[r3,#0xa4]
                  |L2.64|
;;;1084     }
;;;1085   }
000040  4770              BX       lr
;;;1086   
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0xa0000084

                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=2

                  FSMC_GetECC PROC
;;;625      */
;;;626    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  4601              MOV      r1,r0
;;;627    {
;;;628      uint32_t eccval = 0x00000000;
000002  2000              MOVS     r0,#0
;;;629      
;;;630      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2910              CMP      r1,#0x10
000006  d103              BNE      |L3.16|
;;;631      {
;;;632        /* Get the ECCR2 register value */
;;;633        eccval = FSMC_Bank2->ECCR2;
000008  f04f4220          MOV      r2,#0xa0000000
00000c  6f50              LDR      r0,[r2,#0x74]
00000e  e001              B        |L3.20|
                  |L3.16|
;;;634      }
;;;635      else
;;;636      {
;;;637        /* Get the ECCR3 register value */
;;;638        eccval = FSMC_Bank3->ECCR3;
000010  4a01              LDR      r2,|L3.24|
000012  6810              LDR      r0,[r2,#0]
                  |L3.20|
;;;639      }
;;;640      /* Return the error correction code value */
;;;641      return(eccval);
;;;642    }
000014  4770              BX       lr
;;;643    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0xa0000094

                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FSMC_GetFlagStatus PROC
;;;929      */
;;;930    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;931    {
000002  4602              MOV      r2,r0
;;;932      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;933      uint32_t tmpsr = 0x00000000;
000006  2300              MOVS     r3,#0
;;;934      
;;;935      /* Check the parameters */
;;;936      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;937      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;938      
;;;939      if(FSMC_Bank == FSMC_Bank2_NAND)
000008  2a10              CMP      r2,#0x10
00000a  d103              BNE      |L4.20|
;;;940      {
;;;941        tmpsr = FSMC_Bank2->SR2;
00000c  f04f4420          MOV      r4,#0xa0000000
000010  6e63              LDR      r3,[r4,#0x64]
000012  e008              B        |L4.38|
                  |L4.20|
;;;942      }  
;;;943      else if(FSMC_Bank == FSMC_Bank3_NAND)
000014  f5b27f80          CMP      r2,#0x100
000018  d102              BNE      |L4.32|
;;;944      {
;;;945        tmpsr = FSMC_Bank3->SR3;
00001a  4c06              LDR      r4,|L4.52|
00001c  6823              LDR      r3,[r4,#0]
00001e  e002              B        |L4.38|
                  |L4.32|
;;;946      }
;;;947      /* FSMC_Bank4_PCCARD*/
;;;948      else
;;;949      {
;;;950        tmpsr = FSMC_Bank4->SR4;
000020  4c04              LDR      r4,|L4.52|
000022  3420              ADDS     r4,r4,#0x20
000024  6823              LDR      r3,[r4,#0]
                  |L4.38|
;;;951      } 
;;;952      
;;;953      /* Get the flag status */
;;;954      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000026  ea030401          AND      r4,r3,r1
00002a  b10c              CBZ      r4,|L4.48|
;;;955      {
;;;956        bitstatus = SET;
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L4.50|
                  |L4.48|
;;;957      }
;;;958      else
;;;959      {
;;;960        bitstatus = RESET;
000030  2000              MOVS     r0,#0
                  |L4.50|
;;;961      }
;;;962      /* Return the flag status */
;;;963      return bitstatus;
;;;964    }
000032  bd10              POP      {r4,pc}
;;;965    
                          ENDP

                  |L4.52|
                          DCD      0xa0000084

                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=2

                  FSMC_GetITStatus PROC
;;;1014     */
;;;1015   ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1016   {
000002  4602              MOV      r2,r0
;;;1017     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1018     uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
00000a  2500              MOVS     r5,#0
;;;1019     
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;1022     assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;1023     
;;;1024     if(FSMC_Bank == FSMC_Bank2_NAND)
00000c  2a10              CMP      r2,#0x10
00000e  d103              BNE      |L5.24|
;;;1025     {
;;;1026       tmpsr = FSMC_Bank2->SR2;
000010  f04f4620          MOV      r6,#0xa0000000
000014  6e73              LDR      r3,[r6,#0x64]
000016  e008              B        |L5.42|
                  |L5.24|
;;;1027     }  
;;;1028     else if(FSMC_Bank == FSMC_Bank3_NAND)
000018  f5b27f80          CMP      r2,#0x100
00001c  d102              BNE      |L5.36|
;;;1029     {
;;;1030       tmpsr = FSMC_Bank3->SR3;
00001e  4e08              LDR      r6,|L5.64|
000020  6833              LDR      r3,[r6,#0]
000022  e002              B        |L5.42|
                  |L5.36|
;;;1031     }
;;;1032     /* FSMC_Bank4_PCCARD*/
;;;1033     else
;;;1034     {
;;;1035       tmpsr = FSMC_Bank4->SR4;
000024  4e06              LDR      r6,|L5.64|
000026  3620              ADDS     r6,r6,#0x20
000028  6833              LDR      r3,[r6,#0]
                  |L5.42|
;;;1036     } 
;;;1037     
;;;1038     itstatus = tmpsr & FSMC_IT;
00002a  ea030401          AND      r4,r3,r1
;;;1039     
;;;1040     itenable = tmpsr & (FSMC_IT >> 3);
00002e  ea0305d1          AND      r5,r3,r1,LSR #3
;;;1041     if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000032  b114              CBZ      r4,|L5.58|
000034  b10d              CBZ      r5,|L5.58|
;;;1042     {
;;;1043       bitstatus = SET;
000036  2001              MOVS     r0,#1
000038  e000              B        |L5.60|
                  |L5.58|
;;;1044     }
;;;1045     else
;;;1046     {
;;;1047       bitstatus = RESET;
00003a  2000              MOVS     r0,#0
                  |L5.60|
;;;1048     }
;;;1049     return bitstatus; 
;;;1050   }
00003c  bd70              POP      {r4-r6,pc}
;;;1051   
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0xa0000084

                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=2

                  FSMC_ITConfig PROC
;;;869      */
;;;870    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;871    {
;;;872      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;873      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;874      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;875      
;;;876      if (NewState != DISABLE)
000002  b1ea              CBZ      r2,|L6.64|
;;;877      {
;;;878        /* Enable the selected FSMC_Bank2 interrupts */
;;;879        if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d107              BNE      |L6.24|
;;;880        {
;;;881          FSMC_Bank2->SR2 |= FSMC_IT;
000008  f04f4320          MOV      r3,#0xa0000000
00000c  6e5b              LDR      r3,[r3,#0x64]
00000e  430b              ORRS     r3,r3,r1
000010  f04f4420          MOV      r4,#0xa0000000
000014  6663              STR      r3,[r4,#0x64]
000016  e030              B        |L6.122|
                  |L6.24|
;;;882        }
;;;883        /* Enable the selected FSMC_Bank3 interrupts */
;;;884        else if (FSMC_Bank == FSMC_Bank3_NAND)
000018  f5b07f80          CMP      r0,#0x100
00001c  d107              BNE      |L6.46|
;;;885        {
;;;886          FSMC_Bank3->SR3 |= FSMC_IT;
00001e  4b17              LDR      r3,|L6.124|
000020  681b              LDR      r3,[r3,#0]
000022  430b              ORRS     r3,r3,r1
000024  f04f4420          MOV      r4,#0xa0000000
000028  f8c43084          STR      r3,[r4,#0x84]
00002c  e025              B        |L6.122|
                  |L6.46|
;;;887        }
;;;888        /* Enable the selected FSMC_Bank4 interrupts */
;;;889        else
;;;890        {
;;;891          FSMC_Bank4->SR4 |= FSMC_IT;    
00002e  4b13              LDR      r3,|L6.124|
000030  3320              ADDS     r3,r3,#0x20
000032  681b              LDR      r3,[r3,#0]
000034  430b              ORRS     r3,r3,r1
000036  f04f4420          MOV      r4,#0xa0000000
00003a  f8c430a4          STR      r3,[r4,#0xa4]
00003e  e01c              B        |L6.122|
                  |L6.64|
;;;892        }
;;;893      }
;;;894      else
;;;895      {
;;;896        /* Disable the selected FSMC_Bank2 interrupts */
;;;897        if(FSMC_Bank == FSMC_Bank2_NAND)
000040  2810              CMP      r0,#0x10
000042  d107              BNE      |L6.84|
;;;898        {
;;;899          
;;;900          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
000044  f04f4320          MOV      r3,#0xa0000000
000048  6e5b              LDR      r3,[r3,#0x64]
00004a  438b              BICS     r3,r3,r1
00004c  f04f4420          MOV      r4,#0xa0000000
000050  6663              STR      r3,[r4,#0x64]
000052  e012              B        |L6.122|
                  |L6.84|
;;;901        }
;;;902        /* Disable the selected FSMC_Bank3 interrupts */
;;;903        else if (FSMC_Bank == FSMC_Bank3_NAND)
000054  f5b07f80          CMP      r0,#0x100
000058  d107              BNE      |L6.106|
;;;904        {
;;;905          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
00005a  4b08              LDR      r3,|L6.124|
00005c  681b              LDR      r3,[r3,#0]
00005e  438b              BICS     r3,r3,r1
000060  f04f4420          MOV      r4,#0xa0000000
000064  f8c43084          STR      r3,[r4,#0x84]
000068  e007              B        |L6.122|
                  |L6.106|
;;;906        }
;;;907        /* Disable the selected FSMC_Bank4 interrupts */
;;;908        else
;;;909        {
;;;910          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
00006a  4b04              LDR      r3,|L6.124|
00006c  3320              ADDS     r3,r3,#0x20
00006e  681b              LDR      r3,[r3,#0]
000070  438b              BICS     r3,r3,r1
000072  f04f4420          MOV      r4,#0xa0000000
000076  f8c430a4          STR      r3,[r4,#0xa4]
                  |L6.122|
;;;911        }
;;;912      }
;;;913    }
00007a  bd10              POP      {r4,pc}
;;;914    
                          ENDP

                  |L6.124|
                          DCD      0xa0000084

                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;546      */
;;;547    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L7.42|
;;;548    {
;;;549      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;550      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;551      
;;;552      if (NewState != DISABLE)
;;;553      {
;;;554        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;555        if(FSMC_Bank == FSMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L7.24|
;;;556        {
;;;557          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420204          ORR      r2,r2,#4
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01b              B        |L7.80|
                  |L7.24|
;;;558        }
;;;559        else
;;;560        {
;;;561          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
000018  4a0e              LDR      r2,|L7.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420204          ORR      r2,r2,#4
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e012              B        |L7.80|
                  |L7.42|
;;;562        }
;;;563      }
;;;564      else
;;;565      {
;;;566        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;567        if(FSMC_Bank == FSMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L7.64|
;;;568        {
;;;569          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L7.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e007              B        |L7.80|
                  |L7.64|
;;;570        }
;;;571        else
;;;572        {
;;;573          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000040  4a04              LDR      r2,|L7.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L7.88|
000046  401a              ANDS     r2,r2,r3
000048  f04f4320          MOV      r3,#0xa0000000
00004c  f8c32080          STR      r2,[r3,#0x80]
                  |L7.80|
;;;574        }
;;;575      }
;;;576    }
000050  4770              BX       lr
;;;577    /**
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      0xa0000080
                  |L7.88|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_NANDDeInit PROC
;;;375      */
;;;376    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  2810              CMP      r0,#0x10
;;;377    {
;;;378      /* Check the parameter */
;;;379      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;380      
;;;381      if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d10a              BNE      |L8.26|
;;;382      {
;;;383        /* Set the FSMC_Bank2 registers to their reset values */
;;;384        FSMC_Bank2->PCR2 = 0x00000018;
000004  2118              MOVS     r1,#0x18
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6611              STR      r1,[r2,#0x60]
;;;385        FSMC_Bank2->SR2 = 0x00000040;
00000c  2140              MOVS     r1,#0x40
00000e  6651              STR      r1,[r2,#0x64]
;;;386        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000010  f04f31fc          MOV      r1,#0xfcfcfcfc
000014  6691              STR      r1,[r2,#0x68]
;;;387        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
000016  66d1              STR      r1,[r2,#0x6c]
000018  e010              B        |L8.60|
                  |L8.26|
;;;388      }
;;;389      /* FSMC_Bank3_NAND */  
;;;390      else
;;;391      {
;;;392        /* Set the FSMC_Bank3 registers to their reset values */
;;;393        FSMC_Bank3->PCR3 = 0x00000018;
00001a  2118              MOVS     r1,#0x18
00001c  4a08              LDR      r2,|L8.64|
00001e  6011              STR      r1,[r2,#0]
;;;394        FSMC_Bank3->SR3 = 0x00000040;
000020  2140              MOVS     r1,#0x40
000022  f04f4220          MOV      r2,#0xa0000000
000026  f8c21084          STR      r1,[r2,#0x84]
;;;395        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
00002a  f04f31fc          MOV      r1,#0xfcfcfcfc
00002e  4a04              LDR      r2,|L8.64|
000030  3208              ADDS     r2,r2,#8
000032  6011              STR      r1,[r2,#0]
;;;396        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000034  f04f4220          MOV      r2,#0xa0000000
000038  f8c2108c          STR      r1,[r2,#0x8c]
                  |L8.60|
;;;397      }  
;;;398    }
00003c  4770              BX       lr
;;;399    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0xa0000080

                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;586      */
;;;587    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L9.42|
;;;588    {
;;;589      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591      
;;;592      if (NewState != DISABLE)
;;;593      {
;;;594        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;595        if(FSMC_Bank == FSMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L9.24|
;;;596        {
;;;597          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420240          ORR      r2,r2,#0x40
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01b              B        |L9.80|
                  |L9.24|
;;;598        }
;;;599        else
;;;600        {
;;;601          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
000018  4a0e              LDR      r2,|L9.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420240          ORR      r2,r2,#0x40
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e012              B        |L9.80|
                  |L9.42|
;;;602        }
;;;603      }
;;;604      else
;;;605      {
;;;606        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;607        if(FSMC_Bank == FSMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L9.64|
;;;608        {
;;;609          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L9.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e007              B        |L9.80|
                  |L9.64|
;;;610        }
;;;611        else
;;;612        {
;;;613          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000040  4a04              LDR      r2,|L9.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L9.88|
000046  401a              ANDS     r2,r2,r3
000048  f04f4320          MOV      r3,#0xa0000000
00004c  f8c32080          STR      r2,[r3,#0x80]
                  |L9.80|
;;;614        }
;;;615      }
;;;616    }
000050  4770              BX       lr
;;;617    
                          ENDP

000052  0000              DCW      0x0000
                  |L9.84|
                          DCD      0xa0000080
                  |L9.88|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=2

                  FSMC_NANDInit PROC
;;;406      */
;;;407    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;408    {
;;;409      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;410        
;;;411      /* Check the parameters */
;;;412      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;413      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;414      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;415      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;416      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;417      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;418      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;419      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;420      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;421      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;422      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;423      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;424      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;425      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;426      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;427      
;;;428      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
000008  6804              LDR      r4,[r0,#0]
00000a  2c10              CMP      r4,#0x10
00000c  d103              BNE      |L10.22|
;;;429      {
;;;430      /* Get the NAND bank 2 register value */
;;;431        tmppcr = FSMC_Bank2->PCR2;
00000e  f04f4420          MOV      r4,#0xa0000000
000012  6e21              LDR      r1,[r4,#0x60]
000014  e001              B        |L10.26|
                  |L10.22|
;;;432      }
;;;433      else
;;;434      {
;;;435      /* Get the NAND bank 3 register value */
;;;436        tmppcr = FSMC_Bank3->PCR3;
000016  4c2d              LDR      r4,|L10.204|
000018  6821              LDR      r1,[r4,#0]
                  |L10.26|
;;;437      }
;;;438    
;;;439      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;440      tmppcr &= ((uint32_t)~(FSMC_PCR2_PWAITEN  | FSMC_PCR2_PBKEN | FSMC_PCR2_PTYP | \
00001a  4c2d              LDR      r4,|L10.208|
00001c  4021              ANDS     r1,r1,r4
;;;441                             FSMC_PCR2_PWID | FSMC_PCR2_ECCEN | FSMC_PCR2_TCLR | \
;;;442                             FSMC_PCR2_TAR | FSMC_PCR2_ECCPS));  
;;;443    					   
;;;444      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;445      tmppcr |= (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
00001e  6844              LDR      r4,[r0,#4]
000020  f0440408          ORR      r4,r4,#8
000024  6885              LDR      r5,[r0,#8]
000026  432c              ORRS     r4,r4,r5
000028  68c5              LDR      r5,[r0,#0xc]
00002a  432c              ORRS     r4,r4,r5
00002c  6905              LDR      r5,[r0,#0x10]
00002e  432c              ORRS     r4,r4,r5
000030  6945              LDR      r5,[r0,#0x14]
000032  ea442445          ORR      r4,r4,r5,LSL #9
000036  6985              LDR      r5,[r0,#0x18]
000038  ea443445          ORR      r4,r4,r5,LSL #13
00003c  4321              ORRS     r1,r1,r4
;;;446                          PCR_MEMORYTYPE_NAND |
;;;447                          FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;448                          FSMC_NANDInitStruct->FSMC_ECC |
;;;449                          FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;450                          (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;451                          (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;452        
;;;453      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
00003e  6804              LDR      r4,[r0,#0]
000040  2c10              CMP      r4,#0x10
000042  d103              BNE      |L10.76|
;;;454      {
;;;455        /* Get the NAND bank 2 register value */
;;;456        tmppmem = FSMC_Bank2->PMEM2;
000044  f04f4420          MOV      r4,#0xa0000000
000048  6ea2              LDR      r2,[r4,#0x68]
00004a  e002              B        |L10.82|
                  |L10.76|
;;;457      }
;;;458      else
;;;459      {
;;;460        /* Get the NAND bank 3 register value */
;;;461        tmppmem = FSMC_Bank3->PMEM3;
00004c  4c1f              LDR      r4,|L10.204|
00004e  3408              ADDS     r4,r4,#8
000050  6822              LDR      r2,[r4,#0]
                  |L10.82|
;;;462      } 
;;;463      
;;;464      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;465      tmppmem &= ((uint32_t)~(FSMC_PMEM2_MEMSET2  | FSMC_PMEM2_MEMWAIT2 | FSMC_PMEM2_MEMHOLD2 | \
000052  2200              MOVS     r2,#0
;;;466                              FSMC_PMEM2_MEMHIZ2));
;;;467    					   
;;;468      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;469      tmppmem |= (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000054  69c4              LDR      r4,[r0,#0x1c]
000056  6824              LDR      r4,[r4,#0]
000058  69c5              LDR      r5,[r0,#0x1c]
00005a  686d              LDR      r5,[r5,#4]
00005c  ea442405          ORR      r4,r4,r5,LSL #8
000060  69c5              LDR      r5,[r0,#0x1c]
000062  892d              LDRH     r5,[r5,#8]
000064  ea444405          ORR      r4,r4,r5,LSL #16
000068  69c5              LDR      r5,[r0,#0x1c]
00006a  7b2d              LDRB     r5,[r5,#0xc]
00006c  ea446405          ORR      r4,r4,r5,LSL #24
000070  4322              ORRS     r2,r2,r4
;;;470                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;471                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;472                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;473    
;;;474      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
000072  6804              LDR      r4,[r0,#0]
000074  2c10              CMP      r4,#0x10
000076  d103              BNE      |L10.128|
;;;475      {
;;;476        /* Get the NAND bank 2 register value */
;;;477        tmppatt = FSMC_Bank2->PATT2;
000078  f04f4420          MOV      r4,#0xa0000000
00007c  6ee3              LDR      r3,[r4,#0x6c]
00007e  e002              B        |L10.134|
                  |L10.128|
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Get the NAND bank 3 register value */
;;;482        tmppatt = FSMC_Bank2->PATT2;
000080  f04f4420          MOV      r4,#0xa0000000
000084  6ee3              LDR      r3,[r4,#0x6c]
                  |L10.134|
;;;483      } 
;;;484      
;;;485      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;486      tmppatt &= ((uint32_t)~(FSMC_PATT2_ATTSET2  | FSMC_PATT2_ATTWAIT2 | FSMC_PATT2_ATTHOLD2 | \
000086  2300              MOVS     r3,#0
;;;487                              FSMC_PATT2_ATTHIZ2));
;;;488      
;;;489      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;490      tmppatt |= (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000088  6a04              LDR      r4,[r0,#0x20]
00008a  6824              LDR      r4,[r4,#0]
00008c  6a05              LDR      r5,[r0,#0x20]
00008e  686d              LDR      r5,[r5,#4]
000090  ea442405          ORR      r4,r4,r5,LSL #8
000094  6a05              LDR      r5,[r0,#0x20]
000096  892d              LDRH     r5,[r5,#8]
000098  ea444405          ORR      r4,r4,r5,LSL #16
00009c  6a05              LDR      r5,[r0,#0x20]
00009e  7b2d              LDRB     r5,[r5,#0xc]
0000a0  ea446405          ORR      r4,r4,r5,LSL #24
0000a4  4323              ORRS     r3,r3,r4
;;;491                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;492                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;493                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;494      
;;;495      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
0000a6  6804              LDR      r4,[r0,#0]
0000a8  2c10              CMP      r4,#0x10
0000aa  d105              BNE      |L10.184|
;;;496      {
;;;497        /* FSMC_Bank2_NAND registers configuration */
;;;498        FSMC_Bank2->PCR2 = tmppcr;
0000ac  f04f4420          MOV      r4,#0xa0000000
0000b0  6621              STR      r1,[r4,#0x60]
;;;499        FSMC_Bank2->PMEM2 = tmppmem;
0000b2  66a2              STR      r2,[r4,#0x68]
;;;500        FSMC_Bank2->PATT2 = tmppatt;
0000b4  66e3              STR      r3,[r4,#0x6c]
0000b6  e008              B        |L10.202|
                  |L10.184|
;;;501      }
;;;502      else
;;;503      {
;;;504        /* FSMC_Bank3_NAND registers configuration */
;;;505        FSMC_Bank3->PCR3 = tmppcr;
0000b8  4c04              LDR      r4,|L10.204|
0000ba  6021              STR      r1,[r4,#0]
;;;506        FSMC_Bank3->PMEM3 = tmppmem;
0000bc  f04f4420          MOV      r4,#0xa0000000
0000c0  f8c42088          STR      r2,[r4,#0x88]
;;;507        FSMC_Bank3->PATT3 = tmppatt;
0000c4  4c01              LDR      r4,|L10.204|
0000c6  340c              ADDS     r4,r4,#0xc
0000c8  6023              STR      r3,[r4,#0]
                  |L10.202|
;;;508      }
;;;509    }
0000ca  bd30              POP      {r4,r5,pc}
;;;510    
                          ENDP

                  |L10.204|
                          DCD      0xa0000080
                  |L10.208|
                          DCD      0xfff00181

                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;517      */
;;;518    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;519    { 
;;;520      /* Reset NAND Init structure parameters values */
;;;521      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
000002  6001              STR      r1,[r0,#0]
;;;522      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000004  2100              MOVS     r1,#0
000006  6041              STR      r1,[r0,#4]
;;;523      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000008  6081              STR      r1,[r0,#8]
;;;524      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
;;;525      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000c  6101              STR      r1,[r0,#0x10]
;;;526      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;527      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000010  6181              STR      r1,[r0,#0x18]
;;;528      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000012  21fc              MOVS     r1,#0xfc
000014  69c2              LDR      r2,[r0,#0x1c]
000016  6011              STR      r1,[r2,#0]
;;;529      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  6051              STR      r1,[r2,#4]
;;;530      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001c  69c2              LDR      r2,[r0,#0x1c]
00001e  6091              STR      r1,[r2,#8]
;;;531      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000020  69c2              LDR      r2,[r0,#0x1c]
000022  60d1              STR      r1,[r2,#0xc]
;;;532      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000024  6a02              LDR      r2,[r0,#0x20]
000026  6011              STR      r1,[r2,#0]
;;;533      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000028  6a02              LDR      r2,[r0,#0x20]
00002a  6051              STR      r1,[r2,#4]
;;;534      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002c  6a02              LDR      r2,[r0,#0x20]
00002e  6091              STR      r1,[r2,#8]
;;;535      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000030  6a02              LDR      r2,[r0,#0x20]
000032  60d1              STR      r1,[r2,#0xc]
;;;536    }
000034  4770              BX       lr
;;;537    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;302      */
;;;303    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b151              CBZ      r1,|L12.24|
;;;304    {
;;;305      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;306      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;307      
;;;308      if (NewState != DISABLE)
;;;309      {
;;;310        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;311        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000002  0082              LSLS     r2,r0,#2
000004  f1a242c0          SUB      r2,r2,#0x60000000
000008  6812              LDR      r2,[r2,#0]
00000a  f0420301          ORR      r3,r2,#1
00000e  0082              LSLS     r2,r0,#2
000010  f1a242c0          SUB      r2,r2,#0x60000000
000014  6013              STR      r3,[r2,#0]
000016  e009              B        |L12.44|
                  |L12.24|
;;;312      }
;;;313      else
;;;314      {
;;;315        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;316        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
000018  0082              LSLS     r2,r0,#2
00001a  f1a242c0          SUB      r2,r2,#0x60000000
00001e  6812              LDR      r2,[r2,#0]
000020  4b03              LDR      r3,|L12.48|
000022  401a              ANDS     r2,r2,r3
000024  0083              LSLS     r3,r0,#2
000026  f1a343c0          SUB      r3,r3,#0x60000000
00002a  601a              STR      r2,[r3,#0]
                  |L12.44|
;;;317      }
;;;318    }
00002c  4770              BX       lr
;;;319    /**
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;128      */
;;;129    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  b930              CBNZ     r0,|L13.16|
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;133      
;;;134      /* FSMC_Bank1_NORSRAM1 */
;;;135      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;136      {
;;;137        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
000002  f24302db          MOV      r2,#0x30db
000006  0081              LSLS     r1,r0,#2
000008  f1a141c0          SUB      r1,r1,#0x60000000
00000c  600a              STR      r2,[r1,#0]
00000e  e005              B        |L13.28|
                  |L13.16|
;;;138      }
;;;139      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;140      else
;;;141      {   
;;;142        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000010  f24302d2          MOV      r2,#0x30d2
000014  0081              LSLS     r1,r0,#2
000016  f1a141c0          SUB      r1,r1,#0x60000000
00001a  600a              STR      r2,[r1,#0]
                  |L13.28|
;;;143      }
;;;144      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  1c41              ADDS     r1,r0,#1
000022  0089              LSLS     r1,r1,#2
000024  f1a141c0          SUB      r1,r1,#0x60000000
000028  600a              STR      r2,[r1,#0]
;;;145      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00002a  0081              LSLS     r1,r0,#2
00002c  f1a141c0          SUB      r1,r1,#0x60000000
000030  f8c12104          STR      r2,[r1,#0x104]
;;;146    }
000034  4770              BX       lr
;;;147    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMInit PROC
;;;155      */
;;;156    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;157    { 
;;;158      uint32_t tmpbcr = 0, tmpbtr = 0, tmpbwr = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;159    
;;;160      /* Check the parameters */
;;;161      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;162      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;163      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;164      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;165      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;166      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;167      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;168      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;169      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;170      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;171      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;172      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;173      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;174      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;175      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;176      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;177      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;178      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;179      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;180      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;181    
;;;182      /* Get the BTCR register value */
;;;183      tmpbcr = FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank];
000008  6804              LDR      r4,[r0,#0]
00000a  00a4              LSLS     r4,r4,#2
00000c  f1a444c0          SUB      r4,r4,#0x60000000
000010  6821              LDR      r1,[r4,#0]
;;;184    
;;;185      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
;;;186               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;187      tmpbcr &= ((uint32_t)~(FSMC_BCR1_MBKEN    | FSMC_BCR1_MUXEN    | FSMC_BCR1_MTYP     | \
000012  4c44              LDR      r4,|L14.292|
000014  4021              ANDS     r1,r1,r4
;;;188                             FSMC_BCR1_MWID      | FSMC_BCR1_FACCEN   | FSMC_BCR1_BURSTEN  | \
;;;189                             FSMC_BCR1_WAITPOL   | FSMC_BCR1_WRAPMOD  | FSMC_BCR1_WAITCFG  | \
;;;190                             FSMC_BCR1_WREN      | FSMC_BCR1_WAITEN   | FSMC_BCR1_EXTMOD   | \
;;;191                             FSMC_BCR1_ASYNCWAIT | FSMC_BCR1_CBURSTRW));
;;;192    
;;;193      /* Bank1 NOR/SRAM control register configuration */ 
;;;194      tmpbcr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
000016  e9d04501          LDRD     r4,r5,[r0,#4]
00001a  432c              ORRS     r4,r4,r5
00001c  68c5              LDR      r5,[r0,#0xc]
00001e  432c              ORRS     r4,r4,r5
000020  6905              LDR      r5,[r0,#0x10]
000022  432c              ORRS     r4,r4,r5
000024  6945              LDR      r5,[r0,#0x14]
000026  432c              ORRS     r4,r4,r5
000028  6985              LDR      r5,[r0,#0x18]
00002a  432c              ORRS     r4,r4,r5
00002c  69c5              LDR      r5,[r0,#0x1c]
00002e  432c              ORRS     r4,r4,r5
000030  6a05              LDR      r5,[r0,#0x20]
000032  432c              ORRS     r4,r4,r5
000034  6a45              LDR      r5,[r0,#0x24]
000036  432c              ORRS     r4,r4,r5
000038  6a85              LDR      r5,[r0,#0x28]
00003a  432c              ORRS     r4,r4,r5
00003c  6ac5              LDR      r5,[r0,#0x2c]
00003e  432c              ORRS     r4,r4,r5
000040  6b05              LDR      r5,[r0,#0x30]
000042  432c              ORRS     r4,r4,r5
000044  4321              ORRS     r1,r1,r4
;;;195                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;196                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;197                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;198                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;199                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;200                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;201                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;202                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;203                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;204                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;205                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;206    			
;;;207      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = tmpbcr;
000046  6804              LDR      r4,[r0,#0]
000048  00a4              LSLS     r4,r4,#2
00004a  f1a444c0          SUB      r4,r4,#0x60000000
00004e  6021              STR      r1,[r4,#0]
;;;208      
;;;209      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000050  6884              LDR      r4,[r0,#8]
000052  2c08              CMP      r4,#8
000054  d10b              BNE      |L14.110|
;;;210      {
;;;211        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000056  6804              LDR      r4,[r0,#0]
000058  00a4              LSLS     r4,r4,#2
00005a  f1a444c0          SUB      r4,r4,#0x60000000
00005e  6824              LDR      r4,[r4,#0]
000060  f0440540          ORR      r5,r4,#0x40
000064  6804              LDR      r4,[r0,#0]
000066  00a4              LSLS     r4,r4,#2
000068  f1a444c0          SUB      r4,r4,#0x60000000
00006c  6025              STR      r5,[r4,#0]
                  |L14.110|
;;;212      }
;;;213      
;;;214      /* Get the BTCR register value */
;;;215      tmpbtr = FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1];
00006e  6804              LDR      r4,[r0,#0]
000070  1c64              ADDS     r4,r4,#1
000072  00a4              LSLS     r4,r4,#2
000074  f1a444c0          SUB      r4,r4,#0x60000000
000078  6822              LDR      r2,[r4,#0]
;;;216    
;;;217      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;218      tmpbtr &= ((uint32_t)~(FSMC_BTR1_ADDSET | FSMC_BTR1_ADDHLD | FSMC_BTR1_DATAST | \
00007a  f0024240          AND      r2,r2,#0xc0000000
;;;219                           FSMC_BTR1_BUSTURN | FSMC_BTR1_CLKDIV | FSMC_BTR1_DATLAT | \
;;;220                           FSMC_BTR1_ACCMOD));
;;;221    					   
;;;222      /* Bank1 NOR/SRAM timing register configuration */
;;;223      tmpbtr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
00007e  6b44              LDR      r4,[r0,#0x34]
000080  6824              LDR      r4,[r4,#0]
000082  6b45              LDR      r5,[r0,#0x34]
000084  686d              LDR      r5,[r5,#4]
000086  ea441405          ORR      r4,r4,r5,LSL #4
00008a  6b45              LDR      r5,[r0,#0x34]
00008c  68ad              LDR      r5,[r5,#8]
00008e  ea442405          ORR      r4,r4,r5,LSL #8
000092  6b45              LDR      r5,[r0,#0x34]
000094  89ad              LDRH     r5,[r5,#0xc]
000096  ea444405          ORR      r4,r4,r5,LSL #16
00009a  6b45              LDR      r5,[r0,#0x34]
00009c  8a2d              LDRH     r5,[r5,#0x10]
00009e  ea445405          ORR      r4,r4,r5,LSL #20
0000a2  6b45              LDR      r5,[r0,#0x34]
0000a4  7d2d              LDRB     r5,[r5,#0x14]
0000a6  ea446405          ORR      r4,r4,r5,LSL #24
0000aa  6b45              LDR      r5,[r0,#0x34]
0000ac  69ad              LDR      r5,[r5,#0x18]
0000ae  432c              ORRS     r4,r4,r5
0000b0  4322              ORRS     r2,r2,r4
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;228                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;229                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;230                
;;;231      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = tmpbtr;
0000b2  6804              LDR      r4,[r0,#0]
0000b4  1c64              ADDS     r4,r4,#1
0000b6  00a4              LSLS     r4,r4,#2
0000b8  f1a444c0          SUB      r4,r4,#0x60000000
0000bc  6022              STR      r2,[r4,#0]
;;;232    	
;;;233      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;234      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000be  6ac4              LDR      r4,[r0,#0x2c]
0000c0  f5b44f80          CMP      r4,#0x4000
0000c4  d124              BNE      |L14.272|
;;;235      {
;;;236        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;237        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;238        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;239        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;240        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;241        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;242        
;;;243        /* Get the BWTR register value */
;;;244        tmpbwr = FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank];
0000c6  6804              LDR      r4,[r0,#0]
0000c8  00a4              LSLS     r4,r4,#2
0000ca  f1a444c0          SUB      r4,r4,#0x60000000
0000ce  f8d43104          LDR      r3,[r4,#0x104]
;;;245        
;;;246        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;247        tmpbwr &= ((uint32_t)~(FSMC_BWTR1_ADDSET | FSMC_BWTR1_ADDHLD | FSMC_BWTR1_DATAST | \
0000d2  f0034340          AND      r3,r3,#0xc0000000
;;;248                               FSMC_BWTR1_BUSTURN | FSMC_BWTR1_CLKDIV | FSMC_BWTR1_DATLAT | \
;;;249                               FSMC_BWTR1_ACCMOD));
;;;250        
;;;251        tmpbwr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
0000d6  6b84              LDR      r4,[r0,#0x38]
0000d8  6824              LDR      r4,[r4,#0]
0000da  6b85              LDR      r5,[r0,#0x38]
0000dc  686d              LDR      r5,[r5,#4]
0000de  ea441405          ORR      r4,r4,r5,LSL #4
0000e2  6b85              LDR      r5,[r0,#0x38]
0000e4  68ad              LDR      r5,[r5,#8]
0000e6  ea442405          ORR      r4,r4,r5,LSL #8
0000ea  6b85              LDR      r5,[r0,#0x38]
0000ec  8a2d              LDRH     r5,[r5,#0x10]
0000ee  ea445405          ORR      r4,r4,r5,LSL #20
0000f2  6b85              LDR      r5,[r0,#0x38]
0000f4  7d2d              LDRB     r5,[r5,#0x14]
0000f6  ea446405          ORR      r4,r4,r5,LSL #24
0000fa  6b85              LDR      r5,[r0,#0x38]
0000fc  69ad              LDR      r5,[r5,#0x18]
0000fe  432c              ORRS     r4,r4,r5
000100  4323              ORRS     r3,r3,r4
;;;252                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;253                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;254                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;255                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;256                            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;257        
;;;258        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = tmpbwr;
000102  6804              LDR      r4,[r0,#0]
000104  00a4              LSLS     r4,r4,#2
000106  f1a444c0          SUB      r4,r4,#0x60000000
00010a  f8c43104          STR      r3,[r4,#0x104]
00010e  e007              B        |L14.288|
                  |L14.272|
;;;259      }
;;;260      else
;;;261      {
;;;262        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000110  f06f4570          MVN      r5,#0xf0000000
000114  6804              LDR      r4,[r0,#0]
000116  00a4              LSLS     r4,r4,#2
000118  f1a444c0          SUB      r4,r4,#0x60000000
00011c  f8c45104          STR      r5,[r4,#0x104]
                  |L14.288|
;;;263      }
;;;264    }
000120  bd30              POP      {r4,r5,pc}
;;;265    
                          ENDP

000122  0000              DCW      0x0000
                  |L14.292|
                          DCD      0xfff70080

                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMStructInit PROC
;;;271      */
;;;272    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;273    {  
;;;274      /* Reset NOR/SRAM Init structure parameters values */
;;;275      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  6001              STR      r1,[r0,#0]
;;;276      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2102              MOVS     r1,#2
000006  6041              STR      r1,[r0,#4]
;;;277      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
;;;278      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000c  60c1              STR      r1,[r0,#0xc]
;;;279      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;280      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
000010  6141              STR      r1,[r0,#0x14]
;;;281      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000012  6181              STR      r1,[r0,#0x18]
;;;282      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000014  61c1              STR      r1,[r0,#0x1c]
;;;283      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000016  6201              STR      r1,[r0,#0x20]
;;;284      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000018  f44f5180          MOV      r1,#0x1000
00001c  6241              STR      r1,[r0,#0x24]
;;;285      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001e  0049              LSLS     r1,r1,#1
000020  6281              STR      r1,[r0,#0x28]
;;;286      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000022  2100              MOVS     r1,#0
000024  62c1              STR      r1,[r0,#0x2c]
;;;287      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000026  6301              STR      r1,[r0,#0x30]
;;;288      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
000028  4901              LDR      r1,|L15.48|
00002a  6341              STR      r1,[r0,#0x34]
;;;289      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
00002c  6381              STR      r1,[r0,#0x38]
;;;290    }
00002e  4770              BX       lr
;;;291    
                          ENDP

                  |L15.48|
                          DCD      FSMC_DefaultTimingStruct

                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;822      */
;;;823    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  b140              CBZ      r0,|L16.20|
;;;824    {
;;;825      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;826      
;;;827      if (NewState != DISABLE)
;;;828      {
;;;829        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;830        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
000002  4909              LDR      r1,|L16.40|
000004  6809              LDR      r1,[r1,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  f04f4220          MOV      r2,#0xa0000000
00000e  f8c210a0          STR      r1,[r2,#0xa0]
000012  e007              B        |L16.36|
                  |L16.20|
;;;831      }
;;;832      else
;;;833      {
;;;834        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;835        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000014  4904              LDR      r1,|L16.40|
000016  6809              LDR      r1,[r1,#0]
000018  4a04              LDR      r2,|L16.44|
00001a  4011              ANDS     r1,r1,r2
00001c  f04f4220          MOV      r2,#0xa0000000
000020  f8c210a0          STR      r1,[r2,#0xa0]
                  |L16.36|
;;;836      }
;;;837    }
000024  4770              BX       lr
;;;838    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      0xa00000a0
                  |L16.44|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDDeInit PROC
;;;689      */
;;;690    void FSMC_PCCARDDeInit(void)
000000  2018              MOVS     r0,#0x18
;;;691    {
;;;692      /* Set the FSMC_Bank4 registers to their reset values */
;;;693      FSMC_Bank4->PCR4 = 0x00000018; 
000002  4908              LDR      r1,|L17.36|
000004  6008              STR      r0,[r1,#0]
;;;694      FSMC_Bank4->SR4 = 0x00000000;	
000006  2000              MOVS     r0,#0
000008  0609              LSLS     r1,r1,#24
00000a  f8c100a4          STR      r0,[r1,#0xa4]
;;;695      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f30fc          MOV      r0,#0xfcfcfcfc
000012  4904              LDR      r1,|L17.36|
000014  3108              ADDS     r1,r1,#8
000016  6008              STR      r0,[r1,#0]
;;;696      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000018  1d09              ADDS     r1,r1,#4
00001a  6008              STR      r0,[r1,#0]
;;;697      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
00001c  1d09              ADDS     r1,r1,#4
00001e  6008              STR      r0,[r1,#0]
;;;698    }
000020  4770              BX       lr
;;;699    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;706      */
;;;707    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;708    {
;;;709       uint32_t tmppcr4 = 0, tmppmem4 = 0, tmppatt4 = 0, tmppio4 = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;710    
;;;711      /* Check the parameters */
;;;712      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;713      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;714      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;715     
;;;716      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;717      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;718      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;719      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;720      
;;;721      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;722      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;723      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;724      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;725      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;726      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;727      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;728      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;729      
;;;730      /* Get PCCARD control register value */
;;;731      tmppcr4 = FSMC_Bank4->PCR4;
00000a  4d2c              LDR      r5,|L18.188|
00000c  6829              LDR      r1,[r5,#0]
;;;732      
;;;733      /* Clear TAR, TCLR, PWAITEN and PWID bits */
;;;734      tmppcr4 &= ((uint32_t)~(FSMC_PCR4_TAR  | FSMC_PCR4_TCLR | FSMC_PCR4_PWAITEN | \
00000e  4d2c              LDR      r5,|L18.192|
000010  4029              ANDS     r1,r1,r5
;;;735                              FSMC_PCR4_PWID));
;;;736    					   
;;;737      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;738      tmppcr4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000012  6805              LDR      r5,[r0,#0]
000014  f0450510          ORR      r5,r5,#0x10
000018  6846              LDR      r6,[r0,#4]
00001a  ea452546          ORR      r5,r5,r6,LSL #9
00001e  6886              LDR      r6,[r0,#8]
000020  ea453546          ORR      r5,r5,r6,LSL #13
000024  4329              ORRS     r1,r1,r5
;;;739                           FSMC_MemoryDataWidth_16b |  
;;;740                           (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;741                           (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;742      
;;;743      FSMC_Bank4->PCR4 = tmppcr4;
000026  f04f4520          MOV      r5,#0xa0000000
00002a  f8c510a0          STR      r1,[r5,#0xa0]
;;;744      
;;;745      /* Get PCCARD common space timing register value */
;;;746      tmppmem4 = FSMC_Bank4->PMEM4;
00002e  4d23              LDR      r5,|L18.188|
000030  3508              ADDS     r5,r5,#8
000032  682a              LDR      r2,[r5,#0]
;;;747      
;;;748      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;749      tmppmem4 &= ((uint32_t)~(FSMC_PMEM4_MEMSET4  | FSMC_PMEM4_MEMWAIT4 | FSMC_PMEM4_MEMHOLD4 | \
000034  2200              MOVS     r2,#0
;;;750                               FSMC_PMEM4_MEMHIZ4));
;;;751    					   
;;;752      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;753      tmppmem4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000036  68c5              LDR      r5,[r0,#0xc]
000038  682d              LDR      r5,[r5,#0]
00003a  68c6              LDR      r6,[r0,#0xc]
00003c  6876              LDR      r6,[r6,#4]
00003e  ea452506          ORR      r5,r5,r6,LSL #8
000042  68c6              LDR      r6,[r0,#0xc]
000044  8936              LDRH     r6,[r6,#8]
000046  ea454506          ORR      r5,r5,r6,LSL #16
00004a  68c6              LDR      r6,[r0,#0xc]
00004c  7b36              LDRB     r6,[r6,#0xc]
00004e  ea456506          ORR      r5,r5,r6,LSL #24
000052  432a              ORRS     r2,r2,r5
;;;754                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;755                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;756                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;757       
;;;758      FSMC_Bank4->PMEM4 = tmppmem4;
000054  f04f4520          MOV      r5,#0xa0000000
000058  f8c520a8          STR      r2,[r5,#0xa8]
;;;759      
;;;760      /* Get PCCARD timing parameters */
;;;761      tmppatt4 = FSMC_Bank4->PATT4;
00005c  4d17              LDR      r5,|L18.188|
00005e  350c              ADDS     r5,r5,#0xc
000060  682b              LDR      r3,[r5,#0]
;;;762    
;;;763      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;764      tmppatt4 &= ((uint32_t)~(FSMC_PATT4_ATTSET4  | FSMC_PATT4_ATTWAIT4 | FSMC_PATT4_ATTHOLD4 | \
000062  2300              MOVS     r3,#0
;;;765                               FSMC_PATT4_ATTHIZ4));
;;;766    					   
;;;767      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;768      tmppatt4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000064  6905              LDR      r5,[r0,#0x10]
000066  682d              LDR      r5,[r5,#0]
000068  6906              LDR      r6,[r0,#0x10]
00006a  6876              LDR      r6,[r6,#4]
00006c  ea452506          ORR      r5,r5,r6,LSL #8
000070  6906              LDR      r6,[r0,#0x10]
000072  8936              LDRH     r6,[r6,#8]
000074  ea454506          ORR      r5,r5,r6,LSL #16
000078  6906              LDR      r6,[r0,#0x10]
00007a  7b36              LDRB     r6,[r6,#0xc]
00007c  ea456506          ORR      r5,r5,r6,LSL #24
000080  432b              ORRS     r3,r3,r5
;;;769                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;770                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;771                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;772       
;;;773      FSMC_Bank4->PATT4 = tmppatt4;
000082  f04f4520          MOV      r5,#0xa0000000
000086  f8c530ac          STR      r3,[r5,#0xac]
;;;774    
;;;775      /* Get FSMC_PCCARD device timing parameters */
;;;776      tmppio4 = FSMC_Bank4->PIO4;
00008a  4d0c              LDR      r5,|L18.188|
00008c  3510              ADDS     r5,r5,#0x10
00008e  682c              LDR      r4,[r5,#0]
;;;777    
;;;778      /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
;;;779      tmppio4 &= ((uint32_t)~(FSMC_PIO4_IOSET4  | FSMC_PIO4_IOWAIT4 | FSMC_PIO4_IOHOLD4 | \
000090  2400              MOVS     r4,#0
;;;780                              FSMC_PIO4_IOHIZ4));
;;;781    					   
;;;782      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;783      tmppio4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000092  6945              LDR      r5,[r0,#0x14]
000094  682d              LDR      r5,[r5,#0]
000096  6946              LDR      r6,[r0,#0x14]
000098  6876              LDR      r6,[r6,#4]
00009a  ea452506          ORR      r5,r5,r6,LSL #8
00009e  6946              LDR      r6,[r0,#0x14]
0000a0  8936              LDRH     r6,[r6,#8]
0000a2  ea454506          ORR      r5,r5,r6,LSL #16
0000a6  6946              LDR      r6,[r0,#0x14]
0000a8  7b36              LDRB     r6,[r6,#0xc]
0000aa  ea456506          ORR      r5,r5,r6,LSL #24
0000ae  432c              ORRS     r4,r4,r5
;;;784                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;785                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;786                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;787      
;;;788      FSMC_Bank4->PIO4 = tmppio4;					 
0000b0  f04f4520          MOV      r5,#0xa0000000
0000b4  f8c540b0          STR      r4,[r5,#0xb0]
;;;789    }
0000b8  bd70              POP      {r4-r6,pc}
;;;790    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L18.188|
                          DCD      0xa00000a0
                  |L18.192|
                          DCD      0xfffe01cd

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;796      */
;;;797    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;798    {
;;;799      /* Reset PCCARD Init structure parameters values */
;;;800      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
;;;801      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;802      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000006  6081              STR      r1,[r0,#8]
;;;803      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000008  21fc              MOVS     r1,#0xfc
00000a  68c2              LDR      r2,[r0,#0xc]
00000c  6011              STR      r1,[r2,#0]
;;;804      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  6051              STR      r1,[r2,#4]
;;;805      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000012  68c2              LDR      r2,[r0,#0xc]
000014  6091              STR      r1,[r2,#8]
;;;806      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000016  68c2              LDR      r2,[r0,#0xc]
000018  60d1              STR      r1,[r2,#0xc]
;;;807      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00001a  6902              LDR      r2,[r0,#0x10]
00001c  6011              STR      r1,[r2,#0]
;;;808      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001e  6902              LDR      r2,[r0,#0x10]
000020  6051              STR      r1,[r2,#4]
;;;809      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000022  6902              LDR      r2,[r0,#0x10]
000024  6091              STR      r1,[r2,#8]
;;;810      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000026  6902              LDR      r2,[r0,#0x10]
000028  60d1              STR      r1,[r2,#0xc]
;;;811      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00002a  6942              LDR      r2,[r0,#0x14]
00002c  6011              STR      r1,[r2,#0]
;;;812      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002e  6942              LDR      r2,[r0,#0x14]
000030  6051              STR      r1,[r2,#4]
;;;813      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000032  6942              LDR      r2,[r0,#0x14]
000034  6091              STR      r1,[r2,#8]
;;;814      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000036  6942              LDR      r2,[r0,#0x14]
000038  60d1              STR      r1,[r2,#0xc]
;;;815    }
00003a  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  FSMC_DefaultTimingStruct
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x000000ff
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_fsmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_13019877____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REVSH|
#line 144
|__asm___16_stm32f4xx_fsmc_c_13019877____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____RRX|
#line 300
|__asm___16_stm32f4xx_fsmc_c_13019877____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
