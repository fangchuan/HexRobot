; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_core.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\os_core.crf ..\..\uCOS-III\uCOS-III\Source\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=2

                  OSInit PROC
;;;54     
;;;55     void  OSInit (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  4604              MOV      r4,r0
;;;57         CPU_STK      *p_stk;
;;;58         CPU_STK_SIZE  size;
;;;59     
;;;60     
;;;61     
;;;62     #ifdef OS_SAFETY_CRITICAL
;;;63         if (p_err == (OS_ERR *)0) {
;;;64             OS_SAFETY_CRITICAL_EXCEPTION();
;;;65             return;
;;;66         }
;;;67     #endif
;;;68     
;;;69         OSInitHook();                                           /* Call port specific initialization code                 */
000004  f7fffffe          BL       OSInitHook
;;;70     
;;;71         OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
000008  2000              MOVS     r0,#0
00000a  4942              LDR      r1,|L1.276|
00000c  7008              STRB     r0,[r1,#0]
;;;72     
;;;73         OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
00000e  4942              LDR      r1,|L1.280|
000010  7008              STRB     r0,[r1,#0]
;;;74     
;;;75         OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
000012  4942              LDR      r1,|L1.284|
000014  7008              STRB     r0,[r1,#0]
;;;76     
;;;77         OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
000016  4942              LDR      r1,|L1.288|
000018  6008              STR      r0,[r1,#0]  ; OSTCBCurPtr
;;;78         OSTCBHighRdyPtr                 = (OS_TCB *)0;
00001a  4942              LDR      r1,|L1.292|
00001c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
;;;79     
;;;80         OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
00001e  4942              LDR      r1,|L1.296|
000020  7008              STRB     r0,[r1,#0]
;;;81         OSPrioHighRdy                   = (OS_PRIO)0;
000022  4942              LDR      r1,|L1.300|
000024  7008              STRB     r0,[r1,#0]
;;;82         OSPrioSaved                     = (OS_PRIO)0;
000026  4942              LDR      r1,|L1.304|
000028  7008              STRB     r0,[r1,#0]
;;;83     
;;;84     #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;85         OSSchedLockTimeBegin            = (CPU_TS)0;
;;;86         OSSchedLockTimeMax              = (CPU_TS)0;
;;;87         OSSchedLockTimeMaxCur           = (CPU_TS)0;
;;;88     #endif
;;;89     
;;;90     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;91         OSSafetyCriticalStartFlag       =  DEF_FALSE;
;;;92     #endif
;;;93     
;;;94     #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;95         OSSchedRoundRobinEn             = DEF_FALSE;
00002a  4942              LDR      r1,|L1.308|
00002c  7008              STRB     r0,[r1,#0]
;;;96         OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
00002e  4842              LDR      r0,|L1.312|
000030  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000032  210a              MOVS     r1,#0xa
000034  fbb0f0f1          UDIV     r0,r0,r1
000038  4940              LDR      r1,|L1.316|
00003a  6008              STR      r0,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
;;;97     #endif
;;;98     
;;;99         if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
00003c  4840              LDR      r0,|L1.320|
00003e  6800              LDR      r0,[r0,#0]  ; OSCfg_ISRStkSize
000040  b158              CBZ      r0,|L1.90|
;;;100            p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
000042  4840              LDR      r0,|L1.324|
000044  6805              LDR      r5,[r0,#0]  ; OSCfg_ISRStkBasePtr
;;;101            if (p_stk != (CPU_STK *)0) {
000046  b145              CBZ      r5,|L1.90|
;;;102                size  = OSCfg_ISRStkSize;
000048  483d              LDR      r0,|L1.320|
00004a  6806              LDR      r6,[r0,#0]  ; OSCfg_ISRStkSize
;;;103                while (size > (CPU_STK_SIZE)0) {
00004c  e003              B        |L1.86|
                  |L1.78|
;;;104                    size--;
00004e  1e76              SUBS     r6,r6,#1
;;;105                   *p_stk = (CPU_STK)0;
000050  2000              MOVS     r0,#0
000052  6028              STR      r0,[r5,#0]
;;;106                    p_stk++;
000054  1d2d              ADDS     r5,r5,#4
                  |L1.86|
000056  2e00              CMP      r6,#0                 ;103
000058  d1f9              BNE      |L1.78|
                  |L1.90|
;;;107                }
;;;108            }
;;;109        }
;;;110    
;;;111    #if OS_CFG_APP_HOOKS_EN > 0u
;;;112        OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
00005a  2000              MOVS     r0,#0
00005c  493a              LDR      r1,|L1.328|
00005e  6008              STR      r0,[r1,#0]  ; OS_AppTaskCreateHookPtr
;;;113        OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
000060  493a              LDR      r1,|L1.332|
000062  6008              STR      r0,[r1,#0]  ; OS_AppTaskDelHookPtr
;;;114        OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
000064  493a              LDR      r1,|L1.336|
000066  6008              STR      r0,[r1,#0]  ; OS_AppTaskReturnHookPtr
;;;115    
;;;116        OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
000068  493a              LDR      r1,|L1.340|
00006a  6008              STR      r0,[r1,#0]  ; OS_AppIdleTaskHookPtr
;;;117        OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
00006c  493a              LDR      r1,|L1.344|
00006e  6008              STR      r0,[r1,#0]  ; OS_AppStatTaskHookPtr
;;;118        OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
000070  493a              LDR      r1,|L1.348|
000072  6008              STR      r0,[r1,#0]  ; OS_AppTaskSwHookPtr
;;;119        OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
000074  493a              LDR      r1,|L1.352|
000076  6008              STR      r0,[r1,#0]  ; OS_AppTimeTickHookPtr
;;;120    #endif
;;;121    
;;;122    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;123        OSTaskRegNextAvailID    = (OS_REG_ID)0;
000078  493a              LDR      r1,|L1.356|
00007a  7008              STRB     r0,[r1,#0]
;;;124    #endif
;;;125    
;;;126        OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
00007c  f7fffffe          BL       OS_PrioInit
;;;127    
;;;128        OS_RdyListInit();                                       /* Initialize the Ready List                              */
000080  f7fffffe          BL       OS_RdyListInit
;;;129    
;;;130        
;;;131    #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
;;;132        OS_FlagInit(p_err);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       OS_FlagInit
;;;133        if (*p_err != OS_ERR_NONE) {
00008a  8820              LDRH     r0,[r4,#0]
00008c  b100              CBZ      r0,|L1.144|
                  |L1.142|
;;;134            return;
;;;135        }
;;;136    #endif
;;;137    
;;;138    
;;;139    #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
;;;140        OS_MemInit(p_err);
;;;141        if (*p_err != OS_ERR_NONE) {
;;;142            return;
;;;143        }
;;;144    #endif
;;;145    
;;;146    
;;;147    #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
;;;148        OS_MsgPoolInit(p_err);
;;;149        if (*p_err != OS_ERR_NONE) {
;;;150            return;
;;;151        }
;;;152    #endif
;;;153    
;;;154    
;;;155    #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
;;;156        OS_MutexInit(p_err);
;;;157        if (*p_err != OS_ERR_NONE) {
;;;158            return;
;;;159        }
;;;160    #endif
;;;161    
;;;162    
;;;163    #if OS_CFG_Q_EN > 0u
;;;164        OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
;;;165        if (*p_err != OS_ERR_NONE) {
;;;166            return;
;;;167        }
;;;168    #endif
;;;169    
;;;170    
;;;171    #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
;;;172        OS_SemInit(p_err);
;;;173        if (*p_err != OS_ERR_NONE) {
;;;174            return;
;;;175        }
;;;176    #endif
;;;177    
;;;178    
;;;179    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;180        OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
;;;181        if (*p_err != OS_ERR_NONE) {
;;;182            return;
;;;183        }
;;;184    #endif
;;;185    
;;;186    
;;;187        OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
;;;188        if (*p_err != OS_ERR_NONE) {
;;;189            return;
;;;190        }
;;;191    
;;;192    
;;;193    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;194        OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
;;;195        if (*p_err != OS_ERR_NONE) {
;;;196            return;
;;;197        }
;;;198    #endif
;;;199    
;;;200        
;;;201        OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
;;;202        if (*p_err != OS_ERR_NONE) {
;;;203            return;
;;;204        }
;;;205    
;;;206    
;;;207        OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
;;;208        if (*p_err != OS_ERR_NONE) {
;;;209            return;
;;;210        }
;;;211    
;;;212    
;;;213    #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
;;;214        OS_StatTaskInit(p_err);
;;;215        if (*p_err != OS_ERR_NONE) {
;;;216            return;
;;;217        }
;;;218    #endif
;;;219    
;;;220    
;;;221    #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
;;;222        OS_TmrInit(p_err);
;;;223        if (*p_err != OS_ERR_NONE) {
;;;224            return;
;;;225        }
;;;226    #endif
;;;227    
;;;228    
;;;229    #if OS_CFG_DBG_EN > 0u
;;;230        OS_Dbg_Init();
;;;231    #endif
;;;232    
;;;233    
;;;234        OSCfg_Init();
;;;235    }
00008e  bd70              POP      {r4-r6,pc}
                  |L1.144|
000090  4620              MOV      r0,r4                 ;140
000092  f7fffffe          BL       OS_MemInit
000096  8820              LDRH     r0,[r4,#0]            ;141
000098  b100              CBZ      r0,|L1.156|
00009a  e7f8              B        |L1.142|
                  |L1.156|
00009c  4620              MOV      r0,r4                 ;148
00009e  f7fffffe          BL       OS_MsgPoolInit
0000a2  8820              LDRH     r0,[r4,#0]            ;149
0000a4  b100              CBZ      r0,|L1.168|
0000a6  e7f2              B        |L1.142|
                  |L1.168|
0000a8  4620              MOV      r0,r4                 ;156
0000aa  f7fffffe          BL       OS_MutexInit
0000ae  8820              LDRH     r0,[r4,#0]            ;157
0000b0  b100              CBZ      r0,|L1.180|
0000b2  e7ec              B        |L1.142|
                  |L1.180|
0000b4  4620              MOV      r0,r4                 ;164
0000b6  f7fffffe          BL       OS_QInit
0000ba  8820              LDRH     r0,[r4,#0]            ;165
0000bc  b100              CBZ      r0,|L1.192|
0000be  e7e6              B        |L1.142|
                  |L1.192|
0000c0  4620              MOV      r0,r4                 ;172
0000c2  f7fffffe          BL       OS_SemInit
0000c6  8820              LDRH     r0,[r4,#0]            ;173
0000c8  b100              CBZ      r0,|L1.204|
0000ca  e7e0              B        |L1.142|
                  |L1.204|
0000cc  4620              MOV      r0,r4                 ;187
0000ce  f7fffffe          BL       OS_TaskInit
0000d2  8820              LDRH     r0,[r4,#0]            ;188
0000d4  b100              CBZ      r0,|L1.216|
0000d6  e7da              B        |L1.142|
                  |L1.216|
0000d8  4620              MOV      r0,r4                 ;201
0000da  f7fffffe          BL       OS_IdleTaskInit
0000de  8820              LDRH     r0,[r4,#0]            ;202
0000e0  b100              CBZ      r0,|L1.228|
0000e2  e7d4              B        |L1.142|
                  |L1.228|
0000e4  4620              MOV      r0,r4                 ;207
0000e6  f7fffffe          BL       OS_TickTaskInit
0000ea  8820              LDRH     r0,[r4,#0]            ;208
0000ec  b100              CBZ      r0,|L1.240|
0000ee  e7ce              B        |L1.142|
                  |L1.240|
0000f0  4620              MOV      r0,r4                 ;214
0000f2  f7fffffe          BL       OS_StatTaskInit
0000f6  8820              LDRH     r0,[r4,#0]            ;215
0000f8  b100              CBZ      r0,|L1.252|
0000fa  e7c8              B        |L1.142|
                  |L1.252|
0000fc  4620              MOV      r0,r4                 ;222
0000fe  f7fffffe          BL       OS_TmrInit
000102  8820              LDRH     r0,[r4,#0]            ;223
000104  b100              CBZ      r0,|L1.264|
000106  e7c2              B        |L1.142|
                  |L1.264|
000108  f7fffffe          BL       OS_Dbg_Init
00010c  f7fffffe          BL       OSCfg_Init
000110  bf00              NOP      
000112  e7bc              B        |L1.142|
;;;236    
                          ENDP

                  |L1.276|
                          DCD      OSIntNestingCtr
                  |L1.280|
                          DCD      OSRunning
                  |L1.284|
                          DCD      OSSchedLockNestingCtr
                  |L1.288|
                          DCD      OSTCBCurPtr
                  |L1.292|
                          DCD      OSTCBHighRdyPtr
                  |L1.296|
                          DCD      OSPrioCur
                  |L1.300|
                          DCD      OSPrioHighRdy
                  |L1.304|
                          DCD      OSPrioSaved
                  |L1.308|
                          DCD      OSSchedRoundRobinEn
                  |L1.312|
                          DCD      OSCfg_TickRate_Hz
                  |L1.316|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L1.320|
                          DCD      OSCfg_ISRStkSize
                  |L1.324|
                          DCD      OSCfg_ISRStkBasePtr
                  |L1.328|
                          DCD      OS_AppTaskCreateHookPtr
                  |L1.332|
                          DCD      OS_AppTaskDelHookPtr
                  |L1.336|
                          DCD      OS_AppTaskReturnHookPtr
                  |L1.340|
                          DCD      OS_AppIdleTaskHookPtr
                  |L1.344|
                          DCD      OS_AppStatTaskHookPtr
                  |L1.348|
                          DCD      OS_AppTaskSwHookPtr
                  |L1.352|
                          DCD      OS_AppTimeTickHookPtr
                  |L1.356|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;265    
;;;266    void  OSIntEnter (void)
000000  4808              LDR      r0,|L2.36|
;;;267    {
;;;268        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L2.10|
                  |L2.8|
;;;269            return;                                             /* No                                                     */
;;;270        }
;;;271    
;;;272        if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
;;;273            return;                                             /* Yes                                                    */
;;;274        }
;;;275    
;;;276        OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
;;;277    }
000008  4770              BX       lr
                  |L2.10|
00000a  4807              LDR      r0,|L2.40|
00000c  7800              LDRB     r0,[r0,#0]            ;272  ; OSIntNestingCtr
00000e  28fa              CMP      r0,#0xfa              ;272
000010  db00              BLT      |L2.20|
000012  e7f9              B        |L2.8|
                  |L2.20|
000014  4804              LDR      r0,|L2.40|
000016  7800              LDRB     r0,[r0,#0]            ;276  ; OSIntNestingCtr
000018  1c40              ADDS     r0,r0,#1              ;276
00001a  4903              LDR      r1,|L2.40|
00001c  7008              STRB     r0,[r1,#0]            ;276
00001e  bf00              NOP      
000020  e7f2              B        |L2.8|
;;;278    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      OSRunning
                  |L2.40|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;299    
;;;300    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;303    
;;;304    
;;;305    
;;;306        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
000004  482d              LDR      r0,|L3.188|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d000              BEQ      |L3.14|
                  |L3.12|
;;;307            return;                                             /* No                                                     */
;;;308        }
;;;309    
;;;310        CPU_INT_DIS();
;;;311        if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
;;;312            CPU_INT_EN();
;;;313            return;
;;;314        }
;;;315        OSIntNestingCtr--;
;;;316        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
;;;317            CPU_INT_EN();                                       /* Yes                                                    */
;;;318            return;
;;;319        }
;;;320    
;;;321        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
;;;322            CPU_INT_EN();                                       /* Yes                                                    */
;;;323            return;
;;;324        }
;;;325    
;;;326        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
;;;327        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
;;;328        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
;;;329            CPU_INT_EN();                                       /* Yes                                                    */
;;;330            return;
;;;331        }
;;;332    
;;;333    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;334        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
;;;335    #endif
;;;336        OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
;;;337    
;;;338    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;339        OS_TLS_TaskSw();
;;;340    #endif
;;;341    
;;;342        OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
;;;343        CPU_INT_EN();
;;;344    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  bf00              NOP                            ;310
000010  f7fffffe          BL       CPU_SR_Save
000014  4604              MOV      r4,r0                 ;310
000016  bf00              NOP                            ;310
000018  4829              LDR      r0,|L3.192|
00001a  7800              LDRB     r0,[r0,#0]            ;311  ; OSIntNestingCtr
00001c  b928              CBNZ     r0,|L3.42|
00001e  bf00              NOP                            ;312
000020  4620              MOV      r0,r4                 ;312
000022  f7fffffe          BL       CPU_SR_Restore
000026  bf00              NOP                            ;312
000028  e7f0              B        |L3.12|
                  |L3.42|
00002a  4825              LDR      r0,|L3.192|
00002c  7800              LDRB     r0,[r0,#0]            ;315  ; OSIntNestingCtr
00002e  1e40              SUBS     r0,r0,#1              ;315
000030  4923              LDR      r1,|L3.192|
000032  7008              STRB     r0,[r1,#0]            ;315
000034  4608              MOV      r0,r1                 ;316
000036  7800              LDRB     r0,[r0,#0]            ;316  ; OSIntNestingCtr
000038  2800              CMP      r0,#0                 ;316
00003a  dd05              BLE      |L3.72|
00003c  bf00              NOP                            ;317
00003e  4620              MOV      r0,r4                 ;317
000040  f7fffffe          BL       CPU_SR_Restore
000044  bf00              NOP                            ;317
000046  e7e1              B        |L3.12|
                  |L3.72|
000048  481e              LDR      r0,|L3.196|
00004a  7800              LDRB     r0,[r0,#0]            ;321  ; OSSchedLockNestingCtr
00004c  2800              CMP      r0,#0                 ;321
00004e  dd05              BLE      |L3.92|
000050  bf00              NOP                            ;322
000052  4620              MOV      r0,r4                 ;322
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;322
00005a  e7d7              B        |L3.12|
                  |L3.92|
00005c  f7fffffe          BL       OS_PrioGetHighest
000060  4919              LDR      r1,|L3.200|
000062  7008              STRB     r0,[r1,#0]            ;326
000064  4608              MOV      r0,r1                 ;327
000066  7800              LDRB     r0,[r0,#0]            ;327  ; OSPrioHighRdy
000068  eb000040          ADD      r0,r0,r0,LSL #1       ;327
00006c  4917              LDR      r1,|L3.204|
00006e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;327
000072  4917              LDR      r1,|L3.208|
000074  6008              STR      r0,[r1,#0]            ;327  ; OSTCBHighRdyPtr
000076  4608              MOV      r0,r1                 ;328
000078  6800              LDR      r0,[r0,#0]            ;328  ; OSTCBHighRdyPtr
00007a  4916              LDR      r1,|L3.212|
00007c  6809              LDR      r1,[r1,#0]            ;328  ; OSTCBCurPtr
00007e  4288              CMP      r0,r1                 ;328
000080  d105              BNE      |L3.142|
000082  bf00              NOP                            ;329
000084  4620              MOV      r0,r4                 ;329
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;329
00008c  e7be              B        |L3.12|
                  |L3.142|
00008e  4810              LDR      r0,|L3.208|
000090  6800              LDR      r0,[r0,#0]            ;334  ; OSTCBHighRdyPtr
000092  f8d00090          LDR      r0,[r0,#0x90]         ;334
000096  1c40              ADDS     r0,r0,#1              ;334
000098  490d              LDR      r1,|L3.208|
00009a  6809              LDR      r1,[r1,#0]            ;334  ; OSTCBHighRdyPtr
00009c  f8c10090          STR      r0,[r1,#0x90]         ;334
0000a0  480d              LDR      r0,|L3.216|
0000a2  6800              LDR      r0,[r0,#0]            ;336  ; OSTaskCtxSwCtr
0000a4  1c40              ADDS     r0,r0,#1              ;336
0000a6  490c              LDR      r1,|L3.216|
0000a8  6008              STR      r0,[r1,#0]            ;336  ; OSTaskCtxSwCtr
0000aa  f7fffffe          BL       OSIntCtxSw
0000ae  bf00              NOP                            ;343
0000b0  4620              MOV      r0,r4                 ;343
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP                            ;343
0000b8  bf00              NOP      
0000ba  e7a7              B        |L3.12|
;;;345    
                          ENDP

                  |L3.188|
                          DCD      OSRunning
                  |L3.192|
                          DCD      OSIntNestingCtr
                  |L3.196|
                          DCD      OSSchedLockNestingCtr
                  |L3.200|
                          DCD      OSPrioHighRdy
                  |L3.204|
                          DCD      OSRdyList
                  |L3.208|
                          DCD      OSTCBHighRdyPtr
                  |L3.212|
                          DCD      OSTCBCurPtr
                  |L3.216|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OSSched||, CODE, READONLY, ALIGN=2

                  OSSched PROC
;;;386    
;;;387    void  OSSched (void)
000000  b510              PUSH     {r4,lr}
;;;388    {
;;;389        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;390    
;;;391    
;;;392    
;;;393        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
000004  481f              LDR      r0,|L4.132|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  2800              CMP      r0,#0
00000a  dd00              BLE      |L4.14|
                  |L4.12|
;;;394            return;                                             /* Yes ... only schedule when no nested ISRs              */
;;;395        }
;;;396    
;;;397        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
;;;398            return;                                             /* Yes                                                    */
;;;399        }
;;;400    
;;;401        CPU_INT_DIS();
;;;402        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
;;;403        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
;;;404        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
;;;405            CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
;;;406            return;
;;;407        }
;;;408    
;;;409    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;410        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
;;;411    #endif
;;;412        OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
;;;413    
;;;414    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;415        OS_TLS_TaskSw();
;;;416    #endif
;;;417    
;;;418        OS_TASK_SW();                                           /* Perform a task level context switch                    */
;;;419        CPU_INT_EN();
;;;420    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  481e              LDR      r0,|L4.136|
000010  7800              LDRB     r0,[r0,#0]            ;397  ; OSSchedLockNestingCtr
000012  2800              CMP      r0,#0                 ;397
000014  dd00              BLE      |L4.24|
000016  e7f9              B        |L4.12|
                  |L4.24|
000018  bf00              NOP                            ;401
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4604              MOV      r4,r0                 ;401
000020  bf00              NOP                            ;401
000022  f7fffffe          BL       OS_PrioGetHighest
000026  4919              LDR      r1,|L4.140|
000028  7008              STRB     r0,[r1,#0]            ;402
00002a  4608              MOV      r0,r1                 ;403
00002c  7800              LDRB     r0,[r0,#0]            ;403  ; OSPrioHighRdy
00002e  eb000040          ADD      r0,r0,r0,LSL #1       ;403
000032  4917              LDR      r1,|L4.144|
000034  f8510020          LDR      r0,[r1,r0,LSL #2]     ;403
000038  4916              LDR      r1,|L4.148|
00003a  6008              STR      r0,[r1,#0]            ;403  ; OSTCBHighRdyPtr
00003c  4608              MOV      r0,r1                 ;404
00003e  6800              LDR      r0,[r0,#0]            ;404  ; OSTCBHighRdyPtr
000040  4915              LDR      r1,|L4.152|
000042  6809              LDR      r1,[r1,#0]            ;404  ; OSTCBCurPtr
000044  4288              CMP      r0,r1                 ;404
000046  d105              BNE      |L4.84|
000048  bf00              NOP                            ;405
00004a  4620              MOV      r0,r4                 ;405
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP                            ;405
000052  e7db              B        |L4.12|
                  |L4.84|
000054  480f              LDR      r0,|L4.148|
000056  6800              LDR      r0,[r0,#0]            ;410  ; OSTCBHighRdyPtr
000058  f8d00090          LDR      r0,[r0,#0x90]         ;410
00005c  1c40              ADDS     r0,r0,#1              ;410
00005e  490d              LDR      r1,|L4.148|
000060  6809              LDR      r1,[r1,#0]            ;410  ; OSTCBHighRdyPtr
000062  f8c10090          STR      r0,[r1,#0x90]         ;410
000066  480d              LDR      r0,|L4.156|
000068  6800              LDR      r0,[r0,#0]            ;412  ; OSTaskCtxSwCtr
00006a  1c40              ADDS     r0,r0,#1              ;412
00006c  490b              LDR      r1,|L4.156|
00006e  6008              STR      r0,[r1,#0]            ;412  ; OSTaskCtxSwCtr
000070  f7fffffe          BL       OSCtxSw
000074  bf00              NOP                            ;419
000076  4620              MOV      r0,r4                 ;419
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;419
00007e  bf00              NOP      
000080  e7c4              B        |L4.12|
;;;421    
                          ENDP

000082  0000              DCW      0x0000
                  |L4.132|
                          DCD      OSIntNestingCtr
                  |L4.136|
                          DCD      OSSchedLockNestingCtr
                  |L4.140|
                          DCD      OSPrioHighRdy
                  |L4.144|
                          DCD      OSRdyList
                  |L4.148|
                          DCD      OSTCBHighRdyPtr
                  |L4.152|
                          DCD      OSTCBCurPtr
                  |L4.156|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;443    
;;;444    void  OSSchedLock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;445    {
000002  4604              MOV      r4,r0
;;;446        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;447    
;;;448    
;;;449    
;;;450    #ifdef OS_SAFETY_CRITICAL
;;;451        if (p_err == (OS_ERR *)0) {
;;;452            OS_SAFETY_CRITICAL_EXCEPTION();
;;;453            return;
;;;454        }
;;;455    #endif
;;;456    
;;;457    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;458        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  4817              LDR      r0,|L5.100|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd03              BLE      |L5.22|
;;;459           *p_err = OS_ERR_SCHED_LOCK_ISR;
00000e  f6465062          MOV      r0,#0x6d62
000012  8020              STRH     r0,[r4,#0]
                  |L5.20|
;;;460            return;
;;;461        }
;;;462    #endif
;;;463    
;;;464        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
;;;465           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;466            return;
;;;467        }
;;;468    
;;;469        if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
;;;470           *p_err = OS_ERR_LOCK_NESTING_OVF;
;;;471            return;
;;;472        }
;;;473    
;;;474        CPU_CRITICAL_ENTER();
;;;475        OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
;;;476    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;477        OS_SchedLockTimeMeasStart();
;;;478    #endif
;;;479        CPU_CRITICAL_EXIT();
;;;480       *p_err = OS_ERR_NONE;
;;;481    }
000014  bd70              POP      {r4-r6,pc}
                  |L5.22|
000016  4814              LDR      r0,|L5.104|
000018  7800              LDRB     r0,[r0,#0]            ;464  ; OSRunning
00001a  2801              CMP      r0,#1                 ;464
00001c  d003              BEQ      |L5.38|
00001e  f6456089          MOV      r0,#0x5e89            ;465
000022  8020              STRH     r0,[r4,#0]            ;465
000024  e7f6              B        |L5.20|
                  |L5.38|
000026  4811              LDR      r0,|L5.108|
000028  7800              LDRB     r0,[r0,#0]            ;469  ; OSSchedLockNestingCtr
00002a  28fa              CMP      r0,#0xfa              ;469
00002c  db03              BLT      |L5.54|
00002e  f2452009          MOV      r0,#0x5209            ;470
000032  8020              STRH     r0,[r4,#0]            ;470
000034  e7ee              B        |L5.20|
                  |L5.54|
000036  bf00              NOP                            ;474
000038  bf00              NOP                            ;474
00003a  f7fffffe          BL       CPU_SR_Save
00003e  4605              MOV      r5,r0                 ;474
000040  bf00              NOP                            ;474
000042  bf00              NOP                            ;474
000044  4809              LDR      r0,|L5.108|
000046  7800              LDRB     r0,[r0,#0]            ;475  ; OSSchedLockNestingCtr
000048  1c40              ADDS     r0,r0,#1              ;475
00004a  4908              LDR      r1,|L5.108|
00004c  7008              STRB     r0,[r1,#0]            ;475
00004e  bf00              NOP                            ;479
000050  bf00              NOP                            ;479
000052  4628              MOV      r0,r5                 ;479
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;479
00005a  bf00              NOP                            ;479
00005c  2000              MOVS     r0,#0                 ;480
00005e  8020              STRH     r0,[r4,#0]            ;480
000060  bf00              NOP      
000062  e7d7              B        |L5.20|
;;;482    
                          ENDP

                  |L5.100|
                          DCD      OSIntNestingCtr
                  |L5.104|
                          DCD      OSRunning
                  |L5.108|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSchedRoundRobinCfg||, CODE, READONLY, ALIGN=2

                  OSSchedRoundRobinCfg PROC
;;;571    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;572    void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573                                OS_TICK       dflt_time_quanta,
;;;574                                OS_ERR       *p_err)
;;;575    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;576        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;577    
;;;578    
;;;579    
;;;580    #ifdef OS_SAFETY_CRITICAL
;;;581        if (p_err == (OS_ERR *)0) {
;;;582            OS_SAFETY_CRITICAL_EXCEPTION();
;;;583            return;
;;;584        }
;;;585    #endif
;;;586    
;;;587        CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;588        if (en != DEF_ENABLED) {
00001a  2d01              CMP      r5,#1
00001c  d003              BEQ      |L6.38|
;;;589            OSSchedRoundRobinEn = DEF_DISABLED;
00001e  2000              MOVS     r0,#0
000020  490d              LDR      r1,|L6.88|
000022  7008              STRB     r0,[r1,#0]
000024  e002              B        |L6.44|
                  |L6.38|
;;;590        } else {
;;;591            OSSchedRoundRobinEn = DEF_ENABLED;
000026  2001              MOVS     r0,#1
000028  490b              LDR      r1,|L6.88|
00002a  7008              STRB     r0,[r1,#0]
                  |L6.44|
;;;592        }
;;;593    
;;;594        if (dflt_time_quanta > (OS_TICK)0) {
00002c  b114              CBZ      r4,|L6.52|
;;;595            OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
00002e  480b              LDR      r0,|L6.92|
000030  6004              STR      r4,[r0,#0]  ; OSSchedRoundRobinDfltTimeQuanta
000032  e006              B        |L6.66|
                  |L6.52|
;;;596        } else {
;;;597            OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
000034  480a              LDR      r0,|L6.96|
000036  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000038  210a              MOVS     r1,#0xa
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  4907              LDR      r1,|L6.92|
000040  6008              STR      r0,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
                  |L6.66|
;;;598        }
;;;599        CPU_CRITICAL_EXIT();
000042  bf00              NOP      
000044  bf00              NOP      
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       CPU_SR_Restore
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;600       *p_err = OS_ERR_NONE;
000050  2000              MOVS     r0,#0
000052  8030              STRH     r0,[r6,#0]
;;;601    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;602    #endif
                          ENDP

                  |L6.88|
                          DCD      OSSchedRoundRobinEn
                  |L6.92|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L6.96|
                          DCD      OSCfg_TickRate_Hz

                          AREA ||i.OSSchedRoundRobinYield||, CODE, READONLY, ALIGN=2

                  OSSchedRoundRobinYield PROC
;;;625    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;626    void  OSSchedRoundRobinYield (OS_ERR  *p_err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;627    {
000004  4604              MOV      r4,r0
;;;628        OS_RDY_LIST  *p_rdy_list;
;;;629        OS_TCB       *p_tcb;
;;;630        CPU_SR_ALLOC();
000006  2700              MOVS     r7,#0
;;;631    
;;;632    
;;;633    
;;;634    #ifdef OS_SAFETY_CRITICAL
;;;635        if (p_err == (OS_ERR *)0) {
;;;636            OS_SAFETY_CRITICAL_EXCEPTION();
;;;637            return;
;;;638        }
;;;639    #endif
;;;640    
;;;641    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;642        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
000008  4826              LDR      r0,|L7.164|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  2800              CMP      r0,#0
00000e  dd04              BLE      |L7.26|
;;;643           *p_err = OS_ERR_YIELD_ISR;
000010  f24840d1          MOV      r0,#0x84d1
000014  8020              STRH     r0,[r4,#0]
                  |L7.22|
;;;644            return;
;;;645        }
;;;646    #endif
;;;647    
;;;648        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
;;;649           *p_err = OS_ERR_SCHED_LOCKED;
;;;650            return;
;;;651        }
;;;652    
;;;653        if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
;;;654           *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
;;;655            return;
;;;656        }
;;;657    
;;;658        CPU_CRITICAL_ENTER();
;;;659        p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
;;;660        if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
;;;661            CPU_CRITICAL_EXIT();
;;;662           *p_err = OS_ERR_ROUND_ROBIN_1;
;;;663            return;
;;;664        }
;;;665    
;;;666        OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
;;;667        p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
;;;668        if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
;;;669            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;670        } else {
;;;671            p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
;;;672        }
;;;673    
;;;674        CPU_CRITICAL_EXIT();
;;;675    
;;;676        OSSched();                                              /* Run new task                                           */
;;;677       *p_err = OS_ERR_NONE;
;;;678    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  4823              LDR      r0,|L7.168|
00001c  7800              LDRB     r0,[r0,#0]            ;648  ; OSSchedLockNestingCtr
00001e  2800              CMP      r0,#0                 ;648
000020  dd03              BLE      |L7.42|
000022  f6465063          MOV      r0,#0x6d63            ;649
000026  8020              STRH     r0,[r4,#0]            ;649
000028  e7f5              B        |L7.22|
                  |L7.42|
00002a  4820              LDR      r0,|L7.172|
00002c  7800              LDRB     r0,[r0,#0]            ;653  ; OSSchedRoundRobinEn
00002e  2801              CMP      r0,#1                 ;653
000030  d003              BEQ      |L7.58|
000032  f646107b          MOV      r0,#0x697b            ;654
000036  8020              STRH     r0,[r4,#0]            ;654
000038  e7ed              B        |L7.22|
                  |L7.58|
00003a  bf00              NOP                            ;658
00003c  bf00              NOP                            ;658
00003e  f7fffffe          BL       CPU_SR_Save
000042  4607              MOV      r7,r0                 ;658
000044  bf00              NOP                            ;658
000046  bf00              NOP                            ;658
000048  4819              LDR      r0,|L7.176|
00004a  7800              LDRB     r0,[r0,#0]            ;659  ; OSPrioCur
00004c  eb000040          ADD      r0,r0,r0,LSL #1       ;659
000050  4918              LDR      r1,|L7.180|
000052  eb010680          ADD      r6,r1,r0,LSL #2       ;659
000056  8930              LDRH     r0,[r6,#8]            ;660
000058  2802              CMP      r0,#2                 ;660
00005a  da0a              BGE      |L7.114|
00005c  bf00              NOP                            ;661
00005e  bf00              NOP                            ;661
000060  4638              MOV      r0,r7                 ;661
000062  f7fffffe          BL       CPU_SR_Restore
000066  bf00              NOP                            ;661
000068  bf00              NOP                            ;661
00006a  f646107a          MOV      r0,#0x697a            ;662
00006e  8020              STRH     r0,[r4,#0]            ;662
000070  e7d1              B        |L7.22|
                  |L7.114|
000072  4630              MOV      r0,r6                 ;666
000074  f7fffffe          BL       OS_RdyListMoveHeadToTail
000078  6835              LDR      r5,[r6,#0]            ;667
00007a  6d68              LDR      r0,[r5,#0x54]         ;668
00007c  b918              CBNZ     r0,|L7.134|
00007e  480e              LDR      r0,|L7.184|
000080  6800              LDR      r0,[r0,#0]            ;669  ; OSSchedRoundRobinDfltTimeQuanta
000082  65a8              STR      r0,[r5,#0x58]         ;669
000084  e001              B        |L7.138|
                  |L7.134|
000086  6d68              LDR      r0,[r5,#0x54]         ;671
000088  65a8              STR      r0,[r5,#0x58]         ;671
                  |L7.138|
00008a  bf00              NOP                            ;674
00008c  bf00              NOP                            ;674
00008e  4638              MOV      r0,r7                 ;674
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;674
000096  bf00              NOP                            ;674
000098  f7fffffe          BL       OSSched
00009c  2000              MOVS     r0,#0                 ;677
00009e  8020              STRH     r0,[r4,#0]            ;677
0000a0  bf00              NOP      
0000a2  e7b8              B        |L7.22|
;;;679    #endif
                          ENDP

                  |L7.164|
                          DCD      OSIntNestingCtr
                  |L7.168|
                          DCD      OSSchedLockNestingCtr
                  |L7.172|
                          DCD      OSSchedRoundRobinEn
                  |L7.176|
                          DCD      OSPrioCur
                  |L7.180|
                          DCD      OSRdyList
                  |L7.184|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;504    
;;;505    void  OSSchedUnlock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;506    {
000002  4604              MOV      r4,r0
;;;507        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;508    
;;;509    
;;;510    
;;;511    #ifdef OS_SAFETY_CRITICAL
;;;512        if (p_err == (OS_ERR *)0) {
;;;513            OS_SAFETY_CRITICAL_EXCEPTION();
;;;514            return;
;;;515        }
;;;516    #endif
;;;517    
;;;518    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;519        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  481f              LDR      r0,|L8.132|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd03              BLE      |L8.22|
;;;520           *p_err = OS_ERR_SCHED_UNLOCK_ISR;
00000e  f6465065          MOV      r0,#0x6d65
000012  8020              STRH     r0,[r4,#0]
                  |L8.20|
;;;521            return;
;;;522        }
;;;523    #endif
;;;524    
;;;525        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
;;;526           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;527            return;
;;;528        }
;;;529    
;;;530        if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
;;;531           *p_err = OS_ERR_SCHED_NOT_LOCKED;
;;;532            return;
;;;533        }
;;;534    
;;;535        CPU_CRITICAL_ENTER();
;;;536        OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
;;;537        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
;;;538            CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
;;;539           *p_err = OS_ERR_SCHED_LOCKED;
;;;540            return;
;;;541        }
;;;542    
;;;543    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;544        OS_SchedLockTimeMeasStop();
;;;545    #endif
;;;546    
;;;547        CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
;;;548        OSSched();                                              /* Run the scheduler                                      */
;;;549       *p_err = OS_ERR_NONE;
;;;550    }
000014  bd70              POP      {r4-r6,pc}
                  |L8.22|
000016  481c              LDR      r0,|L8.136|
000018  7800              LDRB     r0,[r0,#0]            ;525  ; OSRunning
00001a  2801              CMP      r0,#1                 ;525
00001c  d003              BEQ      |L8.38|
00001e  f6456089          MOV      r0,#0x5e89            ;526
000022  8020              STRH     r0,[r4,#0]            ;526
000024  e7f6              B        |L8.20|
                  |L8.38|
000026  4819              LDR      r0,|L8.140|
000028  7800              LDRB     r0,[r0,#0]            ;530  ; OSSchedLockNestingCtr
00002a  b918              CBNZ     r0,|L8.52|
00002c  f6465064          MOV      r0,#0x6d64            ;531
000030  8020              STRH     r0,[r4,#0]            ;531
000032  e7ef              B        |L8.20|
                  |L8.52|
000034  bf00              NOP                            ;535
000036  bf00              NOP                            ;535
000038  f7fffffe          BL       CPU_SR_Save
00003c  4605              MOV      r5,r0                 ;535
00003e  bf00              NOP                            ;535
000040  bf00              NOP                            ;535
000042  4812              LDR      r0,|L8.140|
000044  7800              LDRB     r0,[r0,#0]            ;536  ; OSSchedLockNestingCtr
000046  1e40              SUBS     r0,r0,#1              ;536
000048  4910              LDR      r1,|L8.140|
00004a  7008              STRB     r0,[r1,#0]            ;536
00004c  4608              MOV      r0,r1                 ;537
00004e  7800              LDRB     r0,[r0,#0]            ;537  ; OSSchedLockNestingCtr
000050  2800              CMP      r0,#0                 ;537
000052  dd0a              BLE      |L8.106|
000054  bf00              NOP                            ;538
000056  bf00              NOP                            ;538
000058  4628              MOV      r0,r5                 ;538
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP                            ;538
000060  bf00              NOP                            ;538
000062  f6465063          MOV      r0,#0x6d63            ;539
000066  8020              STRH     r0,[r4,#0]            ;539
000068  e7d4              B        |L8.20|
                  |L8.106|
00006a  bf00              NOP                            ;547
00006c  bf00              NOP                            ;547
00006e  4628              MOV      r0,r5                 ;547
000070  f7fffffe          BL       CPU_SR_Restore
000074  bf00              NOP                            ;547
000076  bf00              NOP                            ;547
000078  f7fffffe          BL       OSSched
00007c  2000              MOVS     r0,#0                 ;549
00007e  8020              STRH     r0,[r4,#0]            ;549
000080  bf00              NOP      
000082  e7c7              B        |L8.20|
;;;551    
                          ENDP

                  |L8.132|
                          DCD      OSIntNestingCtr
                  |L8.136|
                          DCD      OSRunning
                  |L8.140|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;705    
;;;706    void  OSStart (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;707    {
000002  4604              MOV      r4,r0
;;;708    #ifdef OS_SAFETY_CRITICAL
;;;709        if (p_err == (OS_ERR *)0) {
;;;710            OS_SAFETY_CRITICAL_EXCEPTION();
;;;711            return;
;;;712        }
;;;713    #endif
;;;714    
;;;715        if (OSRunning == OS_STATE_OS_STOPPED) {
000004  4812              LDR      r0,|L9.80|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  b9e8              CBNZ     r0,|L9.70|
;;;716            OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
00000a  f7fffffe          BL       OS_PrioGetHighest
00000e  4911              LDR      r1,|L9.84|
000010  7008              STRB     r0,[r1,#0]
;;;717            OSPrioCur       = OSPrioHighRdy;
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000016  4910              LDR      r1,|L9.88|
000018  7008              STRB     r0,[r1,#0]
;;;718            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
00001a  480e              LDR      r0,|L9.84|
00001c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00001e  eb000040          ADD      r0,r0,r0,LSL #1
000022  490e              LDR      r1,|L9.92|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  490d              LDR      r1,|L9.96|
00002a  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
;;;719            OSTCBCurPtr     = OSTCBHighRdyPtr;
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdyPtr
000030  490c              LDR      r1,|L9.100|
000032  6008              STR      r0,[r1,#0]  ; OSTCBCurPtr
;;;720            OSRunning       = OS_STATE_OS_RUNNING;
000034  2001              MOVS     r0,#1
000036  4906              LDR      r1,|L9.80|
000038  7008              STRB     r0,[r1,#0]
;;;721            OSStartHighRdy();                                   /* Execute target specific code to start task             */
00003a  f7fffffe          BL       OSStartHighRdy
;;;722           *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
00003e  f6432099          MOV      r0,#0x3a99
000042  8020              STRH     r0,[r4,#0]
000044  e002              B        |L9.76|
                  |L9.70|
;;;723        } else {
;;;724           *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
000046  f645608a          MOV      r0,#0x5e8a
00004a  8020              STRH     r0,[r4,#0]
                  |L9.76|
;;;725        }
;;;726    }
00004c  bd10              POP      {r4,pc}
;;;727    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      OSRunning
                  |L9.84|
                          DCD      OSPrioHighRdy
                  |L9.88|
                          DCD      OSPrioCur
                  |L9.92|
                          DCD      OSRdyList
                  |L9.96|
                          DCD      OSTCBHighRdyPtr
                  |L9.100|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;744    
;;;745    CPU_INT16U  OSVersion (OS_ERR  *p_err)
000000  4601              MOV      r1,r0
;;;746    {
;;;747    #ifdef OS_SAFETY_CRITICAL
;;;748        if (p_err == (OS_ERR *)0) {
;;;749            OS_SAFETY_CRITICAL_EXCEPTION();
;;;750            return ((CPU_INT16U)0u);
;;;751        }
;;;752    #endif
;;;753    
;;;754       *p_err = OS_ERR_NONE;
000002  2000              MOVS     r0,#0
000004  8008              STRH     r0,[r1,#0]
;;;755        return (OS_VERSION);
000006  f247605d          MOV      r0,#0x765d
;;;756    }
00000a  4770              BX       lr
;;;757    
                          ENDP


                          AREA ||i.OS_IdleTask||, CODE, READONLY, ALIGN=2

                  OS_IdleTask PROC
;;;780    
;;;781    void  OS_IdleTask (void  *p_arg)
000000  2400              MOVS     r4,#0
;;;782    {
;;;783        CPU_SR_ALLOC();
;;;784    
;;;785    
;;;786    
;;;787        p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
000002  bf00              NOP      
;;;788    
;;;789        while (DEF_ON) {
000004  e019              B        |L11.58|
                  |L11.6|
;;;790            CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4604              MOV      r4,r0
000010  bf00              NOP      
000012  bf00              NOP      
;;;791            OSIdleTaskCtr++;
000014  4809              LDR      r0,|L11.60|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleTaskCtr
000018  1c40              ADDS     r0,r0,#1
00001a  4908              LDR      r1,|L11.60|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;792    #if OS_CFG_STAT_TASK_EN > 0u
;;;793            OSStatTaskCtr++;
00001e  4808              LDR      r0,|L11.64|
000020  6800              LDR      r0,[r0,#0]  ; OSStatTaskCtr
000022  1c40              ADDS     r0,r0,#1
000024  4906              LDR      r1,|L11.64|
000026  6008              STR      r0,[r1,#0]  ; OSStatTaskCtr
;;;794    #endif
;;;795            CPU_CRITICAL_EXIT();
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       CPU_SR_Restore
000032  bf00              NOP      
000034  bf00              NOP      
;;;796    
;;;797            OSIdleTaskHook();                                   /* Call user definable HOOK                               */
000036  f7fffffe          BL       OSIdleTaskHook
                  |L11.58|
00003a  e7e4              B        |L11.6|
;;;798        }
;;;799    }
;;;800    
                          ENDP

                  |L11.60|
                          DCD      OSIdleTaskCtr
                  |L11.64|
                          DCD      OSStatTaskCtr

                          AREA ||i.OS_IdleTaskInit||, CODE, READONLY, ALIGN=2

                  OS_IdleTaskInit PROC
;;;815    
;;;816    void  OS_IdleTaskInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;817    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;818    #ifdef OS_SAFETY_CRITICAL
;;;819        if (p_err == (OS_ERR *)0) {
;;;820            OS_SAFETY_CRITICAL_EXCEPTION();
;;;821            return;
;;;822        }
;;;823    #endif
;;;824    
;;;825        OSIdleTaskCtr = (OS_IDLE_CTR)0;
000006  2000              MOVS     r0,#0
000008  490e              LDR      r1,|L12.68|
00000a  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;826                                                                /* ---------------- CREATE THE IDLE TASK ---------------- */
;;;827        OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
00000c  200b              MOVS     r0,#0xb
00000e  2100              MOVS     r1,#0
000010  9105              STR      r1,[sp,#0x14]
000012  e9cd0407          STRD     r0,r4,[sp,#0x1c]
000016  9106              STR      r1,[sp,#0x18]
000018  4608              MOV      r0,r1
00001a  490b              LDR      r1,|L12.72|
00001c  6809              LDR      r1,[r1,#0]  ; OSCfg_IdleTaskStkSize
00001e  4a0b              LDR      r2,|L12.76|
000020  6812              LDR      r2,[r2,#0]  ; OSCfg_IdleTaskStkLimit
000022  4b0b              LDR      r3,|L12.80|
000024  681b              LDR      r3,[r3,#0]  ; OSCfg_IdleTaskStkBasePtr
000026  e9cd3201          STRD     r3,r2,[sp,#4]
00002a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00002e  203f              MOVS     r0,#0x3f
000030  2300              MOVS     r3,#0
000032  4a08              LDR      r2,|L12.84|
000034  a108              ADR      r1,|L12.88|
000036  9000              STR      r0,[sp,#0]
000038  480c              LDR      r0,|L12.108|
00003a  f7fffffe          BL       OSTaskCreate
;;;828                     (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
;;;829                     (OS_TASK_PTR)OS_IdleTask,
;;;830                     (void       *)0,
;;;831                     (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
;;;832                     (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
;;;833                     (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
;;;834                     (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
;;;835                     (OS_MSG_QTY  )0u,
;;;836                     (OS_TICK     )0u,
;;;837                     (void       *)0,
;;;838                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;839                     (OS_ERR     *)p_err);
;;;840    }
00003e  b00a              ADD      sp,sp,#0x28
000040  bd10              POP      {r4,pc}
;;;841    
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      OSIdleTaskCtr
                  |L12.72|
                          DCD      OSCfg_IdleTaskStkSize
                  |L12.76|
                          DCD      OSCfg_IdleTaskStkLimit
                  |L12.80|
                          DCD      OSCfg_IdleTaskStkBasePtr
                  |L12.84|
                          DCD      OS_IdleTask
                  |L12.88|
000058  75432f4f          DCB      "uC/OS-III Idle Task",0
00005c  532d4949
000060  49204964
000064  6c652054
000068  61736b00
                  |L12.108|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_Pend||, CODE, READONLY, ALIGN=2

                  OS_Pend PROC
;;;872    
;;;873    void  OS_Pend (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;874                   OS_PEND_OBJ   *p_obj,
;;;875                   OS_STATE       pending_on,
;;;876                   OS_TICK        timeout)
;;;877    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;878        OS_PEND_LIST  *p_pend_list;
;;;879    
;;;880    
;;;881    
;;;882        OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
00000c  4815              LDR      r0,|L13.100|
00000e  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000010  f8806034          STRB     r6,[r0,#0x34]
;;;883        OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
000014  2000              MOVS     r0,#0
000016  4913              LDR      r1,|L13.100|
000018  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00001a  f8810035          STRB     r0,[r1,#0x35]
;;;884    
;;;885        OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
00001e  4639              MOV      r1,r7
000020  4810              LDR      r0,|L13.100|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000024  f7fffffe          BL       OS_TaskBlock
;;;886                     timeout);
;;;887    
;;;888        if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
000028  b16c              CBZ      r4,|L13.70|
;;;889            p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
00002a  f1040808          ADD      r8,r4,#8
;;;890            p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
00002e  60ec              STR      r4,[r5,#0xc]
;;;891            OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
000030  2201              MOVS     r2,#1
000032  4629              MOV      r1,r5
000034  480b              LDR      r0,|L13.100|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000038  f7fffffe          BL       OS_PendDataInit
;;;892                            (OS_PEND_DATA *)p_pend_data,
;;;893                            (OS_OBJ_QTY    )1);
;;;894            OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
00003c  4629              MOV      r1,r5
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       OS_PendListInsertPrio
000044  e006              B        |L13.84|
                  |L13.70|
;;;895                                  p_pend_data);
;;;896        } else {
;;;897            OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
000046  2000              MOVS     r0,#0
000048  4906              LDR      r1,|L13.100|
00004a  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00004c  87c8              STRH     r0,[r1,#0x3e]
;;;898            OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
00004e  4905              LDR      r1,|L13.100|
000050  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000052  6308              STR      r0,[r1,#0x30]
                  |L13.84|
;;;899        }
;;;900    #if OS_CFG_DBG_EN > 0u
;;;901        OS_PendDbgNameAdd(p_obj,
000054  4803              LDR      r0,|L13.100|
000056  6801              LDR      r1,[r0,#0]  ; OSTCBCurPtr
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       OS_PendDbgNameAdd
;;;902                          OSTCBCurPtr);
;;;903    #endif
;;;904    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;905    
                          ENDP

000062  0000              DCW      0x0000
                  |L13.100|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_PendAbort||, CODE, READONLY, ALIGN=1

                  OS_PendAbort PROC
;;;926    
;;;927    void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;928                        OS_TCB       *p_tcb,
;;;929                        CPU_TS        ts)
;;;930    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;931        switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d247              BCS      |L14.160|
000010  e8dff000          TBB      [pc,r0]
000014  04050809          DCB      0x04,0x05,0x08,0x09
000018  06072728          DCB      0x06,0x07,0x27,0x28
;;;932            case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
;;;933            case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
00001c  bf00              NOP      
;;;934            case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
00001e  bf00              NOP      
;;;935            case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
000020  bf00              NOP      
;;;936                 break;
000022  e03e              B        |L14.162|
;;;937    
;;;938            case OS_TASK_STATE_PEND:
;;;939            case OS_TASK_STATE_PEND_TIMEOUT:
000024  bf00              NOP      
;;;940                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000026  f8940034          LDRB     r0,[r4,#0x34]
00002a  2803              CMP      r0,#3
00002c  d104              BNE      |L14.56|
;;;941                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
00002e  4632              MOV      r2,r6
000030  4621              MOV      r1,r4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       OS_PendAbort1
                  |L14.56|
;;;942                                   p_tcb,
;;;943                                   ts);
;;;944                 }
;;;945    #if (OS_MSG_EN > 0u)
;;;946                 p_tcb->MsgPtr     = (void      *)0;
000038  2000              MOVS     r0,#0
00003a  65e0              STR      r0,[r4,#0x5c]
;;;947                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00003c  f8a40060          STRH     r0,[r4,#0x60]
;;;948    #endif
;;;949                 p_tcb->TS         = ts;
000040  6426              STR      r6,[r4,#0x40]
;;;950                 if (p_obj != (OS_PEND_OBJ *)0) {
000042  b115              CBZ      r5,|L14.74|
;;;951                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_PendListRemove
                  |L14.74|
;;;952                 }
;;;953                 OS_TaskRdy(p_tcb);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_TaskRdy
;;;954                 p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
000050  2000              MOVS     r0,#0
000052  3434              ADDS     r4,r4,#0x34
000054  70a0              STRB     r0,[r4,#2]
;;;955                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
000056  2001              MOVS     r0,#1
000058  7060              STRB     r0,[r4,#1]
;;;956                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
00005a  2000              MOVS     r0,#0
00005c  f8040934          STRB     r0,[r4],#-0x34
;;;957                 break;
000060  e01f              B        |L14.162|
;;;958    
;;;959            case OS_TASK_STATE_PEND_SUSPENDED:
;;;960            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000062  bf00              NOP      
;;;961                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000064  f8940034          LDRB     r0,[r4,#0x34]
000068  2803              CMP      r0,#3
00006a  d104              BNE      |L14.118|
;;;962                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
00006c  4632              MOV      r2,r6
00006e  4621              MOV      r1,r4
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       OS_PendAbort1
                  |L14.118|
;;;963                                   p_tcb,
;;;964                                   ts);
;;;965                 }
;;;966    #if (OS_MSG_EN > 0u)
;;;967                 p_tcb->MsgPtr     = (void      *)0;
000076  2000              MOVS     r0,#0
000078  65e0              STR      r0,[r4,#0x5c]
;;;968                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00007a  f8a40060          STRH     r0,[r4,#0x60]
;;;969    #endif
;;;970                 p_tcb->TS         = ts;
00007e  6426              STR      r6,[r4,#0x40]
;;;971                 if (p_obj != (OS_PEND_OBJ *)0) {
000080  b115              CBZ      r5,|L14.136|
;;;972                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       OS_PendListRemove
                  |L14.136|
;;;973                 }
;;;974                 OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       OS_TickListRemove
;;;975                 p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
00008e  2004              MOVS     r0,#4
000090  3434              ADDS     r4,r4,#0x34
000092  70a0              STRB     r0,[r4,#2]
;;;976                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
000094  2001              MOVS     r0,#1
000096  7060              STRB     r0,[r4,#1]
;;;977                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000098  2000              MOVS     r0,#0
00009a  f8040934          STRB     r0,[r4],#-0x34
;;;978                 break;
00009e  e000              B        |L14.162|
                  |L14.160|
;;;979    
;;;980            default:
;;;981                 break;
0000a0  bf00              NOP      
                  |L14.162|
0000a2  bf00              NOP                            ;936
;;;982        }
;;;983    }
0000a4  bd70              POP      {r4-r6,pc}
;;;984    
                          ENDP


                          AREA ||i.OS_PendAbort1||, CODE, READONLY, ALIGN=1

                  OS_PendAbort1 PROC
;;;1032   
;;;1033   void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1034                        OS_TCB       *p_tcb,
;;;1035                        CPU_TS        ts)
;;;1036   {
000002  4603              MOV      r3,r0
;;;1037       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1038       OS_PEND_DATA   *p_pend_data;
;;;1039   
;;;1040   
;;;1041   
;;;1042       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000004  6b08              LDR      r0,[r1,#0x30]
;;;1043       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000006  8fcc              LDRH     r4,[r1,#0x3e]
;;;1044   
;;;1045       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
000008  e008              B        |L15.28|
                  |L15.10|
;;;1046           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
00000a  68c5              LDR      r5,[r0,#0xc]
00000c  429d              CMP      r5,r3
00000e  d102              BNE      |L15.22|
;;;1047               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
000010  6103              STR      r3,[r0,#0x10]
;;;1048               p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
000012  61c2              STR      r2,[r0,#0x1c]
;;;1049               break;
000014  e004              B        |L15.32|
                  |L15.22|
;;;1050           }
;;;1051           p_pend_data++;
000016  3020              ADDS     r0,r0,#0x20
;;;1052           n_pend_list--;
000018  1e65              SUBS     r5,r4,#1
00001a  b2ac              UXTH     r4,r5
                  |L15.28|
00001c  2c00              CMP      r4,#0                 ;1045
00001e  dcf4              BGT      |L15.10|
                  |L15.32|
000020  bf00              NOP                            ;1049
;;;1053       }
;;;1054   }
000022  bd30              POP      {r4,r5,pc}
;;;1055   
                          ENDP


                          AREA ||i.OS_PendDataInit||, CODE, READONLY, ALIGN=1

                  OS_PendDataInit PROC
;;;1097   
;;;1098   void  OS_PendDataInit (OS_TCB        *p_tcb,
000000  b510              PUSH     {r4,lr}
;;;1099                          OS_PEND_DATA  *p_pend_data_tbl,
;;;1100                          OS_OBJ_QTY     tbl_size)
;;;1101   {
;;;1102       OS_OBJ_QTY  i;
;;;1103   
;;;1104   
;;;1105   
;;;1106       p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
000002  87c2              STRH     r2,[r0,#0x3e]
;;;1107       p_tcb->PendDataTblPtr     = p_pend_data_tbl;
000004  6301              STR      r1,[r0,#0x30]
;;;1108   
;;;1109       for (i = 0u; i < tbl_size; i++) {
000006  2300              MOVS     r3,#0
000008  e00a              B        |L16.32|
                  |L16.10|
;;;1110           p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
00000a  2400              MOVS     r4,#0
00000c  604c              STR      r4,[r1,#4]
;;;1111           p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
00000e  600c              STR      r4,[r1,#0]
;;;1112           p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
000010  610c              STR      r4,[r1,#0x10]
;;;1113           p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
000012  614c              STR      r4,[r1,#0x14]
;;;1114           p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
000014  830c              STRH     r4,[r1,#0x18]
;;;1115           p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
000016  61cc              STR      r4,[r1,#0x1c]
;;;1116           p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
000018  6088              STR      r0,[r1,#8]
;;;1117           p_pend_data_tbl++;
00001a  3120              ADDS     r1,r1,#0x20
00001c  1c5c              ADDS     r4,r3,#1              ;1109
00001e  b2a3              UXTH     r3,r4                 ;1109
                  |L16.32|
000020  4293              CMP      r3,r2                 ;1109
000022  dbf2              BLT      |L16.10|
;;;1118       }
;;;1119   }
000024  bd10              POP      {r4,pc}
;;;1120   
                          ENDP


                          AREA ||i.OS_PendDbgNameAdd||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameAdd PROC
;;;1140   #if OS_CFG_DBG_EN > 0u
;;;1141   void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1142                            OS_TCB       *p_tcb)
;;;1143   {
;;;1144       OS_PEND_LIST  *p_pend_list;
;;;1145       OS_PEND_DATA  *p_pend_data;
;;;1146       OS_TCB        *p_tcb1;
;;;1147   
;;;1148   
;;;1149       if (p_obj != (OS_PEND_OBJ *)0) {
000002  b148              CBZ      r0,|L17.24|
;;;1150           p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
000004  6845              LDR      r5,[r0,#4]
000006  f8c150bc          STR      r5,[r1,#0xbc]
;;;1151           p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
00000a  f1000408          ADD      r4,r0,#8
;;;1152           p_pend_data       =  p_pend_list->HeadPtr;
00000e  6822              LDR      r2,[r4,#0]
;;;1153           p_tcb1            =  p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1154           p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
000012  6a1d              LDR      r5,[r3,#0x20]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e013              B        |L17.64|
                  |L17.24|
;;;1155       } else {
;;;1156           switch (p_tcb->PendOn) {
000018  f8915034          LDRB     r5,[r1,#0x34]
00001c  2d02              CMP      r5,#2
00001e  d002              BEQ      |L17.38|
000020  2d07              CMP      r5,#7
000022  d108              BNE      |L17.54|
000024  e003              B        |L17.46|
                  |L17.38|
;;;1157               case OS_TASK_PEND_ON_TASK_Q:
;;;1158                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
000026  a507              ADR      r5,|L17.68|
000028  f8c150bc          STR      r5,[r1,#0xbc]
;;;1159                    break;
00002c  e007              B        |L17.62|
                  |L17.46|
;;;1160   
;;;1161               case OS_TASK_PEND_ON_TASK_SEM:
;;;1162                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
00002e  a507              ADR      r5,|L17.76|
000030  f8c150bc          STR      r5,[r1,#0xbc]
;;;1163                    break;
000034  e003              B        |L17.62|
                  |L17.54|
;;;1164   
;;;1165               default:
;;;1166                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
000036  a508              ADR      r5,|L17.88|
000038  f8c150bc          STR      r5,[r1,#0xbc]
;;;1167                    break;
00003c  bf00              NOP      
                  |L17.62|
00003e  bf00              NOP                            ;1159
                  |L17.64|
;;;1168           }
;;;1169       }
;;;1170   }
000040  bd30              POP      {r4,r5,pc}
;;;1171   
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
000044  5461736b          DCB      "Task Q",0
000048  205100  
00004b  00                DCB      0
                  |L17.76|
00004c  5461736b          DCB      "Task Sem",0
000050  2053656d
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L17.88|
000058  2000              DCB      " ",0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.OS_PendDbgNameRemove||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameRemove PROC
;;;1173   
;;;1174   void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1175                               OS_TCB       *p_tcb)
;;;1176   {
;;;1177       OS_PEND_LIST  *p_pend_list;
;;;1178       OS_PEND_DATA  *p_pend_data;
;;;1179       OS_TCB        *p_tcb1;
;;;1180   
;;;1181   
;;;1182       p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
000002  a507              ADR      r5,|L18.32|
000004  f8c150bc          STR      r5,[r1,#0xbc]
;;;1183       p_pend_list       = &p_obj->PendList;
000008  f1000408          ADD      r4,r0,#8
;;;1184       p_pend_data       =  p_pend_list->HeadPtr;
00000c  6822              LDR      r2,[r4,#0]
;;;1185       if (p_pend_data  != (OS_PEND_DATA *)0) {
00000e  b11a              CBZ      r2,|L18.24|
;;;1186           p_tcb1            = p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1187           p_obj->DbgNamePtr = p_tcb1->NamePtr;
000012  6a1d              LDR      r5,[r3,#0x20]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e001              B        |L18.28|
                  |L18.24|
;;;1188       } else {
;;;1189           p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
000018  a501              ADR      r5,|L18.32|
00001a  61c5              STR      r5,[r0,#0x1c]
                  |L18.28|
;;;1190       }
;;;1191   }
00001c  bd30              POP      {r4,r5,pc}
;;;1192   #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
000020  2000              DCB      " ",0
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.OS_PendListChangePrio||, CODE, READONLY, ALIGN=1

                  OS_PendListChangePrio PROC
;;;1275   
;;;1276   void  OS_PendListChangePrio (OS_TCB   *p_tcb,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1277                                OS_PRIO   prio_new)
;;;1278   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1279       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1280       OS_PEND_DATA   *p_pend_data;
;;;1281       OS_PEND_LIST   *p_pend_list;
;;;1282       OS_PEND_OBJ    *p_obj;
;;;1283   
;;;1284   
;;;1285       p_tcb->Prio = prio_new;
000008  f8847037          STRB     r7,[r4,#0x37]
;;;1286       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
00000c  6b25              LDR      r5,[r4,#0x30]
;;;1287       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
00000e  f8b4803e          LDRH     r8,[r4,#0x3e]
;;;1288   
;;;1289       while (n_pend_list > 0u) {
000012  e013              B        |L19.60|
                  |L19.20|
;;;1290           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
000014  f8d5900c          LDR      r9,[r5,#0xc]
;;;1291           p_pend_list = &p_obj->PendList;
000018  f1090608          ADD      r6,r9,#8
;;;1292           if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
00001c  8930              LDRH     r0,[r6,#8]
00001e  2801              CMP      r0,#1
000020  d907              BLS      |L19.50|
;;;1293               OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       OS_PendListRemove1
;;;1294                                  p_pend_data);
;;;1295               OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       OS_PendListInsertPrio
                  |L19.50|
;;;1296                                     p_pend_data);
;;;1297           }
;;;1298           p_pend_data++;                                              /* Point to next wait list                        */
000032  3520              ADDS     r5,r5,#0x20
;;;1299           n_pend_list--;
000034  f1a80001          SUB      r0,r8,#1
000038  fa1ff880          UXTH     r8,r0
                  |L19.60|
00003c  f1b80f00          CMP      r8,#0                 ;1289
000040  d1e8              BNE      |L19.20|
;;;1300       }
;;;1301   }
000042  e8bd83f0          POP      {r4-r9,pc}
;;;1302   
                          ENDP


                          AREA ||i.OS_PendListInit||, CODE, READONLY, ALIGN=1

                  OS_PendListInit PROC
;;;1318   
;;;1319   void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
000000  2100              MOVS     r1,#0
;;;1320   {
;;;1321       p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
000002  6001              STR      r1,[r0,#0]
;;;1322       p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
000004  6041              STR      r1,[r0,#4]
;;;1323       p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
000006  8101              STRH     r1,[r0,#8]
;;;1324   }
000008  4770              BX       lr
;;;1325   
                          ENDP


                          AREA ||i.OS_PendListInsertHead||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertHead PROC
;;;1372   
;;;1373   void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
000000  8903              LDRH     r3,[r0,#8]
;;;1374                                OS_PEND_DATA  *p_pend_data)
;;;1375   {
;;;1376       OS_PEND_DATA  *p_pend_data_next;
;;;1377   
;;;1378   
;;;1379   
;;;1380       p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
000002  1c5b              ADDS     r3,r3,#1
000004  8103              STRH     r3,[r0,#8]
;;;1381       p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
000006  6803              LDR      r3,[r0,#0]
000008  604b              STR      r3,[r1,#4]
;;;1382       p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
00000a  2300              MOVS     r3,#0
00000c  600b              STR      r3,[r1,#0]
;;;1383       p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
00000e  6802              LDR      r2,[r0,#0]
;;;1384       if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
000010  b102              CBZ      r2,|L21.20|
;;;1385           p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
000012  6011              STR      r1,[r2,#0]
                  |L21.20|
;;;1386       }
;;;1387       p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
000014  6001              STR      r1,[r0,#0]
;;;1388       if (p_pend_list->NbrEntries == 1u) {
000016  8903              LDRH     r3,[r0,#8]
000018  2b01              CMP      r3,#1
00001a  d100              BNE      |L21.30|
;;;1389           p_pend_list->TailPtr = p_pend_data;
00001c  6041              STR      r1,[r0,#4]
                  |L21.30|
;;;1390       }
;;;1391   }
00001e  4770              BX       lr
;;;1392   
                          ENDP


                          AREA ||i.OS_PendListInsertPrio||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertPrio PROC
;;;1460   
;;;1461   void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1462                                OS_PEND_DATA  *p_pend_data)
;;;1463   {
;;;1464       OS_PRIO        prio;
;;;1465       OS_TCB        *p_tcb;
;;;1466       OS_TCB        *p_tcb_next;
;;;1467       OS_PEND_DATA  *p_pend_data_prev;
;;;1468       OS_PEND_DATA  *p_pend_data_next;
;;;1469   
;;;1470   
;;;1471   
;;;1472       p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
000002  688e              LDR      r6,[r1,#8]
;;;1473       prio  = p_tcb->Prio;
000004  f8965037          LDRB     r5,[r6,#0x37]
;;;1474       if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
000008  8907              LDRH     r7,[r0,#8]
00000a  b93f              CBNZ     r7,|L22.28|
;;;1475           p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
00000c  2701              MOVS     r7,#1
00000e  8107              STRH     r7,[r0,#8]
;;;1476           p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
000010  2700              MOVS     r7,#0
000012  604f              STR      r7,[r1,#4]
;;;1477           p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
000014  600f              STR      r7,[r1,#0]
;;;1478           p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
000016  6001              STR      r1,[r0,#0]
;;;1479           p_pend_list->TailPtr    = p_pend_data;
000018  6041              STR      r1,[r0,#4]
00001a  e023              B        |L22.100|
                  |L22.28|
;;;1480       } else {
;;;1481           p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
00001c  8907              LDRH     r7,[r0,#8]
00001e  1c7f              ADDS     r7,r7,#1
000020  8107              STRH     r7,[r0,#8]
;;;1482           p_pend_data_next = p_pend_list->HeadPtr;
000022  6802              LDR      r2,[r0,#0]
;;;1483           while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
000024  e006              B        |L22.52|
                  |L22.38|
;;;1484               p_tcb_next   = p_pend_data_next->TCBPtr;
000026  6894              LDR      r4,[r2,#8]
;;;1485               if (prio < p_tcb_next->Prio) {
000028  f8947037          LDRB     r7,[r4,#0x37]
00002c  42af              CMP      r7,r5
00002e  dd00              BLE      |L22.50|
;;;1486                   break;                                                /*         Found! ... insert BEFORE current     */
000030  e002              B        |L22.56|
                  |L22.50|
;;;1487               } else {
;;;1488                   p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
000032  6852              LDR      r2,[r2,#4]
                  |L22.52|
000034  2a00              CMP      r2,#0                 ;1483
000036  d1f6              BNE      |L22.38|
                  |L22.56|
000038  bf00              NOP                            ;1486
;;;1489               }
;;;1490           }
;;;1491           if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
00003a  b932              CBNZ     r2,|L22.74|
;;;1492               p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
00003c  2700              MOVS     r7,#0
00003e  604f              STR      r7,[r1,#4]
;;;1493               p_pend_data_prev          = p_pend_list->TailPtr;
000040  6843              LDR      r3,[r0,#4]
;;;1494               p_pend_data->PrevPtr      = p_pend_data_prev;
000042  600b              STR      r3,[r1,#0]
;;;1495               p_pend_data_prev->NextPtr = p_pend_data;
000044  6059              STR      r1,[r3,#4]
;;;1496               p_pend_list->TailPtr      = p_pend_data;
000046  6041              STR      r1,[r0,#4]
000048  e00c              B        |L22.100|
                  |L22.74|
;;;1497           } else {
;;;1498               if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
00004a  6817              LDR      r7,[r2,#0]
00004c  b92f              CBNZ     r7,|L22.90|
;;;1499                   p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
00004e  6011              STR      r1,[r2,#0]
;;;1500                   p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
000050  2700              MOVS     r7,#0
000052  600f              STR      r7,[r1,#0]
;;;1501                   p_pend_data->NextPtr       = p_pend_data_next;
000054  604a              STR      r2,[r1,#4]
;;;1502                   p_pend_list->HeadPtr       = p_pend_data;
000056  6001              STR      r1,[r0,#0]
000058  e004              B        |L22.100|
                  |L22.90|
;;;1503               } else {
;;;1504                   p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
00005a  6813              LDR      r3,[r2,#0]
;;;1505                   p_pend_data->PrevPtr       = p_pend_data_prev;
00005c  600b              STR      r3,[r1,#0]
;;;1506                   p_pend_data->NextPtr       = p_pend_data_next;
00005e  604a              STR      r2,[r1,#4]
;;;1507                   p_pend_data_prev->NextPtr  = p_pend_data;
000060  6059              STR      r1,[r3,#4]
;;;1508                   p_pend_data_next->PrevPtr  = p_pend_data;
000062  6011              STR      r1,[r2,#0]
                  |L22.100|
;;;1509               }
;;;1510           }
;;;1511       }
;;;1512   }
000064  bdf0              POP      {r4-r7,pc}
;;;1513   
                          ENDP


                          AREA ||i.OS_PendListRemove||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove PROC
;;;1563   
;;;1564   void  OS_PendListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1565   {
000004  4604              MOV      r4,r0
;;;1566       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1567       OS_PEND_DATA   *p_pend_data;
;;;1568       OS_PEND_LIST   *p_pend_list;
;;;1569       OS_PEND_OBJ    *p_obj;
;;;1570   
;;;1571   
;;;1572   
;;;1573       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000006  6b25              LDR      r5,[r4,#0x30]
;;;1574       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000008  8fe6              LDRH     r6,[r4,#0x3e]
;;;1575   
;;;1576       while (n_pend_list > (OS_OBJ_QTY)0) {
00000a  e00a              B        |L23.34|
                  |L23.12|
;;;1577           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
00000c  f8d5800c          LDR      r8,[r5,#0xc]
;;;1578           p_pend_list = &p_obj->PendList;
000010  f1080708          ADD      r7,r8,#8
;;;1579           OS_PendListRemove1(p_pend_list,
000014  4629              MOV      r1,r5
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       OS_PendListRemove1
;;;1580                              p_pend_data);
;;;1581           p_pend_data++;
00001c  3520              ADDS     r5,r5,#0x20
;;;1582           n_pend_list--;
00001e  1e70              SUBS     r0,r6,#1
000020  b286              UXTH     r6,r0
                  |L23.34|
000022  2e00              CMP      r6,#0                 ;1576
000024  dcf2              BGT      |L23.12|
;;;1583       }
;;;1584       p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
000026  2000              MOVS     r0,#0
000028  87e0              STRH     r0,[r4,#0x3e]
;;;1585       p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
00002a  6320              STR      r0,[r4,#0x30]
;;;1586   }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;1587   
                          ENDP


                          AREA ||i.OS_PendListRemove1||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove1 PROC
;;;1638   
;;;1639   void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
000000  b510              PUSH     {r4,lr}
;;;1640                             OS_PEND_DATA  *p_pend_data)
;;;1641   {
;;;1642       OS_PEND_DATA  *p_prev;
;;;1643       OS_PEND_DATA  *p_next;
;;;1644   
;;;1645   
;;;1646   
;;;1647       if (p_pend_list->NbrEntries == 1u) {
000002  8904              LDRH     r4,[r0,#8]
000004  2c01              CMP      r4,#1
000006  d103              BNE      |L24.16|
;;;1648           p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
000008  2400              MOVS     r4,#0
00000a  6004              STR      r4,[r0,#0]
;;;1649           p_pend_list->TailPtr = (OS_PEND_DATA *)0;
00000c  6044              STR      r4,[r0,#4]
00000e  e011              B        |L24.52|
                  |L24.16|
;;;1650   
;;;1651       } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
000010  680c              LDR      r4,[r1,#0]
000012  b924              CBNZ     r4,|L24.30|
;;;1652           p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
000014  684a              LDR      r2,[r1,#4]
;;;1653           p_next->PrevPtr      = (OS_PEND_DATA *)0;
000016  2400              MOVS     r4,#0
000018  6014              STR      r4,[r2,#0]
;;;1654           p_pend_list->HeadPtr = p_next;
00001a  6002              STR      r2,[r0,#0]
00001c  e00a              B        |L24.52|
                  |L24.30|
;;;1655   
;;;1656       } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
00001e  684c              LDR      r4,[r1,#4]
000020  b924              CBNZ     r4,|L24.44|
;;;1657           p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
000022  680b              LDR      r3,[r1,#0]
;;;1658           p_prev->NextPtr      = (OS_PEND_DATA *)0;
000024  2400              MOVS     r4,#0
000026  605c              STR      r4,[r3,#4]
;;;1659           p_pend_list->TailPtr = p_prev;
000028  6043              STR      r3,[r0,#4]
00002a  e003              B        |L24.52|
                  |L24.44|
;;;1660   
;;;1661       } else {
;;;1662           p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
00002c  680b              LDR      r3,[r1,#0]
;;;1663           p_next               = p_pend_data->NextPtr;
00002e  684a              LDR      r2,[r1,#4]
;;;1664           p_prev->NextPtr      = p_next;
000030  605a              STR      r2,[r3,#4]
;;;1665           p_next->PrevPtr      = p_prev;
000032  6013              STR      r3,[r2,#0]
                  |L24.52|
;;;1666       }
;;;1667       p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
000034  8904              LDRH     r4,[r0,#8]
000036  1e64              SUBS     r4,r4,#1
000038  8104              STRH     r4,[r0,#8]
;;;1668       p_pend_data->NextPtr = (OS_PEND_DATA *)0;
00003a  2400              MOVS     r4,#0
00003c  604c              STR      r4,[r1,#4]
;;;1669       p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
00003e  600c              STR      r4,[r1,#0]
;;;1670   }
000040  bd10              POP      {r4,pc}
;;;1671   
                          ENDP


                          AREA ||i.OS_PendObjDel||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel PROC
;;;1692   
;;;1693   void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;1694                        OS_TCB       *p_tcb,
;;;1695                        CPU_TS        ts)
;;;1696   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1697       switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d245              BCS      |L25.156|
000010  e8dff000          TBB      [pc,r0]
000014  04050809          DCB      0x04,0x05,0x08,0x09
000018  06072627          DCB      0x06,0x07,0x26,0x27
;;;1698           case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
;;;1699           case OS_TASK_STATE_DLY:
00001c  bf00              NOP      
;;;1700           case OS_TASK_STATE_SUSPENDED:
00001e  bf00              NOP      
;;;1701           case OS_TASK_STATE_DLY_SUSPENDED:
000020  bf00              NOP      
;;;1702                break;
000022  e03c              B        |L25.158|
;;;1703   
;;;1704           case OS_TASK_STATE_PEND:
;;;1705           case OS_TASK_STATE_PEND_TIMEOUT:
000024  bf00              NOP      
;;;1706                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000026  f8940034          LDRB     r0,[r4,#0x34]
00002a  2803              CMP      r0,#3
00002c  d104              BNE      |L25.56|
;;;1707                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
00002e  462a              MOV      r2,r5
000030  4621              MOV      r1,r4
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       OS_PendObjDel1
                  |L25.56|
;;;1708                                   p_tcb,
;;;1709                                   ts);
;;;1710                }
;;;1711   #if (OS_MSG_EN > 0u)
;;;1712                p_tcb->MsgPtr     = (void *)0;
000038  2000              MOVS     r0,#0
00003a  65e0              STR      r0,[r4,#0x5c]
;;;1713                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00003c  f8a40060          STRH     r0,[r4,#0x60]
;;;1714   #endif
;;;1715                p_tcb->TS         = ts;
000040  6425              STR      r5,[r4,#0x40]
;;;1716                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_PendListRemove
;;;1717                OS_TaskRdy(p_tcb);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       OS_TaskRdy
;;;1718                p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
00004e  2000              MOVS     r0,#0
000050  3434              ADDS     r4,r4,#0x34
000052  70a0              STRB     r0,[r4,#2]
;;;1719                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
000054  2002              MOVS     r0,#2
000056  7060              STRB     r0,[r4,#1]
;;;1720                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
000058  2000              MOVS     r0,#0
00005a  f8040934          STRB     r0,[r4],#-0x34
;;;1721                break;
00005e  e01e              B        |L25.158|
;;;1722   
;;;1723           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1724           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000060  bf00              NOP      
;;;1725                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000062  f8940034          LDRB     r0,[r4,#0x34]
000066  2803              CMP      r0,#3
000068  d104              BNE      |L25.116|
;;;1726                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
00006a  462a              MOV      r2,r5
00006c  4621              MOV      r1,r4
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       OS_PendObjDel1
                  |L25.116|
;;;1727                                   p_tcb,
;;;1728                                   ts);
;;;1729                }
;;;1730   #if (OS_MSG_EN > 0u)
;;;1731                p_tcb->MsgPtr     = (void      *)0;
000074  2000              MOVS     r0,#0
000076  65e0              STR      r0,[r4,#0x5c]
;;;1732                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
000078  f8a40060          STRH     r0,[r4,#0x60]
;;;1733   #endif
;;;1734                p_tcb->TS         = ts;
00007c  6425              STR      r5,[r4,#0x40]
;;;1735                OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       OS_TickListRemove
;;;1736                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       OS_PendListRemove
;;;1737                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
00008a  2004              MOVS     r0,#4
00008c  3434              ADDS     r4,r4,#0x34
00008e  70a0              STRB     r0,[r4,#2]
;;;1738                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
000090  2002              MOVS     r0,#2
000092  7060              STRB     r0,[r4,#1]
;;;1739                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000094  2000              MOVS     r0,#0
000096  f8040934          STRB     r0,[r4],#-0x34
;;;1740                break;
00009a  e000              B        |L25.158|
                  |L25.156|
;;;1741   
;;;1742           default:
;;;1743                break;
00009c  bf00              NOP      
                  |L25.158|
00009e  bf00              NOP                            ;1702
;;;1744       }
;;;1745   }
0000a0  bd70              POP      {r4-r6,pc}
;;;1746   
                          ENDP


                          AREA ||i.OS_PendObjDel1||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel1 PROC
;;;1794   
;;;1795   void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1796                         OS_TCB       *p_tcb,
;;;1797                         CPU_TS        ts)
;;;1798   {
000002  4603              MOV      r3,r0
;;;1799       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1800       OS_PEND_DATA   *p_pend_data;
;;;1801   
;;;1802   
;;;1803   
;;;1804       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000004  6b08              LDR      r0,[r1,#0x30]
;;;1805       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000006  8fcc              LDRH     r4,[r1,#0x3e]
;;;1806   
;;;1807       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
000008  e008              B        |L26.28|
                  |L26.10|
;;;1808           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
00000a  68c5              LDR      r5,[r0,#0xc]
00000c  429d              CMP      r5,r3
00000e  d102              BNE      |L26.22|
;;;1809               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
000010  6103              STR      r3,[r0,#0x10]
;;;1810               p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
000012  61c2              STR      r2,[r0,#0x1c]
;;;1811               break;
000014  e004              B        |L26.32|
                  |L26.22|
;;;1812           }
;;;1813           p_pend_data++;
000016  3020              ADDS     r0,r0,#0x20
;;;1814           n_pend_list--;
000018  1e65              SUBS     r5,r4,#1
00001a  b2ac              UXTH     r4,r5
                  |L26.28|
00001c  2c00              CMP      r4,#0                 ;1807
00001e  dcf4              BGT      |L26.10|
                  |L26.32|
000020  bf00              NOP                            ;1811
;;;1815       }
;;;1816   }
000022  bd30              POP      {r4,r5,pc}
;;;1817   
                          ENDP


                          AREA ||i.OS_Post||, CODE, READONLY, ALIGN=1

                  OS_Post PROC
;;;1843   
;;;1844   void  OS_Post (OS_PEND_OBJ  *p_obj,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1845                  OS_TCB       *p_tcb,
;;;1846                  void         *p_void,
;;;1847                  OS_MSG_SIZE   msg_size,
;;;1848                  CPU_TS        ts)
;;;1849   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;1850       switch (p_tcb->TaskState) {
00000e  f8940036          LDRB     r0,[r4,#0x36]
000012  2808              CMP      r0,#8
000014  d250              BCS      |L27.184|
000016  e8dff000          TBB      [pc,r0]
00001a  0405              DCB      0x04,0x05
00001c  08090607          DCB      0x08,0x09,0x06,0x07
000020  2b2c              DCB      0x2b,0x2c
;;;1851           case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
;;;1852           case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
000022  bf00              NOP      
;;;1853           case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
000024  bf00              NOP      
;;;1854           case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
000026  bf00              NOP      
;;;1855                break;
000028  e047              B        |L27.186|
;;;1856   
;;;1857           case OS_TASK_STATE_PEND:
;;;1858           case OS_TASK_STATE_PEND_TIMEOUT:
00002a  bf00              NOP      
;;;1859                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
00002c  f8940034          LDRB     r0,[r4,#0x34]
000030  2803              CMP      r0,#3
000032  d107              BNE      |L27.68|
;;;1860                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
000034  4643              MOV      r3,r8
000036  463a              MOV      r2,r7
000038  4621              MOV      r1,r4
00003a  4630              MOV      r0,r6
00003c  9500              STR      r5,[sp,#0]
00003e  f7fffffe          BL       OS_Post1
000042  e003              B        |L27.76|
                  |L27.68|
;;;1861                             p_tcb,
;;;1862                             p_void,
;;;1863                             msg_size,
;;;1864                             ts);
;;;1865                } else {
;;;1866   #if (OS_MSG_EN > 0u)
;;;1867                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
000044  65e7              STR      r7,[r4,#0x5c]
;;;1868                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
000046  f8a48060          STRH     r8,[r4,#0x60]
;;;1869   #endif
;;;1870                    p_tcb->TS      = ts;
00004a  6425              STR      r5,[r4,#0x40]
                  |L27.76|
;;;1871                }
;;;1872                if (p_obj != (OS_PEND_OBJ *)0) {
00004c  b136              CBZ      r6,|L27.92|
;;;1873                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OS_PendListRemove
;;;1874   #if OS_CFG_DBG_EN > 0u
;;;1875                    OS_PendDbgNameRemove(p_obj,
000054  4621              MOV      r1,r4
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       OS_PendDbgNameRemove
                  |L27.92|
;;;1876                                         p_tcb);
;;;1877   #endif
;;;1878                }
;;;1879                OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       OS_TaskRdy
;;;1880                p_tcb->TaskState  = OS_TASK_STATE_RDY;
000062  2000              MOVS     r0,#0
000064  3434              ADDS     r4,r4,#0x34
000066  70a0              STRB     r0,[r4,#2]
;;;1881                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
000068  7060              STRB     r0,[r4,#1]
;;;1882                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
00006a  f8040934          STRB     r0,[r4],#-0x34
;;;1883                break;
00006e  e024              B        |L27.186|
;;;1884   
;;;1885           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1886           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000070  bf00              NOP      
;;;1887                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000072  f8940034          LDRB     r0,[r4,#0x34]
000076  2803              CMP      r0,#3
000078  d107              BNE      |L27.138|
;;;1888                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
00007a  4643              MOV      r3,r8
00007c  463a              MOV      r2,r7
00007e  4621              MOV      r1,r4
000080  4630              MOV      r0,r6
000082  9500              STR      r5,[sp,#0]
000084  f7fffffe          BL       OS_Post1
000088  e003              B        |L27.146|
                  |L27.138|
;;;1889                             p_tcb,
;;;1890                             p_void,
;;;1891                             msg_size,
;;;1892                             ts);
;;;1893                } else {
;;;1894   #if (OS_MSG_EN > 0u)
;;;1895                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
00008a  65e7              STR      r7,[r4,#0x5c]
;;;1896                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
00008c  f8a48060          STRH     r8,[r4,#0x60]
;;;1897   #endif
;;;1898                    p_tcb->TS      = ts;
000090  6425              STR      r5,[r4,#0x40]
                  |L27.146|
;;;1899                }
;;;1900                OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       OS_TickListRemove
;;;1901                if (p_obj != (OS_PEND_OBJ *)0) {
000098  b136              CBZ      r6,|L27.168|
;;;1902                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       OS_PendListRemove
;;;1903   #if OS_CFG_DBG_EN > 0u
;;;1904                    OS_PendDbgNameRemove(p_obj,
0000a0  4621              MOV      r1,r4
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       OS_PendDbgNameRemove
                  |L27.168|
;;;1905                                         p_tcb);
;;;1906   #endif
;;;1907                }
;;;1908                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
0000a8  2004              MOVS     r0,#4
0000aa  3434              ADDS     r4,r4,#0x34
0000ac  70a0              STRB     r0,[r4,#2]
;;;1909                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
0000ae  2000              MOVS     r0,#0
0000b0  7060              STRB     r0,[r4,#1]
;;;1910                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
0000b2  f8040934          STRB     r0,[r4],#-0x34
;;;1911                break;
0000b6  e000              B        |L27.186|
                  |L27.184|
;;;1912   
;;;1913           default:
;;;1914                break;
0000b8  bf00              NOP      
                  |L27.186|
0000ba  bf00              NOP                            ;1855
;;;1915       }
;;;1916   }
0000bc  e8bd83f8          POP      {r3-r9,pc}
;;;1917   
                          ENDP


                          AREA ||i.OS_Post1||, CODE, READONLY, ALIGN=1

                  OS_Post1 PROC
;;;1969   
;;;1970   void  OS_Post1 (OS_PEND_OBJ  *p_obj,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1971                   OS_TCB       *p_tcb,
;;;1972                   void         *p_void,
;;;1973                   OS_MSG_SIZE   msg_size,
;;;1974                   CPU_TS        ts)
;;;1975   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1976       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1977       OS_PEND_DATA   *p_pend_data;
;;;1978   
;;;1979   
;;;1980   
;;;1981       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000006  6b08              LDR      r0,[r1,#0x30]
;;;1982       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000008  8fcd              LDRH     r5,[r1,#0x3e]
;;;1983   
;;;1984       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
00000a  e00a              B        |L28.34|
                  |L28.12|
;;;1985           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
00000c  68c7              LDR      r7,[r0,#0xc]
00000e  42a7              CMP      r7,r4
000010  d104              BNE      |L28.28|
;;;1986               p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
000012  6104              STR      r4,[r0,#0x10]
;;;1987               p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
000014  6142              STR      r2,[r0,#0x14]
;;;1988               p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
000016  8303              STRH     r3,[r0,#0x18]
;;;1989               p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
000018  61c6              STR      r6,[r0,#0x1c]
;;;1990               break;
00001a  e004              B        |L28.38|
                  |L28.28|
;;;1991           }
;;;1992           p_pend_data++;
00001c  3020              ADDS     r0,r0,#0x20
;;;1993           n_pend_list--;
00001e  1e6f              SUBS     r7,r5,#1
000020  b2bd              UXTH     r5,r7
                  |L28.34|
000022  2d00              CMP      r5,#0                 ;1984
000024  dcf2              BGT      |L28.12|
                  |L28.38|
000026  bf00              NOP                            ;1990
;;;1994       }
;;;1995   }
000028  bdf0              POP      {r4-r7,pc}
;;;1996   
                          ENDP


                          AREA ||i.OS_RdyListInit||, CODE, READONLY, ALIGN=2

                  OS_RdyListInit PROC
;;;2039   
;;;2040   void  OS_RdyListInit (void)
000000  2100              MOVS     r1,#0
;;;2041   {
;;;2042       OS_PRIO       i;
;;;2043       OS_RDY_LIST  *p_rdy_list;
;;;2044   
;;;2045   
;;;2046   
;;;2047       for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
000002  e00a              B        |L29.26|
                  |L29.4|
;;;2048           p_rdy_list = &OSRdyList[i];
000004  eb010241          ADD      r2,r1,r1,LSL #1
000008  4b05              LDR      r3,|L29.32|
00000a  eb030082          ADD      r0,r3,r2,LSL #2
;;;2049           p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
00000e  2200              MOVS     r2,#0
000010  8102              STRH     r2,[r0,#8]
;;;2050           p_rdy_list->HeadPtr    = (OS_TCB   *)0;
000012  6002              STR      r2,[r0,#0]
;;;2051           p_rdy_list->TailPtr    = (OS_TCB   *)0;
000014  6042              STR      r2,[r0,#4]
000016  1c4a              ADDS     r2,r1,#1              ;2047
000018  b2d1              UXTB     r1,r2                 ;2047
                  |L29.26|
00001a  2940              CMP      r1,#0x40              ;2047
00001c  d3f2              BCC      |L29.4|
;;;2052       }
;;;2053   }
00001e  4770              BX       lr
;;;2054   
                          ENDP

                  |L29.32|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsert||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsert PROC
;;;2073   
;;;2074   void  OS_RdyListInsert (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2075   {
000002  4604              MOV      r4,r0
;;;2076       OS_PrioInsert(p_tcb->Prio);
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  f7fffffe          BL       OS_PrioInsert
;;;2077       if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
00000c  f8940037          LDRB     r0,[r4,#0x37]
000010  4905              LDR      r1,|L30.40|
000012  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000014  4288              CMP      r0,r1
000016  d103              BNE      |L30.32|
;;;2078           OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       OS_RdyListInsertTail
00001e  e002              B        |L30.38|
                  |L30.32|
;;;2079       } else {
;;;2080           OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_RdyListInsertHead
                  |L30.38|
;;;2081       }
;;;2082   }
000026  bd10              POP      {r4,pc}
;;;2083   
                          ENDP

                  |L30.40|
                          DCD      OSPrioCur

                          AREA ||i.OS_RdyListInsertHead||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertHead PROC
;;;2140   
;;;2141   void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2142   {
;;;2143       OS_RDY_LIST  *p_rdy_list;
;;;2144       OS_TCB       *p_tcb2;
;;;2145   
;;;2146   
;;;2147   
;;;2148       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0c              LDR      r4,|L31.60|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2149       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
000010  890b              LDRH     r3,[r1,#8]
000012  b93b              CBNZ     r3,|L31.36|
;;;2150           p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2151           p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
000018  2300              MOVS     r3,#0
00001a  60c3              STR      r3,[r0,#0xc]
;;;2152           p_tcb->PrevPtr         =  (OS_TCB   *)0;
00001c  6103              STR      r3,[r0,#0x10]
;;;2153           p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
00001e  6008              STR      r0,[r1,#0]
;;;2154           p_rdy_list->TailPtr    =  p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e009              B        |L31.56|
                  |L31.36|
;;;2155       } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
;;;2156           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2157           p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
00002a  680b              LDR      r3,[r1,#0]
00002c  60c3              STR      r3,[r0,#0xc]
;;;2158           p_tcb->PrevPtr         = (OS_TCB    *)0;
00002e  2300              MOVS     r3,#0
000030  6103              STR      r3,[r0,#0x10]
;;;2159           p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
000032  680a              LDR      r2,[r1,#0]
;;;2160           p_tcb2->PrevPtr        = p_tcb;
000034  6110              STR      r0,[r2,#0x10]
;;;2161           p_rdy_list->HeadPtr    = p_tcb;
000036  6008              STR      r0,[r1,#0]
                  |L31.56|
;;;2162       }
;;;2163   }
000038  bd10              POP      {r4,pc}
;;;2164   
                          ENDP

00003a  0000              DCW      0x0000
                  |L31.60|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsertTail||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertTail PROC
;;;2221   
;;;2222   void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2223   {
;;;2224       OS_RDY_LIST  *p_rdy_list;
;;;2225       OS_TCB       *p_tcb2;
;;;2226   
;;;2227   
;;;2228   
;;;2229       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0b              LDR      r4,|L32.56|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2230       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
000010  890b              LDRH     r3,[r1,#8]
000012  b93b              CBNZ     r3,|L32.36|
;;;2231           p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2232           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
000018  2300              MOVS     r3,#0
00001a  60c3              STR      r3,[r0,#0xc]
;;;2233           p_tcb->PrevPtr          = (OS_TCB   *)0;
00001c  6103              STR      r3,[r0,#0x10]
;;;2234           p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
00001e  6008              STR      r0,[r1,#0]
;;;2235           p_rdy_list->TailPtr     = p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e008              B        |L32.54|
                  |L32.36|
;;;2236       } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
;;;2237           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2238           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
00002a  2300              MOVS     r3,#0
00002c  60c3              STR      r3,[r0,#0xc]
;;;2239           p_tcb2                  = p_rdy_list->TailPtr;
00002e  684a              LDR      r2,[r1,#4]
;;;2240           p_tcb->PrevPtr          = p_tcb2;
000030  6102              STR      r2,[r0,#0x10]
;;;2241           p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
000032  60d0              STR      r0,[r2,#0xc]
;;;2242           p_rdy_list->TailPtr     = p_tcb;
000034  6048              STR      r0,[r1,#4]
                  |L32.54|
;;;2243       }
;;;2244   }
000036  bd10              POP      {r4,pc}
;;;2245   
                          ENDP

                  |L32.56|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListMoveHeadToTail||, CODE, READONLY, ALIGN=1

                  OS_RdyListMoveHeadToTail PROC
;;;2298   
;;;2299   void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
000000  b510              PUSH     {r4,lr}
;;;2300   {
000002  4601              MOV      r1,r0
;;;2301       OS_TCB  *p_tcb1;
;;;2302       OS_TCB  *p_tcb2;
;;;2303       OS_TCB  *p_tcb3;
;;;2304   
;;;2305   
;;;2306   
;;;2307       switch (p_rdy_list->NbrEntries) {
000004  890c              LDRH     r4,[r1,#8]
000006  b124              CBZ      r4,|L33.18|
000008  2c01              CMP      r4,#1
00000a  d003              BEQ      |L33.20|
00000c  2c02              CMP      r4,#2
00000e  d10c              BNE      |L33.42|
000010  e001              B        |L33.22|
                  |L33.18|
;;;2308           case 0:
;;;2309           case 1:
000012  bf00              NOP      
                  |L33.20|
;;;2310                break;
000014  e014              B        |L33.64|
                  |L33.22|
;;;2311   
;;;2312           case 2:                                             /* SWAP the TCBs                                          */
;;;2313                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
000016  6808              LDR      r0,[r1,#0]
;;;2314                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
000018  684a              LDR      r2,[r1,#4]
;;;2315                p_tcb1->PrevPtr     = p_tcb2;
00001a  6102              STR      r2,[r0,#0x10]
;;;2316                p_tcb1->NextPtr     = (OS_TCB *)0;
00001c  2400              MOVS     r4,#0
00001e  60c4              STR      r4,[r0,#0xc]
;;;2317                p_tcb2->PrevPtr     = (OS_TCB *)0;
000020  6114              STR      r4,[r2,#0x10]
;;;2318                p_tcb2->NextPtr     = p_tcb1;
000022  60d0              STR      r0,[r2,#0xc]
;;;2319                p_rdy_list->HeadPtr = p_tcb2;
000024  600a              STR      r2,[r1,#0]
;;;2320                p_rdy_list->TailPtr = p_tcb1;
000026  6048              STR      r0,[r1,#4]
;;;2321                break;
000028  e00a              B        |L33.64|
                  |L33.42|
;;;2322   
;;;2323           default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
;;;2324                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
00002a  6808              LDR      r0,[r1,#0]
;;;2325                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
00002c  684a              LDR      r2,[r1,#4]
;;;2326                p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
00002e  68c3              LDR      r3,[r0,#0xc]
;;;2327                p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
000030  2400              MOVS     r4,#0
000032  611c              STR      r4,[r3,#0x10]
;;;2328                p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
000034  60c4              STR      r4,[r0,#0xc]
;;;2329                p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
000036  6102              STR      r2,[r0,#0x10]
;;;2330                p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
000038  60d0              STR      r0,[r2,#0xc]
;;;2331                p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
00003a  600b              STR      r3,[r1,#0]
;;;2332                p_rdy_list->TailPtr = p_tcb1;
00003c  6048              STR      r0,[r1,#4]
;;;2333                break;
00003e  bf00              NOP      
                  |L33.64|
000040  bf00              NOP                            ;2310
;;;2334       }
;;;2335   }
000042  bd10              POP      {r4,pc}
;;;2336   
                          ENDP


                          AREA ||i.OS_RdyListRemove||, CODE, READONLY, ALIGN=2

                  OS_RdyListRemove PROC
;;;2385   
;;;2386   void  OS_RdyListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2387   {
000004  4605              MOV      r5,r0
;;;2388       OS_RDY_LIST  *p_rdy_list;
;;;2389       OS_TCB       *p_tcb1;
;;;2390       OS_TCB       *p_tcb2;
;;;2391   
;;;2392   
;;;2393   
;;;2394       p_rdy_list = &OSRdyList[p_tcb->Prio];
000006  f8950037          LDRB     r0,[r5,#0x37]
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  4912              LDR      r1,|L34.88|
000010  eb010480          ADD      r4,r1,r0,LSL #2
;;;2395       p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
000014  692f              LDR      r7,[r5,#0x10]
;;;2396       p_tcb2     = p_tcb->NextPtr;
000016  68ee              LDR      r6,[r5,#0xc]
;;;2397       if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
000018  b987              CBNZ     r7,|L34.60|
;;;2398           if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
00001a  b946              CBNZ     r6,|L34.46|
;;;2399               p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
00001c  2000              MOVS     r0,#0
00001e  8120              STRH     r0,[r4,#8]
;;;2400               p_rdy_list->HeadPtr    = (OS_TCB   *)0;
000020  6020              STR      r0,[r4,#0]
;;;2401               p_rdy_list->TailPtr    = (OS_TCB   *)0;
000022  6060              STR      r0,[r4,#4]
;;;2402               OS_PrioRemove(p_tcb->Prio);
000024  f8950037          LDRB     r0,[r5,#0x37]
000028  f7fffffe          BL       OS_PrioRemove
00002c  e00e              B        |L34.76|
                  |L34.46|
;;;2403           } else {
;;;2404               p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
00002e  8920              LDRH     r0,[r4,#8]
000030  1e40              SUBS     r0,r0,#1
000032  8120              STRH     r0,[r4,#8]
;;;2405               p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
000034  2000              MOVS     r0,#0
000036  6130              STR      r0,[r6,#0x10]
;;;2406               p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
000038  6026              STR      r6,[r4,#0]
00003a  e007              B        |L34.76|
                  |L34.60|
;;;2407           }
;;;2408       } else {
;;;2409           p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
00003c  8920              LDRH     r0,[r4,#8]
00003e  1e40              SUBS     r0,r0,#1
000040  8120              STRH     r0,[r4,#8]
;;;2410           p_tcb1->NextPtr = p_tcb2;
000042  60fe              STR      r6,[r7,#0xc]
;;;2411           if (p_tcb2 == (OS_TCB *)0) {
000044  b90e              CBNZ     r6,|L34.74|
;;;2412               p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
000046  6067              STR      r7,[r4,#4]
000048  e000              B        |L34.76|
                  |L34.74|
;;;2413           } else {
;;;2414               p_tcb2->PrevPtr     = p_tcb1;
00004a  6137              STR      r7,[r6,#0x10]
                  |L34.76|
;;;2415           }
;;;2416       }
;;;2417       p_tcb->PrevPtr = (OS_TCB *)0;
00004c  2000              MOVS     r0,#0
00004e  6128              STR      r0,[r5,#0x10]
;;;2418       p_tcb->NextPtr = (OS_TCB *)0;
000050  60e8              STR      r0,[r5,#0xc]
;;;2419   }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;2420   
                          ENDP

000056  0000              DCW      0x0000
                  |L34.88|
                          DCD      OSRdyList

                          AREA ||i.OS_SchedRoundRobin||, CODE, READONLY, ALIGN=2

                  OS_SchedRoundRobin PROC
;;;2524   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;2525   void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
000000  b570              PUSH     {r4-r6,lr}
;;;2526   {
000002  4605              MOV      r5,r0
;;;2527       OS_TCB   *p_tcb;
;;;2528       CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;2529   
;;;2530   
;;;2531   
;;;2532       if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
000006  482e              LDR      r0,|L35.192|
000008  7800              LDRB     r0,[r0,#0]  ; OSSchedRoundRobinEn
00000a  2801              CMP      r0,#1
00000c  d000              BEQ      |L35.16|
                  |L35.14|
;;;2533           return;
;;;2534       }
;;;2535   
;;;2536       CPU_CRITICAL_ENTER();
;;;2537       p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
;;;2538   
;;;2539       if (p_tcb == (OS_TCB *)0) {
;;;2540           CPU_CRITICAL_EXIT();
;;;2541           return;
;;;2542       }
;;;2543   
;;;2544       if (p_tcb == &OSIdleTaskTCB) {
;;;2545           CPU_CRITICAL_EXIT();
;;;2546           return;
;;;2547       }
;;;2548   
;;;2549       if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
;;;2550           p_tcb->TimeQuantaCtr--;
;;;2551       }
;;;2552   
;;;2553       if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
;;;2554           CPU_CRITICAL_EXIT();
;;;2555           return;
;;;2556       }
;;;2557   
;;;2558       if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
;;;2559           CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
;;;2560           return;
;;;2561       }
;;;2562   
;;;2563       if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
;;;2564           CPU_CRITICAL_EXIT();
;;;2565           return;
;;;2566       }
;;;2567   
;;;2568       OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
;;;2569       p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
;;;2570       if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
;;;2571           p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;2572       } else {
;;;2573           p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
;;;2574       }
;;;2575       CPU_CRITICAL_EXIT();
;;;2576   }
00000e  bd70              POP      {r4-r6,pc}
                  |L35.16|
000010  bf00              NOP                            ;2536
000012  bf00              NOP                            ;2536
000014  f7fffffe          BL       CPU_SR_Save
000018  4606              MOV      r6,r0                 ;2536
00001a  bf00              NOP                            ;2536
00001c  bf00              NOP                            ;2536
00001e  682c              LDR      r4,[r5,#0]            ;2537
000020  b93c              CBNZ     r4,|L35.50|
000022  bf00              NOP                            ;2540
000024  bf00              NOP                            ;2540
000026  4630              MOV      r0,r6                 ;2540
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP                            ;2540
00002e  bf00              NOP                            ;2540
000030  e7ed              B        |L35.14|
                  |L35.50|
000032  4824              LDR      r0,|L35.196|
000034  4284              CMP      r4,r0                 ;2544
000036  d107              BNE      |L35.72|
000038  bf00              NOP                            ;2545
00003a  bf00              NOP                            ;2545
00003c  4630              MOV      r0,r6                 ;2545
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;2545
000044  bf00              NOP                            ;2545
000046  e7e2              B        |L35.14|
                  |L35.72|
000048  6da0              LDR      r0,[r4,#0x58]         ;2549
00004a  b110              CBZ      r0,|L35.82|
00004c  6da0              LDR      r0,[r4,#0x58]         ;2550
00004e  1e40              SUBS     r0,r0,#1              ;2550
000050  65a0              STR      r0,[r4,#0x58]         ;2550
                  |L35.82|
000052  6da0              LDR      r0,[r4,#0x58]         ;2553
000054  b138              CBZ      r0,|L35.102|
000056  bf00              NOP                            ;2554
000058  bf00              NOP                            ;2554
00005a  4630              MOV      r0,r6                 ;2554
00005c  f7fffffe          BL       CPU_SR_Restore
000060  bf00              NOP                            ;2554
000062  bf00              NOP                            ;2554
000064  e7d3              B        |L35.14|
                  |L35.102|
000066  8928              LDRH     r0,[r5,#8]            ;2558
000068  2802              CMP      r0,#2                 ;2558
00006a  da07              BGE      |L35.124|
00006c  bf00              NOP                            ;2559
00006e  bf00              NOP                            ;2559
000070  4630              MOV      r0,r6                 ;2559
000072  f7fffffe          BL       CPU_SR_Restore
000076  bf00              NOP                            ;2559
000078  bf00              NOP                            ;2559
00007a  e7c8              B        |L35.14|
                  |L35.124|
00007c  4812              LDR      r0,|L35.200|
00007e  7800              LDRB     r0,[r0,#0]            ;2563  ; OSSchedLockNestingCtr
000080  2800              CMP      r0,#0                 ;2563
000082  dd07              BLE      |L35.148|
000084  bf00              NOP                            ;2564
000086  bf00              NOP                            ;2564
000088  4630              MOV      r0,r6                 ;2564
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP                            ;2564
000090  bf00              NOP                            ;2564
000092  e7bc              B        |L35.14|
                  |L35.148|
000094  4628              MOV      r0,r5                 ;2568
000096  f7fffffe          BL       OS_RdyListMoveHeadToTail
00009a  682c              LDR      r4,[r5,#0]            ;2569
00009c  6d60              LDR      r0,[r4,#0x54]         ;2570
00009e  b918              CBNZ     r0,|L35.168|
0000a0  480a              LDR      r0,|L35.204|
0000a2  6800              LDR      r0,[r0,#0]            ;2571  ; OSSchedRoundRobinDfltTimeQuanta
0000a4  65a0              STR      r0,[r4,#0x58]         ;2571
0000a6  e001              B        |L35.172|
                  |L35.168|
0000a8  6d60              LDR      r0,[r4,#0x54]         ;2573
0000aa  65a0              STR      r0,[r4,#0x58]         ;2573
                  |L35.172|
0000ac  bf00              NOP                            ;2575
0000ae  bf00              NOP                            ;2575
0000b0  4630              MOV      r0,r6                 ;2575
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP                            ;2575
0000b8  bf00              NOP                            ;2575
0000ba  bf00              NOP      
0000bc  e7a7              B        |L35.14|
;;;2577   #endif
                          ENDP

0000be  0000              DCW      0x0000
                  |L35.192|
                          DCD      OSSchedRoundRobinEn
                  |L35.196|
                          DCD      OSIdleTaskTCB
                  |L35.200|
                          DCD      OSSchedLockNestingCtr
                  |L35.204|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OS_TaskBlock||, CODE, READONLY, ALIGN=1

                  OS_TaskBlock PROC
;;;2597   
;;;2598   void  OS_TaskBlock (OS_TCB   *p_tcb,
000000  b538              PUSH     {r3-r5,lr}
;;;2599                       OS_TICK   timeout)
;;;2600   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2601       OS_ERR  err;
;;;2602   
;;;2603   
;;;2604       if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
000006  b185              CBZ      r5,|L36.42|
;;;2605           OS_TickListInsert(p_tcb,
000008  466b              MOV      r3,sp
00000a  2202              MOVS     r2,#2
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       OS_TickListInsert
;;;2606                             timeout,
;;;2607                             OS_OPT_TIME_TIMEOUT,
;;;2608                            &err);
;;;2609           if (err == OS_ERR_NONE) {
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  b918              CBNZ     r0,|L36.34|
;;;2610               p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
00001a  2003              MOVS     r0,#3
00001c  f8840036          STRB     r0,[r4,#0x36]
000020  e006              B        |L36.48|
                  |L36.34|
;;;2611           } else {
;;;2612               p_tcb->TaskState = OS_TASK_STATE_PEND;
000022  2002              MOVS     r0,#2
000024  f8840036          STRB     r0,[r4,#0x36]
000028  e002              B        |L36.48|
                  |L36.42|
;;;2613           }
;;;2614       } else {
;;;2615           p_tcb->TaskState = OS_TASK_STATE_PEND;
00002a  2002              MOVS     r0,#2
00002c  f8840036          STRB     r0,[r4,#0x36]
                  |L36.48|
;;;2616       }
;;;2617       OS_RdyListRemove(p_tcb);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       OS_RdyListRemove
;;;2618   }
000036  bd38              POP      {r3-r5,pc}
;;;2619   
                          ENDP


                          AREA ||i.OS_TaskRdy||, CODE, READONLY, ALIGN=1

                  OS_TaskRdy PROC
;;;2635   
;;;2636   void  OS_TaskRdy (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2637   {
000002  4604              MOV      r4,r0
;;;2638       OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       OS_TickListRemove
;;;2639       if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
00000a  f8940036          LDRB     r0,[r4,#0x36]
00000e  f0000004          AND      r0,r0,#4
000012  b910              CBNZ     r0,|L37.26|
;;;2640           OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       OS_RdyListInsert
                  |L37.26|
;;;2641       }
;;;2642   }
00001a  bd10              POP      {r4,pc}
                          ENDP

