; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_nrf.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_nrf.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_spi_nrf.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_nrf.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;76     */
;;;77     static void Delay(__IO u32 nCount)
000000  b501              PUSH     {r0,lr}
;;;78     {
;;;79       for(; nCount != 0; nCount--);
000002  e002              B        |L1.10|
                  |L1.4|
000004  9800              LDR      r0,[sp,#0]
000006  1e40              SUBS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L1.10|
00000a  9800              LDR      r0,[sp,#0]
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L1.4|
;;;80     } 
000010  bd08              POP      {r3,pc}
;;;81     
                          ENDP


                          AREA ||i.NRF_Check||, CODE, READONLY, ALIGN=2

                  NRF_Check PROC
;;;346      */
;;;347    u8 NRF_Check(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;348    {
;;;349    		u8 buf[5]={0xC2,0xC2,0xC2,0xC2,0xC2};
000002  a110              ADR      r1,|L2.68|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0102          STRD     r0,r1,[sp,#8]
;;;350    		u8 buf1[5];
;;;351    		u8 i; 
;;;352    		 
;;;353    		/*写入5个字节的地址.  */  
;;;354    		SPI_NRF_WriteBuf(NRF_WRITE_REG+TX_ADDR,buf,5);
00000a  2205              MOVS     r2,#5
00000c  a902              ADD      r1,sp,#8
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       SPI_NRF_WriteBuf
;;;355    
;;;356    		/*读出写入的地址 */
;;;357    		SPI_NRF_ReadBuf(TX_ADDR,buf1,5); 
000014  2205              MOVS     r2,#5
000016  4669              MOV      r1,sp
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       SPI_NRF_ReadBuf
;;;358    		 
;;;359    		/*比较*/               
;;;360    		for(i=0;i<5;i++)
00001e  2400              MOVS     r4,#0
000020  e006              B        |L2.48|
                  |L2.34|
;;;361    		{
;;;362    			if(buf1[i]!=0xC2)
000022  f81d0004          LDRB     r0,[sp,r4]
000026  28c2              CMP      r0,#0xc2
000028  d000              BEQ      |L2.44|
;;;363    				break;
00002a  e003              B        |L2.52|
                  |L2.44|
00002c  1c60              ADDS     r0,r4,#1              ;360
00002e  b2c4              UXTB     r4,r0                 ;360
                  |L2.48|
000030  2c05              CMP      r4,#5                 ;360
000032  dbf6              BLT      |L2.34|
                  |L2.52|
000034  bf00              NOP      
;;;364    		} 
;;;365    					 
;;;366    		if(i==5)
000036  2c05              CMP      r4,#5
000038  d102              BNE      |L2.64|
;;;367    			return SUCCESS ;        //MCU与NRF成功连接 
00003a  2001              MOVS     r0,#1
                  |L2.60|
;;;368    		else
;;;369    			return ERROR ;        //MCU与NRF不正常连接
;;;370    }
00003c  b004              ADD      sp,sp,#0x10
00003e  bd10              POP      {r4,pc}
                  |L2.64|
000040  2000              MOVS     r0,#0                 ;369
000042  e7fb              B        |L2.60|
;;;371    
                          ENDP

                  |L2.68|
000044  c2c2c2c2          DCB      194,194,194,194,194,0
000048  c200    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.NRF_RX_Mode||, CODE, READONLY, ALIGN=2

                  NRF_RX_Mode PROC
;;;287      */
;;;288    void NRF_RX_Mode(void)
000000  b510              PUSH     {r4,lr}
;;;289    
;;;290    {
;;;291    	 NRF_CE_LOW();	
000002  2101              MOVS     r1,#1
000004  4812              LDR      r0,|L3.80|
000006  f7fffffe          BL       GPIO_ResetBits
;;;292    
;;;293       SPI_NRF_WriteBuf(NRF_WRITE_REG+RX_ADDR_P0,(u8 *)NRF_ADDRESS,ADR_WIDTH);//写RX节点地址
00000a  2205              MOVS     r2,#5
00000c  4911              LDR      r1,|L3.84|
00000e  202a              MOVS     r0,#0x2a
000010  f7fffffe          BL       SPI_NRF_WriteBuf
;;;294    
;;;295       SPI_NRF_WriteReg(NRF_WRITE_REG+EN_AA,0x01);    //使能通道0的自动应答    
000014  2101              MOVS     r1,#1
000016  2021              MOVS     r0,#0x21
000018  f7fffffe          BL       SPI_NRF_WriteReg
;;;296    
;;;297       SPI_NRF_WriteReg(NRF_WRITE_REG+EN_RXADDR,0x01);//使能通道0的接收地址    
00001c  2101              MOVS     r1,#1
00001e  2022              MOVS     r0,#0x22
000020  f7fffffe          BL       SPI_NRF_WriteReg
;;;298    
;;;299       SPI_NRF_WriteReg(NRF_WRITE_REG+RF_CH,CHANAL);      //设置RF通信频率    
000024  2128              MOVS     r1,#0x28
000026  2025              MOVS     r0,#0x25
000028  f7fffffe          BL       SPI_NRF_WriteReg
;;;300    
;;;301       SPI_NRF_WriteReg(NRF_WRITE_REG+RX_PW_P0,RX_PLOAD_WIDTH);//选择通道0的有效数据宽度      
00002c  210c              MOVS     r1,#0xc
00002e  2031              MOVS     r0,#0x31
000030  f7fffffe          BL       SPI_NRF_WriteReg
;;;302    
;;;303       SPI_NRF_WriteReg(NRF_WRITE_REG+RF_SETUP,0x0f); //设置TX发射参数,0db增益,2Mbps,低噪声增益开启   
000034  210f              MOVS     r1,#0xf
000036  2026              MOVS     r0,#0x26
000038  f7fffffe          BL       SPI_NRF_WriteReg
;;;304    
;;;305       SPI_NRF_WriteReg(NRF_WRITE_REG+CONFIG, 0x0f);  //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式 
00003c  210f              MOVS     r1,#0xf
00003e  2020              MOVS     r0,#0x20
000040  f7fffffe          BL       SPI_NRF_WriteReg
;;;306    
;;;307    	/*CE拉高，进入接收模式*/	
;;;308    		NRF_CE_HIGH();
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L3.80|
000048  f7fffffe          BL       GPIO_SetBits
;;;309    
;;;310    }    
00004c  bd10              POP      {r4,pc}
;;;311    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0x40020400
                  |L3.84|
                          DCD      NRF_ADDRESS

                          AREA ||i.NRF_Rx_Dat||, CODE, READONLY, ALIGN=2

                  NRF_Rx_Dat PROC
;;;418      */
;;;419    u8 NRF_Rx_Dat(u8 *rxbuf)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4605              MOV      r5,r0
;;;421    		u8          state; 
;;;422    	  u16  link_count=0;
000004  2600              MOVS     r6,#0
;;;423    		NRF_CE_HIGH();	 //进入接收状态
000006  2101              MOVS     r1,#1
000008  4816              LDR      r0,|L4.100|
00000a  f7fffffe          BL       GPIO_SetBits
;;;424    		 /*等待接收中断*/
;;;425    		while(NRF_Read_IRQ()!=0)
00000e  e007              B        |L4.32|
                  |L4.16|
;;;426    		{
;;;427    			  link_count ++;
000010  1c70              ADDS     r0,r6,#1
000012  b286              UXTH     r6,r0
;;;428    			  if(link_count == 5000)  //5000为最大重连次数
000014  f2413088          MOV      r0,#0x1388
000018  4286              CMP      r6,r0
00001a  d101              BNE      |L4.32|
;;;429    					return ERROR;
00001c  2000              MOVS     r0,#0
                  |L4.30|
;;;430    		}			
;;;431    		
;;;432    		NRF_CE_LOW();  	 //进入待机状态
;;;433    		/*读取status寄存器的值  */               
;;;434    		state=SPI_NRF_ReadReg(STATUS);
;;;435    		 
;;;436    		/* 清除中断标志*/      
;;;437    		SPI_NRF_WriteReg(NRF_WRITE_REG+STATUS,state);
;;;438    
;;;439    		/*判断是否接收到数据*/
;;;440    		if(state&RX_DR)                                 //接收到数据
;;;441    		{
;;;442    			SPI_NRF_ReadBuf(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//读取数据
;;;443    			SPI_NRF_WriteReg(FLUSH_RX,NOP);          //清除RX FIFO寄存器
;;;444    			return RX_DR; 
;;;445    		}
;;;446    		else    
;;;447    			return ERROR;                    //没收到任何数据
;;;448    }
00001e  bd70              POP      {r4-r6,pc}
                  |L4.32|
000020  2104              MOVS     r1,#4                 ;425
000022  4810              LDR      r0,|L4.100|
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  2800              CMP      r0,#0                 ;425
00002a  d1f1              BNE      |L4.16|
00002c  2101              MOVS     r1,#1                 ;432
00002e  480d              LDR      r0,|L4.100|
000030  f7fffffe          BL       GPIO_ResetBits
000034  2007              MOVS     r0,#7                 ;434
000036  f7fffffe          BL       SPI_NRF_ReadReg
00003a  4604              MOV      r4,r0                 ;434
00003c  4621              MOV      r1,r4                 ;437
00003e  2027              MOVS     r0,#0x27              ;437
000040  f7fffffe          BL       SPI_NRF_WriteReg
000044  f0040040          AND      r0,r4,#0x40           ;440
000048  b150              CBZ      r0,|L4.96|
00004a  220c              MOVS     r2,#0xc               ;442
00004c  4629              MOV      r1,r5                 ;442
00004e  2061              MOVS     r0,#0x61              ;442
000050  f7fffffe          BL       SPI_NRF_ReadBuf
000054  21ff              MOVS     r1,#0xff              ;443
000056  20e2              MOVS     r0,#0xe2              ;443
000058  f7fffffe          BL       SPI_NRF_WriteReg
00005c  2040              MOVS     r0,#0x40              ;444
00005e  e7de              B        |L4.30|
                  |L4.96|
000060  2000              MOVS     r0,#0                 ;447
000062  e7dc              B        |L4.30|
;;;449    /***************************** 阿波罗科技 www.apollorobot.com (END OF FILE) *********************************/
                          ENDP

                  |L4.100|
                          DCD      0x40020400

                          AREA ||i.NRF_TX_Mode||, CODE, READONLY, ALIGN=2

                  NRF_TX_Mode PROC
;;;316      */
;;;317    void NRF_TX_Mode(void)
000000  b510              PUSH     {r4,lr}
;;;318    {  
;;;319    	 NRF_CE_LOW();		
000002  2101              MOVS     r1,#1
000004  4816              LDR      r0,|L5.96|
000006  f7fffffe          BL       GPIO_ResetBits
;;;320    
;;;321       SPI_NRF_WriteBuf(NRF_WRITE_REG+TX_ADDR,(u8 *)NRF_ADDRESS,ADR_WIDTH);    //写TX节点地址 
00000a  2205              MOVS     r2,#5
00000c  4915              LDR      r1,|L5.100|
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       SPI_NRF_WriteBuf
;;;322    
;;;323       SPI_NRF_WriteBuf(NRF_WRITE_REG+RX_ADDR_P0,(u8 *)NRF_ADDRESS,ADR_WIDTH); //设置TX节点地址,主要为了使能ACK   
000014  2205              MOVS     r2,#5
000016  4913              LDR      r1,|L5.100|
000018  202a              MOVS     r0,#0x2a
00001a  f7fffffe          BL       SPI_NRF_WriteBuf
;;;324    
;;;325       SPI_NRF_WriteReg(NRF_WRITE_REG+EN_AA,0x01);     //使能通道0的自动应答    
00001e  2101              MOVS     r1,#1
000020  2021              MOVS     r0,#0x21
000022  f7fffffe          BL       SPI_NRF_WriteReg
;;;326    
;;;327       SPI_NRF_WriteReg(NRF_WRITE_REG+EN_RXADDR,0x01); //使能通道0的接收地址  
000026  2101              MOVS     r1,#1
000028  2022              MOVS     r0,#0x22
00002a  f7fffffe          BL       SPI_NRF_WriteReg
;;;328    
;;;329       SPI_NRF_WriteReg(NRF_WRITE_REG+SETUP_RETR,0x1a);//设置自动重发间隔时间:500us + 86us;最大自动重发次数:10次
00002e  211a              MOVS     r1,#0x1a
000030  2024              MOVS     r0,#0x24
000032  f7fffffe          BL       SPI_NRF_WriteReg
;;;330    
;;;331       SPI_NRF_WriteReg(NRF_WRITE_REG+RF_CH,CHANAL);       //设置RF通道为CHANAL
000036  2128              MOVS     r1,#0x28
000038  2025              MOVS     r0,#0x25
00003a  f7fffffe          BL       SPI_NRF_WriteReg
;;;332    
;;;333       SPI_NRF_WriteReg(NRF_WRITE_REG+RF_SETUP,0x0f);  //设置TX发射参数,0db增益,2Mbps,低噪声增益开启   
00003e  210f              MOVS     r1,#0xf
000040  2026              MOVS     r0,#0x26
000042  f7fffffe          BL       SPI_NRF_WriteReg
;;;334    	
;;;335       SPI_NRF_WriteReg(NRF_WRITE_REG+CONFIG,0x0e);    //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,发射模式,开启所有中断
000046  210e              MOVS     r1,#0xe
000048  2020              MOVS     r0,#0x20
00004a  f7fffffe          BL       SPI_NRF_WriteReg
;;;336    
;;;337    	/*CE拉高，进入发送模式*/	
;;;338    		NRF_CE_HIGH();
00004e  2101              MOVS     r1,#1
000050  4803              LDR      r0,|L5.96|
000052  f7fffffe          BL       GPIO_SetBits
;;;339        Delay(0xffff); //CE要拉高一段时间才进入发送模式
000056  f64f70ff          MOV      r0,#0xffff
00005a  f7fffffe          BL       Delay
;;;340    }
00005e  bd10              POP      {r4,pc}
;;;341    
                          ENDP

                  |L5.96|
                          DCD      0x40020400
                  |L5.100|
                          DCD      NRF_ADDRESS

                          AREA ||i.NRF_Tx_Dat||, CODE, READONLY, ALIGN=2

                  NRF_Tx_Dat PROC
;;;377      */
;;;378    u8 NRF_Tx_Dat(u8 *txbuf)
000000  b570              PUSH     {r4-r6,lr}
;;;379    {
000002  4605              MOV      r5,r0
;;;380    		u8 state;  
;;;381    
;;;382    		 /*ce为低，进入待机模式1*/
;;;383    		NRF_CE_LOW();
000004  2101              MOVS     r1,#1
000006  4815              LDR      r0,|L6.92|
000008  f7fffffe          BL       GPIO_ResetBits
;;;384    
;;;385    		/*写数据到TX BUF 最大 32个字节*/						
;;;386    		SPI_NRF_WriteBuf(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH);
00000c  220c              MOVS     r2,#0xc
00000e  4629              MOV      r1,r5
000010  20a0              MOVS     r0,#0xa0
000012  f7fffffe          BL       SPI_NRF_WriteBuf
;;;387    
;;;388    		/*CE为高，txbuf非空，发送数据包 */   
;;;389    		NRF_CE_HIGH();
000016  2101              MOVS     r1,#1
000018  4810              LDR      r0,|L6.92|
00001a  f7fffffe          BL       GPIO_SetBits
;;;390    				
;;;391    		/*等待发送完成中断 */                            
;;;392    		while(NRF_Read_IRQ()!=0); 	
00001e  bf00              NOP      
                  |L6.32|
000020  2104              MOVS     r1,#4
000022  480e              LDR      r0,|L6.92|
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  2800              CMP      r0,#0
00002a  d1f9              BNE      |L6.32|
;;;393    		
;;;394    		/*读取状态寄存器的值 */                              
;;;395    		state = SPI_NRF_ReadReg(STATUS);
00002c  2007              MOVS     r0,#7
00002e  f7fffffe          BL       SPI_NRF_ReadReg
000032  4604              MOV      r4,r0
;;;396    
;;;397    		 /*清除TX_DS或MAX_RT中断标志*/                  
;;;398    		SPI_NRF_WriteReg(NRF_WRITE_REG+STATUS,state); 	
000034  4621              MOV      r1,r4
000036  2027              MOVS     r0,#0x27
000038  f7fffffe          BL       SPI_NRF_WriteReg
;;;399    
;;;400    		SPI_NRF_WriteReg(FLUSH_TX,NOP);    //清除TX FIFO寄存器 
00003c  21ff              MOVS     r1,#0xff
00003e  20e1              MOVS     r0,#0xe1
000040  f7fffffe          BL       SPI_NRF_WriteReg
;;;401    
;;;402    		 /*判断中断类型*/    
;;;403    		if(state&MAX_RT)                     //达到最大重发次数
000044  f0040010          AND      r0,r4,#0x10
000048  b108              CBZ      r0,|L6.78|
;;;404    				 return MAX_RT; 
00004a  2010              MOVS     r0,#0x10
                  |L6.76|
;;;405    
;;;406    		else if(state&TX_DS)                  //发送完成
;;;407    				return TX_DS;
;;;408    		 else						  
;;;409    				return ERROR;                 //其他原因发送失败
;;;410    } 
00004c  bd70              POP      {r4-r6,pc}
                  |L6.78|
00004e  f0040020          AND      r0,r4,#0x20           ;406
000052  b108              CBZ      r0,|L6.88|
000054  2020              MOVS     r0,#0x20              ;407
000056  e7f9              B        |L6.76|
                  |L6.88|
000058  2000              MOVS     r0,#0                 ;409
00005a  e7f7              B        |L6.76|
;;;411    
                          ENDP

                  |L6.92|
                          DCD      0x40020400

                          AREA ||i.SPI_NRF_RW||, CODE, READONLY, ALIGN=2

                  SPI_NRF_RW PROC
;;;88       */
;;;89     static u8 SPI_NRF_RW(u8 dat)
000000  b510              PUSH     {r4,lr}
;;;90     {  	
000002  4604              MOV      r4,r0
;;;91        /* 当 SPI发送缓冲器非空时等待 */
;;;92       while (SPI_I2S_GetFlagStatus(NRF_SPI, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L7.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L7.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L7.6|
;;;93       
;;;94        /* 通过 SPI2发送一字节数据 */
;;;95       SPI_I2S_SendData(NRF_SPI, dat);		
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L7.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;96      
;;;97        /* 当SPI接收缓冲器为空时等待 */
;;;98       while (SPI_I2S_GetFlagStatus(NRF_SPI, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L7.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L7.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L7.28|
;;;99     
;;;100      /* Return the byte read from the SPI bus */
;;;101      return SPI_I2S_ReceiveData(NRF_SPI);
000028  4802              LDR      r0,|L7.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;102    }
000030  bd10              POP      {r4,pc}
;;;103    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40013000

                          AREA ||i.SPI_NRF_ReadBuf||, CODE, READONLY, ALIGN=2

                  SPI_NRF_ReadBuf PROC
;;;164      */
;;;165    static u8 SPI_NRF_ReadBuf(u8 reg,u8 *pBuf,u8 bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;166    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;167    		u8 status, byte_cnt;
;;;168    
;;;169    		NRF_CE_LOW();
00000a  2101              MOVS     r1,#1
00000c  480d              LDR      r0,|L8.68|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;170    		/*置低CSN，使能SPI传输*/
;;;171    		NRF_CSN_LOW();
000012  2102              MOVS     r1,#2
000014  480b              LDR      r0,|L8.68|
000016  f7fffffe          BL       GPIO_ResetBits
;;;172    			
;;;173    		/*发送寄存器号*/		
;;;174    		status = SPI_NRF_RW(reg); 
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       SPI_NRF_RW
000020  4680              MOV      r8,r0
;;;175    
;;;176    		/*读取缓冲区数据*/
;;;177    		for(byte_cnt=0;byte_cnt<bytes;byte_cnt++)		  
000022  2400              MOVS     r4,#0
000024  e005              B        |L8.50|
                  |L8.38|
;;;178    			 pBuf[byte_cnt] = SPI_NRF_RW(NOP); //从NRF24L01读取数据  
000026  20ff              MOVS     r0,#0xff
000028  f7fffffe          BL       SPI_NRF_RW
00002c  5528              STRB     r0,[r5,r4]
00002e  1c60              ADDS     r0,r4,#1              ;177
000030  b2c4              UXTB     r4,r0                 ;177
                  |L8.50|
000032  42b4              CMP      r4,r6                 ;177
000034  dbf7              BLT      |L8.38|
;;;179    
;;;180    		 /*CSN拉高，完成*/
;;;181    		NRF_CSN_HIGH();	
000036  2102              MOVS     r1,#2
000038  4802              LDR      r0,|L8.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;182    			
;;;183    		return status;		//返回寄存器状态值
00003e  4640              MOV      r0,r8
;;;184    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;185    
                          ENDP

                  |L8.68|
                          DCD      0x40020400

                          AREA ||i.SPI_NRF_ReadReg||, CODE, READONLY, ALIGN=2

                  SPI_NRF_ReadReg PROC
;;;136      */
;;;137    static u8 SPI_NRF_ReadReg(u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139    		u8 reg_val;
;;;140    
;;;141    		NRF_CE_LOW();
000004  2101              MOVS     r1,#1
000006  480a              LDR      r0,|L9.48|
000008  f7fffffe          BL       GPIO_ResetBits
;;;142    		/*置低CSN，使能SPI传输*/
;;;143    		NRF_CSN_LOW();
00000c  2102              MOVS     r1,#2
00000e  4808              LDR      r0,|L9.48|
000010  f7fffffe          BL       GPIO_ResetBits
;;;144    					
;;;145    			 /*发送寄存器号*/
;;;146    		SPI_NRF_RW(reg); 
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_NRF_RW
;;;147    
;;;148    		 /*读取寄存器的值 */
;;;149    		reg_val = SPI_NRF_RW(NOP);
00001a  20ff              MOVS     r0,#0xff
00001c  f7fffffe          BL       SPI_NRF_RW
000020  4605              MOV      r5,r0
;;;150    								
;;;151    			/*CSN拉高，完成*/
;;;152    		NRF_CSN_HIGH();		
000022  2102              MOVS     r1,#2
000024  4802              LDR      r0,|L9.48|
000026  f7fffffe          BL       GPIO_SetBits
;;;153    			
;;;154    		return reg_val;
00002a  4628              MOV      r0,r5
;;;155    }	
00002c  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      0x40020400

                          AREA ||i.SPI_NRF_WriteBuf||, CODE, READONLY, ALIGN=2

                  SPI_NRF_WriteBuf PROC
;;;193      */
;;;194    static u8 SPI_NRF_WriteBuf(u8 reg ,u8 *pBuf,u8 bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;195    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;196    		 u8 status,byte_cnt;
;;;197    		 NRF_CE_LOW();
00000a  2101              MOVS     r1,#1
00000c  480d              LDR      r0,|L10.68|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;198    			 /*置低CSN，使能SPI传输*/
;;;199    		 NRF_CSN_LOW();			
000012  2102              MOVS     r1,#2
000014  480b              LDR      r0,|L10.68|
000016  f7fffffe          BL       GPIO_ResetBits
;;;200    
;;;201    		 /*发送寄存器号*/	
;;;202    		 status = SPI_NRF_RW(reg); 
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       SPI_NRF_RW
000020  4680              MOV      r8,r0
;;;203    		
;;;204    				/*向缓冲区写入数据*/
;;;205    		 for(byte_cnt=0;byte_cnt<bytes;byte_cnt++)
000022  2600              MOVS     r6,#0
000024  e005              B        |L10.50|
                  |L10.38|
;;;206    			SPI_NRF_RW(*pBuf++);	//写数据到缓冲区 	 
000026  f8140b01          LDRB     r0,[r4],#1
00002a  f7fffffe          BL       SPI_NRF_RW
00002e  1c70              ADDS     r0,r6,#1              ;205
000030  b2c6              UXTB     r6,r0                 ;205
                  |L10.50|
000032  42ae              CMP      r6,r5                 ;205
000034  dbf7              BLT      |L10.38|
;;;207    					 
;;;208    		/*CSN拉高，完成*/
;;;209    		 NRF_CSN_HIGH();			
000036  2102              MOVS     r1,#2
000038  4802              LDR      r0,|L10.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;210    		
;;;211    			return (status);	//返回NRF24L01的状态 		
00003e  4640              MOV      r0,r8
;;;212    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP

                  |L10.68|
                          DCD      0x40020400

                          AREA ||i.SPI_NRF_WriteReg||, CODE, READONLY, ALIGN=2

                  SPI_NRF_WriteReg PROC
;;;110      */
;;;111    static u8 SPI_NRF_WriteReg(u8 reg,u8 dat)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    		 u8 status;
;;;114    		 NRF_CE_LOW();
000006  2101              MOVS     r1,#1
000008  4809              LDR      r0,|L11.48|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;115    		/*置低CSN，使能SPI传输*/
;;;116    		 NRF_CSN_LOW();
00000e  2102              MOVS     r1,#2
000010  4807              LDR      r0,|L11.48|
000012  f7fffffe          BL       GPIO_ResetBits
;;;117    					
;;;118    		/*发送命令及寄存器号 */
;;;119    		 status = SPI_NRF_RW(reg);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       SPI_NRF_RW
00001c  4606              MOV      r6,r0
;;;120    			 
;;;121    		 /*向寄存器写入数据*/
;;;122    		 SPI_NRF_RW(dat); 
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_NRF_RW
;;;123    							
;;;124    		/*CSN拉高，完成*/	   
;;;125    		 NRF_CSN_HIGH();	
000024  2102              MOVS     r1,#2
000026  4802              LDR      r0,|L11.48|
000028  f7fffffe          BL       GPIO_SetBits
;;;126    			
;;;127    		/*返回状态寄存器的值*/
;;;128    			return(status);
00002c  4630              MOV      r0,r6
;;;129    }
00002e  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  |L11.48|
                          DCD      0x40020400

                          AREA ||i.bsp_InitNRF||, CODE, READONLY, ALIGN=2

                  bsp_InitNRF PROC
;;;225      */
;;;226    void bsp_InitNRF(void)
000000  b500              PUSH     {lr}
;;;227    {
000002  b087              SUB      sp,sp,#0x1c
;;;228    		SPI_InitTypeDef  SPI_InitStructure;
;;;229    		GPIO_InitTypeDef GPIO_InitStructure;
;;;230    		
;;;231    		/*开启相应IO端口的时钟*/
;;;232    		RCC_APB2PeriphClockCmd(NRF_PORT_CLK,ENABLE);
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;233    
;;;234    		/*使能SPI1时钟*/
;;;235    		RCC_APB2PeriphClockCmd(NRF_SPI_CLK, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;236    
;;;237    		 /*配置 SPI_NRF_SPI的 SCK,MISO,MOSI引脚，GPIOB^3,GPIOB^4,GPIOB^5 */
;;;238    		GPIO_PinAFConfig(NRF_SPI_PORT, GPIO_PinSource3, GPIO_AF_SPI1);
000014  2205              MOVS     r2,#5
000016  2103              MOVS     r1,#3
000018  4833              LDR      r0,|L12.232|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;239    		GPIO_PinAFConfig(NRF_SPI_PORT, GPIO_PinSource4, GPIO_AF_SPI1);
00001e  2205              MOVS     r2,#5
000020  2104              MOVS     r1,#4
000022  4831              LDR      r0,|L12.232|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;240    		GPIO_PinAFConfig(NRF_SPI_PORT, GPIO_PinSource5, GPIO_AF_SPI1);
000028  2205              MOVS     r2,#5
00002a  4611              MOV      r1,r2
00002c  482e              LDR      r0,|L12.232|
00002e  f7fffffe          BL       GPIO_PinAFConfig
;;;241    		GPIO_InitStructure.GPIO_Pin = NRF_SPI_SCK | NRF_SPI_MISO | NRF_SPI_MOSI;
000032  2038              MOVS     r0,#0x38
000034  9000              STR      r0,[sp,#0]
;;;242    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
000036  2001              MOVS     r0,#1
000038  f88d0005          STRB     r0,[sp,#5]
;;;243    	  GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF;
00003c  2002              MOVS     r0,#2
00003e  f88d0004          STRB     r0,[sp,#4]
;;;244    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000042  2000              MOVS     r0,#0
000044  f88d0006          STRB     r0,[sp,#6]
;;;245    	  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000048  f88d0007          STRB     r0,[sp,#7]
;;;246    		GPIO_Init(NRF_SPI_PORT, &GPIO_InitStructure);  
00004c  4669              MOV      r1,sp
00004e  4826              LDR      r0,|L12.232|
000050  f7fffffe          BL       GPIO_Init
;;;247    
;;;248    		/*配置SPI_NRF_SPI的CE引脚,和SPI_NRF_SPI的 CSN 引脚*/
;;;249    		GPIO_InitStructure.GPIO_Pin = NRF_CE_PIN | NRF_CS_PIN;
000054  2003              MOVS     r0,#3
000056  9000              STR      r0,[sp,#0]
;;;250    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
000058  2001              MOVS     r0,#1
00005a  f88d0005          STRB     r0,[sp,#5]
;;;251    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00005e  f88d0004          STRB     r0,[sp,#4]
;;;252    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000062  2000              MOVS     r0,#0
000064  f88d0006          STRB     r0,[sp,#6]
;;;253    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000068  f88d0007          STRB     r0,[sp,#7]
;;;254    		GPIO_Init(NRF_CS_PORT, &GPIO_InitStructure);
00006c  4669              MOV      r1,sp
00006e  481e              LDR      r0,|L12.232|
000070  f7fffffe          BL       GPIO_Init
;;;255    
;;;256    
;;;257    		 /*配置SPI_NRF_SPI的IRQ引脚*/
;;;258    		GPIO_InitStructure.GPIO_Pin = NRF_IRQ_PIN;
000074  2004              MOVS     r0,#4
000076  9000              STR      r0,[sp,#0]
;;;259    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
000078  2001              MOVS     r0,#1
00007a  f88d0005          STRB     r0,[sp,#5]
;;;260    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN ;  //上拉输入
00007e  2000              MOVS     r0,#0
000080  f88d0004          STRB     r0,[sp,#4]
;;;261    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		
000084  f88d0006          STRB     r0,[sp,#6]
;;;262    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
000088  2001              MOVS     r0,#1
00008a  f88d0007          STRB     r0,[sp,#7]
;;;263    		GPIO_Init(NRF_IRQ_PORT, &GPIO_InitStructure); 
00008e  4669              MOV      r1,sp
000090  4815              LDR      r0,|L12.232|
000092  f7fffffe          BL       GPIO_Init
;;;264    				
;;;265    		/* 这是自定义的宏，用于拉高csn引脚，NRF进入空闲状态 */
;;;266    		NRF_CSN_HIGH(); 
000096  2102              MOVS     r1,#2
000098  4813              LDR      r0,|L12.232|
00009a  f7fffffe          BL       GPIO_SetBits
;;;267    	 
;;;268    		SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //双线全双工
00009e  2000              MOVS     r0,#0
0000a0  f8ad0008          STRH     r0,[sp,#8]
;;;269    		SPI_InitStructure.SPI_Mode = SPI_Mode_Master;	 					//主模式
0000a4  f44f7082          MOV      r0,#0x104
0000a8  f8ad000a          STRH     r0,[sp,#0xa]
;;;270    		SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	 				//数据大小8位
0000ac  2000              MOVS     r0,#0
0000ae  f8ad000c          STRH     r0,[sp,#0xc]
;;;271    		SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		 				//时钟极性，空闲时为低
0000b2  f8ad000e          STRH     r0,[sp,#0xe]
;;;272    		SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;						//第1个边沿有效，上升沿为采样时刻
0000b6  f8ad0010          STRH     r0,[sp,#0x10]
;;;273    		SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		   					//NSS信号由软件产生
0000ba  f44f7000          MOV      r0,#0x200
0000be  f8ad0012          STRH     r0,[sp,#0x12]
;;;274    		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;  //8分频，9MHz
0000c2  2010              MOVS     r0,#0x10
0000c4  f8ad0014          STRH     r0,[sp,#0x14]
;;;275    		SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;  				//高位在前
0000c8  2000              MOVS     r0,#0
0000ca  f8ad0016          STRH     r0,[sp,#0x16]
;;;276    		SPI_InitStructure.SPI_CRCPolynomial = 7;
0000ce  2007              MOVS     r0,#7
0000d0  f8ad0018          STRH     r0,[sp,#0x18]
;;;277    		SPI_Init(NRF_SPI, &SPI_InitStructure);
0000d4  a902              ADD      r1,sp,#8
0000d6  4805              LDR      r0,|L12.236|
0000d8  f7fffffe          BL       SPI_Init
;;;278    
;;;279    		/* Enable SPI1  */
;;;280    		SPI_Cmd(NRF_SPI, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  4803              LDR      r0,|L12.236|
0000e0  f7fffffe          BL       SPI_Cmd
;;;281    }
0000e4  b007              ADD      sp,sp,#0x1c
0000e6  bd00              POP      {pc}
;;;282    
                          ENDP

                  |L12.232|
                          DCD      0x40020400
                  |L12.236|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  NRF_ADDRESS
000000  00010203          DCB      0x00,0x01,0x02,0x03
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_nrf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_nrf_c_dcb10072____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_nrf_c_dcb10072____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_nrf_c_dcb10072____REVSH|
#line 144
|__asm___13_bsp_spi_nrf_c_dcb10072____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_nrf_c_dcb10072____RRX|
#line 300
|__asm___13_bsp_spi_nrf_c_dcb10072____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
