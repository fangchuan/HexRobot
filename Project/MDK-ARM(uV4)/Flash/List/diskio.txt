; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\diskio.crf ..\..\User\fatfs\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;30     /*-------------------------------------------------------------------------------------------*/
;;;31     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;32     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;33     )
;;;34     {
000002  4604              MOV      r4,r0
;;;35     	DSTATUS status = STA_NOINIT;
000004  2501              MOVS     r5,#1
;;;36     	switch (pdrv) {
000006  b114              CBZ      r4,|L1.14|
000008  2c01              CMP      r4,#1
00000a  d104              BNE      |L1.22|
;;;37     		case ATA:	/* SD CARD */
;;;38     			#if FATFS_USE_SDIO == 1
;;;39     				  status = SD_Init();
;;;40     					if (status!=SD_OK )
;;;41     					{
;;;42     						status = STA_NOINIT;
;;;43     					}
;;;44     					else
;;;45     					{
;;;46     						status = RES_OK;
;;;47     					}
;;;48     			#endif
;;;49     			break;
00000c  e005              B        |L1.26|
                  |L1.14|
;;;50     		
;;;51     		case SPI_FLASH:
;;;52     						bsp_FlashInit();
00000e  f7fffffe          BL       bsp_FlashInit
;;;53     						status = RES_OK;
000012  2500              MOVS     r5,#0
;;;54     			break;
000014  e001              B        |L1.26|
                  |L1.22|
;;;55     
;;;56     		default:
;;;57     			status = STA_NOINIT;
000016  2501              MOVS     r5,#1
000018  bf00              NOP                            ;36
                  |L1.26|
00001a  bf00              NOP                            ;49
;;;58     	}
;;;59     		return status;
00001c  4628              MOV      r0,r5
;;;60     
;;;61     }
00001e  bd70              POP      {r4-r6,pc}
;;;62     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;180    #if _USE_IOCTL
;;;181    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;182    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;183    	BYTE cmd,		/* Control code */
;;;184    	void *buff		/* Buffer to send/receive control data */
;;;185    )
;;;186    {
000002  4603              MOV      r3,r0
;;;187    	DRESULT res;
;;;188    
;;;189    	switch (pdrv) {
000004  b113              CBZ      r3,|L2.12|
000006  2b01              CMP      r3,#1
000008  d118              BNE      |L2.60|
;;;190    			case ATA:	/* SD CARD */
;;;191    			#if FATFS_USE_SDIO == 1
;;;192    				switch (cmd) 
;;;193    				{				
;;;194    					case GET_SECTOR_SIZE :     // Get R/W sector size (WORD) 
;;;195    						*(WORD * )buff = 512;
;;;196    					break;
;;;197    					case GET_BLOCK_SIZE:      // Get erase block size in unit of sector (DWORD)
;;;198    						*(DWORD * )buff = SDCardInfo.CardBlockSize;
;;;199    					break;
;;;200    					case GET_SECTOR_COUNT:
;;;201    						*(DWORD * )buff = SDCardInfo.CardCapacity/SDCardInfo.CardBlockSize;
;;;202    					case CTRL_SYNC :
;;;203    					break;
;;;204    				}
;;;205    				res = RES_OK;
;;;206    			#endif
;;;207    			break;
00000a  e019              B        |L2.64|
                  |L2.12|
;;;208    
;;;209    		case SPI_FLASH:
;;;210    				switch (cmd) 
00000c  b189              CBZ      r1,|L2.50|
00000e  2901              CMP      r1,#1
000010  d00b              BEQ      |L2.42|
000012  2902              CMP      r1,#2
000014  d002              BEQ      |L2.28|
000016  2903              CMP      r1,#3
000018  d10c              BNE      |L2.52|
00001a  e003              B        |L2.36|
                  |L2.28|
;;;211    				{
;;;212    					case GET_SECTOR_SIZE :     // Get R/W sector size (WORD)
;;;213    						*(WORD * )buff = FLASH_SECTOR_SIZE;		//flash最小写单元为页，256字节，此处取2页为一个读写单位
00001c  f44f7400          MOV      r4,#0x200
000020  8014              STRH     r4,[r2,#0]
;;;214    					break;
000022  e008              B        |L2.54|
                  |L2.36|
;;;215    					case GET_BLOCK_SIZE :      // Get erase block size in unit of sector (DWORD)
;;;216    						*(DWORD * )buff = FLASH_BLOCK_SIZE;		//flash以4k为最小擦除单位,512bytes为一个扇区，则一个块里有8个扇区
000024  2408              MOVS     r4,#8
000026  6014              STR      r4,[r2,#0]
;;;217    					break;
000028  e005              B        |L2.54|
                  |L2.42|
;;;218    					case GET_SECTOR_COUNT:
;;;219    						*(DWORD * )buff = FLASH_SECTOR_COUNT;		//用于fatfs的sector数量
00002a  4c06              LDR      r4,|L2.68|
00002c  8824              LDRH     r4,[r4,#0]  ; FLASH_SECTOR_COUNT
00002e  6014              STR      r4,[r2,#0]
;;;220    					break;
000030  e001              B        |L2.54|
                  |L2.50|
;;;221    					case CTRL_SYNC :
;;;222    					break;
000032  e000              B        |L2.54|
                  |L2.52|
;;;223    					default:break;
000034  bf00              NOP      
                  |L2.54|
000036  bf00              NOP                            ;214
;;;224    				}
;;;225    				res = RES_OK;
000038  2000              MOVS     r0,#0
;;;226    		break;
00003a  e001              B        |L2.64|
                  |L2.60|
;;;227    		default:
;;;228    			res = RES_PARERR;
00003c  2004              MOVS     r0,#4
00003e  bf00              NOP                            ;189
                  |L2.64|
000040  bf00              NOP                            ;207
;;;229    	}
;;;230    
;;;231    	return res;
;;;232    }
000042  bd10              POP      {r4,pc}
;;;233    #endif
                          ENDP

                  |L2.68|
                          DCD      FLASH_SECTOR_COUNT

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;75     /*-------------------------------------------------------------------------------------------*/
;;;76     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;77     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;78     	BYTE *buff,		/* Data buffer to store read data */
;;;79     	DWORD sector,	/* Sector address (LBA) */
;;;80     	UINT count		/* Number of sectors to read (1..128) */
;;;81     )
;;;82     {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;83     	DRESULT status = RES_PARERR;
00000c  f04f0804          MOV      r8,#4
;;;84     
;;;85     	switch (pdrv)
000010  b117              CBZ      r7,|L3.24|
000012  2f01              CMP      r7,#1
000014  d10f              BNE      |L3.54|
;;;86     	{
;;;87     		case ATA:	/* SD CARD */
;;;88     			#if FATFS_USE_SDIO == 1
;;;89     				if (count > 1)
;;;90     				{
;;;91     					SD_ReadMultiBlocks(buff, sector*SD_BLOCK_SIZE, SD_BLOCK_SIZE, count);				
;;;92     					/* Check if the Transfer is finished */
;;;93     					SD_WaitReadOperation();  //循环查询dma传输是否结束				
;;;94     					/* Wait until end of DMA transfer */
;;;95     					while(SD_GetStatus() != SD_TRANSFER_OK);
;;;96     				}
;;;97     				else
;;;98     				{					
;;;99     					SD_ReadBlock(buff, sector*SD_BLOCK_SIZE, SD_BLOCK_SIZE);
;;;100    					/* Check if the Transfer is finished */
;;;101    					SD_WaitReadOperation();  //循环查询dma传输是否结束				
;;;102    					/* Wait until end of DMA transfer */
;;;103    					while(SD_GetStatus() != SD_TRANSFER_OK);
;;;104    				}
;;;105    				status = RES_OK;
;;;106    			#endif
;;;107    			break;
000016  e011              B        |L3.60|
                  |L3.24|
;;;108    
;;;109    		case SPI_FLASH:
;;;110    					for(;count>0;count--)
000018  e009              B        |L3.46|
                  |L3.26|
;;;111    					{
;;;112    						W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
00001a  0269              LSLS     r1,r5,#9
00001c  f44f7200          MOV      r2,#0x200
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       W25QXX_Read
;;;113    						sector++;
000026  1c6d              ADDS     r5,r5,#1
;;;114    						buff+=FLASH_SECTOR_SIZE;
000028  f5047400          ADD      r4,r4,#0x200
00002c  1e76              SUBS     r6,r6,#1              ;110
                  |L3.46|
00002e  2e00              CMP      r6,#0                 ;110
000030  d1f3              BNE      |L3.26|
;;;115    					}
;;;116    					status = RES_OK;
000032  46b0              MOV      r8,r6
;;;117    		break;
000034  e002              B        |L3.60|
                  |L3.54|
;;;118    		default:
;;;119    			status = RES_PARERR;
000036  f04f0804          MOV      r8,#4
00003a  bf00              NOP                            ;85
                  |L3.60|
00003c  bf00              NOP                            ;107
;;;120    	}
;;;121    	return status;
00003e  4640              MOV      r0,r8
;;;122    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;65     /*-------------------------------------------------------------------------------------------*/
;;;66     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;67     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;68     )
;;;69     {
;;;70     	return RES_OK;
000002  2000              MOVS     r0,#0
;;;71     }
000004  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;127    #if _USE_WRITE
;;;128    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;129    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;130    	const BYTE *buff,	/* Data to be written */
;;;131    	DWORD sector,		/* Sector address (LBA) */
;;;132    	UINT count			/* Number of sectors to write (1..128) */
;;;133    )
;;;134    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;135     DRESULT res;
;;;136    
;;;137    	switch (pdrv)
00000c  f1b80f00          CMP      r8,#0
000010  d003              BEQ      |L5.26|
000012  f1b80f01          CMP      r8,#1
000016  d10f              BNE      |L5.56|
;;;138    	{
;;;139    		case ATA:	/* SD CARD */
;;;140    			#if FATFS_USE_SDIO == 1
;;;141    					if (count > 1)
;;;142    					{
;;;143    						SD_WriteMultiBlocks((uint8_t *)buff, sector*SD_BLOCK_SIZE,SD_BLOCK_SIZE, count);						
;;;144    						/* Check if the Transfer is finished */
;;;145    						SD_WaitWriteOperation();	   //等待dma传输结束
;;;146    						while(SD_GetStatus() != SD_TRANSFER_OK); //等待sdio到sd卡传输结束
;;;147    					}
;;;148    					else
;;;149    					{
;;;150    						SD_WriteBlock((uint8_t *)buff,sector*SD_BLOCK_SIZE,SD_BLOCK_SIZE);						
;;;151    						/* Check if the Transfer is finished */
;;;152    						SD_WaitWriteOperation();	   //等待dma传输结束
;;;153    						while(SD_GetStatus() != SD_TRANSFER_OK); //等待sdio到sd卡传输结束
;;;154    					}
;;;155    					res = RES_OK;
;;;156    			#endif
;;;157    			break;
000018  e010              B        |L5.60|
                  |L5.26|
;;;158    
;;;159    		case SPI_FLASH:
;;;160    					for(;count>0;count--)
00001a  e009              B        |L5.48|
                  |L5.28|
;;;161    					{										    
;;;162    						W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
00001c  0269              LSLS     r1,r5,#9
00001e  f44f7200          MOV      r2,#0x200
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       W25QXX_Write
;;;163    						sector++;
000028  1c6d              ADDS     r5,r5,#1
;;;164    						buff+=FLASH_SECTOR_SIZE;
00002a  f5047400          ADD      r4,r4,#0x200
00002e  1e76              SUBS     r6,r6,#1              ;160
                  |L5.48|
000030  2e00              CMP      r6,#0                 ;160
000032  d1f3              BNE      |L5.28|
;;;165    					}
;;;166    
;;;167    					res = RES_OK;
000034  2700              MOVS     r7,#0
;;;168    		break;
000036  e001              B        |L5.60|
                  |L5.56|
;;;169    		default:
;;;170    			res = RES_PARERR;
000038  2704              MOVS     r7,#4
00003a  bf00              NOP                            ;137
                  |L5.60|
00003c  bf00              NOP                            ;157
;;;171    	}
;;;172    	return res;
00003e  4638              MOV      r0,r7
;;;173    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;174    #endif
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;242    */
;;;243    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;244    {
;;;245    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2013-01-01 00:00:00 */
;;;246    
;;;247    	return	  ((DWORD)(2013 - 1980) << 25)	/* Year = 2013 */
;;;248    			| ((DWORD)1 << 21)				/* Month = 1 */
;;;249    			| ((DWORD)1 << 16)				/* Day_m = 1*/
;;;250    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;251    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;252    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;253    }
000002  4770              BX       lr
                          ENDP

                  |L6.4|
                          DCD      0x42210000

                          AREA ||.data||, DATA, ALIGN=1

                  FLASH_SECTOR_COUNT
000000  7000              DCW      0x7000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\fatfs\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_e3159e14____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REVSH|
#line 144
|__asm___8_diskio_c_e3159e14____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____RRX|
#line 300
|__asm___8_diskio_c_e3159e14____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
