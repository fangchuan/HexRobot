; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_task.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_task.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\os_task.crf ..\..\uCOS-III\uCOS-III\Source\os_task.c]
                          THUMB

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;61     #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
;;;62     void  OSTaskChangePrio (OS_TCB   *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;63                             OS_PRIO   prio_new,
;;;64                             OS_ERR   *p_err)
;;;65     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;66         CPU_BOOLEAN   self;
;;;67         CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;68     
;;;69     
;;;70     
;;;71     #ifdef OS_SAFETY_CRITICAL
;;;72         if (p_err == (OS_ERR *)0) {
;;;73             OS_SAFETY_CRITICAL_EXCEPTION();
;;;74             return;
;;;75         }
;;;76     #endif
;;;77     
;;;78     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;79         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
00000e  4841              LDR      r0,|L1.276|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  2800              CMP      r0,#0
000014  dd04              BLE      |L1.32|
;;;80            *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
000016  f2471049          MOV      r0,#0x7149
00001a  8030              STRH     r0,[r6,#0]
                  |L1.28|
;;;81             return;
;;;82         }
;;;83     #endif
;;;84     
;;;85     #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;86         if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
;;;87            *p_err = OS_ERR_PRIO_INVALID;
;;;88             return;
;;;89         }
;;;90     #endif
;;;91     
;;;92         if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
;;;93            *p_err = OS_ERR_PRIO_INVALID;
;;;94             return;
;;;95         }
;;;96     
;;;97         if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
;;;98             CPU_CRITICAL_ENTER();
;;;99             p_tcb = OSTCBCurPtr;
;;;100            CPU_CRITICAL_EXIT();
;;;101            self  = DEF_TRUE;
;;;102        } else {
;;;103            self  = DEF_FALSE;
;;;104        }
;;;105    
;;;106        OS_CRITICAL_ENTER();
;;;107        switch (p_tcb->TaskState) {
;;;108            case OS_TASK_STATE_RDY:
;;;109                 OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
;;;110                 p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
;;;111                 OS_PrioInsert(p_tcb->Prio);
;;;112                 if (self == DEF_TRUE) {
;;;113                     OS_RdyListInsertHead(p_tcb);
;;;114                 } else {
;;;115                     OS_RdyListInsertTail(p_tcb);
;;;116                 }
;;;117                 break;
;;;118    
;;;119            case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB */
;;;120            case OS_TASK_STATE_SUSPENDED:
;;;121            case OS_TASK_STATE_DLY_SUSPENDED:
;;;122                 p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
;;;123                 break;
;;;124    
;;;125            case OS_TASK_STATE_PEND:
;;;126            case OS_TASK_STATE_PEND_TIMEOUT:
;;;127            case OS_TASK_STATE_PEND_SUSPENDED:
;;;128            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;129                 switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
;;;130                     case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
;;;131                     case OS_TASK_PEND_ON_TASK_SEM:
;;;132                     case OS_TASK_PEND_ON_FLAG:
;;;133                          p_tcb->Prio = prio_new;               /* Set new task priority                                  */
;;;134                          break;
;;;135    
;;;136                     case OS_TASK_PEND_ON_MUTEX:
;;;137                     case OS_TASK_PEND_ON_MULTI:
;;;138                     case OS_TASK_PEND_ON_Q:
;;;139                     case OS_TASK_PEND_ON_SEM:
;;;140                          OS_PendListChangePrio(p_tcb,
;;;141                                                prio_new);
;;;142                          break;
;;;143    
;;;144                     default:
;;;145                          break;
;;;146                }
;;;147                 break;
;;;148    
;;;149            default:
;;;150                 OS_CRITICAL_EXIT();
;;;151                *p_err = OS_ERR_STATE_INVALID;
;;;152                 return;
;;;153        }
;;;154    
;;;155        OS_CRITICAL_EXIT_NO_SCHED();
;;;156    
;;;157        OSSched();                                              /* Run highest priority task ready                        */
;;;158    
;;;159       *p_err = OS_ERR_NONE;
;;;160    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.32|
000020  2d3f              CMP      r5,#0x3f              ;92
000022  d303              BCC      |L1.44|
000024  f2462073          MOV      r0,#0x6273            ;93
000028  8030              STRH     r0,[r6,#0]            ;93
00002a  e7f7              B        |L1.28|
                  |L1.44|
00002c  b98c              CBNZ     r4,|L1.82|
00002e  bf00              NOP                            ;98
000030  bf00              NOP                            ;98
000032  f7fffffe          BL       CPU_SR_Save
000036  4680              MOV      r8,r0                 ;98
000038  bf00              NOP                            ;98
00003a  bf00              NOP                            ;98
00003c  4836              LDR      r0,|L1.280|
00003e  6804              LDR      r4,[r0,#0]            ;99  ; OSTCBCurPtr
000040  bf00              NOP                            ;100
000042  bf00              NOP                            ;100
000044  4640              MOV      r0,r8                 ;100
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;100
00004c  bf00              NOP                            ;100
00004e  2701              MOVS     r7,#1                 ;101
000050  e000              B        |L1.84|
                  |L1.82|
000052  2700              MOVS     r7,#0                 ;103
                  |L1.84|
000054  bf00              NOP                            ;106
000056  bf00              NOP                            ;106
000058  f7fffffe          BL       CPU_SR_Save
00005c  4680              MOV      r8,r0                 ;106
00005e  bf00              NOP                            ;106
000060  bf00              NOP                            ;106
000062  f8940036          LDRB     r0,[r4,#0x36]         ;107
000066  2808              CMP      r0,#8                 ;107
000068  d23a              BCS      |L1.224|
00006a  e8dff000          TBB      [pc,r0]               ;107
00006e  0417              DCB      0x04,0x17
000070  1c1d1819          DCB      0x1c,0x1d,0x18,0x19
000074  1e1f              DCB      0x1e,0x1f
000076  4620              MOV      r0,r4                 ;109
000078  f7fffffe          BL       OS_RdyListRemove
00007c  f8845037          STRB     r5,[r4,#0x37]         ;110
000080  f8940037          LDRB     r0,[r4,#0x37]         ;111
000084  f7fffffe          BL       OS_PrioInsert
000088  2f01              CMP      r7,#1                 ;112
00008a  d103              BNE      |L1.148|
00008c  4620              MOV      r0,r4                 ;113
00008e  f7fffffe          BL       OS_RdyListInsertHead
000092  e002              B        |L1.154|
                  |L1.148|
000094  4620              MOV      r0,r4                 ;115
000096  f7fffffe          BL       OS_RdyListInsertTail
                  |L1.154|
00009a  e02c              B        |L1.246|
00009c  bf00              NOP                            ;120
00009e  bf00              NOP                            ;121
0000a0  f8845037          STRB     r5,[r4,#0x37]         ;122
0000a4  e027              B        |L1.246|
0000a6  bf00              NOP                            ;126
0000a8  bf00              NOP                            ;127
0000aa  bf00              NOP                            ;128
0000ac  f8940034          LDRB     r0,[r4,#0x34]         ;129
0000b0  2808              CMP      r0,#8                 ;129
0000b2  d212              BCS      |L1.218|
0000b4  e8dff000          TBB      [pc,r0]               ;129
0000b8  1106040a          DCB      0x11,0x06,0x04,0x0a
0000bc  090b0c05          DCB      0x09,0x0b,0x0c,0x05
0000c0  bf00              NOP                            ;131
0000c2  bf00              NOP                            ;132
0000c4  f8845037          STRB     r5,[r4,#0x37]         ;133
0000c8  e008              B        |L1.220|
0000ca  bf00              NOP                            ;137
0000cc  bf00              NOP                            ;138
0000ce  bf00              NOP                            ;139
0000d0  4629              MOV      r1,r5                 ;140
0000d2  4620              MOV      r0,r4                 ;140
0000d4  f7fffffe          BL       OS_PendListChangePrio
0000d8  e000              B        |L1.220|
                  |L1.218|
0000da  bf00              NOP                            ;145
                  |L1.220|
0000dc  bf00              NOP                            ;134
0000de  e00a              B        |L1.246|
                  |L1.224|
0000e0  bf00              NOP                            ;150
0000e2  bf00              NOP                            ;150
0000e4  4640              MOV      r0,r8                 ;150
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  bf00              NOP                            ;150
0000ec  bf00              NOP                            ;150
0000ee  f646602d          MOV      r0,#0x6e2d            ;151
0000f2  8030              STRH     r0,[r6,#0]            ;151
0000f4  e792              B        |L1.28|
                  |L1.246|
0000f6  bf00              NOP                            ;117
0000f8  bf00              NOP                            ;155
0000fa  bf00              NOP                            ;155
0000fc  4640              MOV      r0,r8                 ;155
0000fe  f7fffffe          BL       CPU_SR_Restore
000102  bf00              NOP                            ;155
000104  bf00              NOP                            ;155
000106  f7fffffe          BL       OSSched
00010a  2000              MOVS     r0,#0                 ;159
00010c  8030              STRH     r0,[r6,#0]            ;159
00010e  bf00              NOP      
000110  e784              B        |L1.28|
;;;161    #endif
                          ENDP

000112  0000              DCW      0x0000
                  |L1.276|
                          DCD      OSIntNestingCtr
                  |L1.280|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;248    /*$PAGE*/
;;;249    void  OSTaskCreate (OS_TCB        *p_tcb,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;250                        CPU_CHAR      *p_name,
;;;251                        OS_TASK_PTR    p_task,
;;;252                        void          *p_arg,
;;;253                        OS_PRIO        prio,
;;;254                        CPU_STK       *p_stk_base,
;;;255                        CPU_STK_SIZE   stk_limit,
;;;256                        CPU_STK_SIZE   stk_size,
;;;257                        OS_MSG_QTY     q_size,
;;;258                        OS_TICK        time_quanta,
;;;259                        void          *p_ext,
;;;260                        OS_OPT         opt,
;;;261                        OS_ERR        *p_err)
;;;262    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4690              MOV      r8,r2
00000a  e9dd9519          LDRD     r9,r5,[sp,#0x64]
00000e  9f15              LDR      r7,[sp,#0x54]
000010  9e13              LDR      r6,[sp,#0x4c]
;;;263        CPU_STK_SIZE   i;
;;;264    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;265        OS_REG_ID      reg_nbr;
;;;266    #endif
;;;267    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;268        OS_TLS_ID      id;
;;;269    #endif
;;;270    
;;;271        CPU_STK       *p_sp;
;;;272        CPU_STK       *p_stk_limit;
;;;273        CPU_SR_ALLOC();
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
;;;274    
;;;275    
;;;276    
;;;277    #ifdef OS_SAFETY_CRITICAL
;;;278        if (p_err == (OS_ERR *)0) {
;;;279            OS_SAFETY_CRITICAL_EXCEPTION();
;;;280            return;
;;;281        }
;;;282    #endif
;;;283    
;;;284    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;285        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;286           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;287            return;
;;;288        }
;;;289    #endif
;;;290    
;;;291    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;292        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
000016  4861              LDR      r0,|L2.412|
000018  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00001a  2800              CMP      r0,#0
00001c  dd05              BLE      |L2.42|
;;;293           *p_err = OS_ERR_TASK_CREATE_ISR;
00001e  f247104a          MOV      r0,#0x714a
000022  8028              STRH     r0,[r5,#0]
                  |L2.36|
;;;294            return;
;;;295        }
;;;296    #endif
;;;297    
;;;298    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;299        if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
;;;300           *p_err = OS_ERR_TCB_INVALID;
;;;301            return;
;;;302        }
;;;303        if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
;;;304           *p_err = OS_ERR_TASK_INVALID;
;;;305            return;
;;;306        }
;;;307        if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
;;;308           *p_err = OS_ERR_STK_INVALID;
;;;309            return;
;;;310        }
;;;311        if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
;;;312           *p_err = OS_ERR_STK_SIZE_INVALID;
;;;313            return;
;;;314        }
;;;315        if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
;;;316           *p_err = OS_ERR_STK_LIMIT_INVALID;
;;;317            return;
;;;318        }
;;;319        if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
;;;320           *p_err = OS_ERR_PRIO_INVALID;
;;;321            return;
;;;322        }
;;;323    #endif
;;;324    
;;;325    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;326        if (prio == (OS_PRIO)0) {
;;;327            if (p_tcb != &OSIntQTaskTCB) {
;;;328               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
;;;329                return;
;;;330            }
;;;331        }
;;;332    #endif
;;;333    
;;;334        if (prio == (OS_CFG_PRIO_MAX - 1u)) {
;;;335            if (p_tcb != &OSIdleTaskTCB) {
;;;336               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
;;;337                return;
;;;338            }
;;;339        }
;;;340    
;;;341        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;342    
;;;343       *p_err = OS_ERR_NONE;
;;;344                                                                /* --------------- CLEAR THE TASK'S STACK --------------- */
;;;345        if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
;;;346            if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
;;;347                p_sp = p_stk_base;
;;;348                for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
;;;349                   *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
;;;350                    p_sp++;
;;;351                }
;;;352            }
;;;353        }
;;;354                                                                /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
;;;355    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;356        p_stk_limit = p_stk_base + stk_limit;
;;;357    #else
;;;358        p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
;;;359    #endif
;;;360    
;;;361        p_sp = OSTaskStkInit(p_task,
;;;362                             p_arg,
;;;363                             p_stk_base,
;;;364                             p_stk_limit,
;;;365                             stk_size,
;;;366                             opt);
;;;367    
;;;368                                                                /* -------------- INITIALIZE THE TCB FIELDS ------------- */
;;;369        p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
;;;370        p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
;;;371    
;;;372        p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
;;;373    
;;;374        p_tcb->Prio          = prio;                            /* Save the task's priority                               */
;;;375    
;;;376        p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
;;;377        p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
;;;378    
;;;379        p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
;;;380    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;381        if (time_quanta == (OS_TICK)0) {
;;;382            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;383        } else {
;;;384            p_tcb->TimeQuantaCtr = time_quanta;
;;;385        }
;;;386    #endif
;;;387        p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
;;;388        p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
;;;389        p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
;;;390        p_tcb->Opt           = opt;                             /* Save task options                                      */
;;;391    
;;;392    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;393        for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
;;;394            p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
;;;395        }
;;;396    #endif
;;;397    
;;;398    #if OS_CFG_TASK_Q_EN > 0u
;;;399        OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
;;;400                    q_size);
;;;401    #else
;;;402        (void)&q_size;
;;;403    #endif
;;;404    
;;;405        OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
;;;406    
;;;407    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;408        for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;409            p_tcb->TLS_Tbl[id] = (OS_TLS)0;
;;;410        }
;;;411        OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
;;;412    #endif
;;;413                                                                /* --------------- ADD TASK TO READY LIST --------------- */
;;;414        OS_CRITICAL_ENTER();
;;;415        OS_PrioInsert(p_tcb->Prio);
;;;416        OS_RdyListInsertTail(p_tcb);
;;;417    
;;;418    #if OS_CFG_DBG_EN > 0u
;;;419        OS_TaskDbgListAdd(p_tcb);
;;;420    #endif
;;;421    
;;;422        OSTaskQty++;                                            /* Increment the #tasks counter                           */
;;;423    
;;;424        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
;;;425            OS_CRITICAL_EXIT();
;;;426            return;
;;;427        }
;;;428    
;;;429        OS_CRITICAL_EXIT_NO_SCHED();
;;;430    
;;;431        OSSched();
;;;432    }
000024  b009              ADD      sp,sp,#0x24
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.42|
00002a  b91c              CBNZ     r4,|L2.52|
00002c  f24710ad          MOV      r0,#0x71ad            ;300
000030  8028              STRH     r0,[r5,#0]            ;300
000032  e7f7              B        |L2.36|
                  |L2.52|
000034  f1b80f00          CMP      r8,#0                 ;303
000038  d103              BNE      |L2.66|
00003a  f247104f          MOV      r0,#0x714f            ;304
00003e  8028              STRH     r0,[r5,#0]            ;304
000040  e7f0              B        |L2.36|
                  |L2.66|
000042  b91e              CBNZ     r6,|L2.76|
000044  f646602f          MOV      r0,#0x6e2f            ;308
000048  8028              STRH     r0,[r5,#0]            ;308
00004a  e7eb              B        |L2.36|
                  |L2.76|
00004c  4854              LDR      r0,|L2.416|
00004e  6800              LDR      r0,[r0,#0]            ;311  ; OSCfg_StkSizeMin
000050  4287              CMP      r7,r0                 ;311
000052  d203              BCS      |L2.92|
000054  f6466030          MOV      r0,#0x6e30            ;312
000058  8028              STRH     r0,[r5,#0]            ;312
00005a  e7e3              B        |L2.36|
                  |L2.92|
00005c  9814              LDR      r0,[sp,#0x50]         ;315
00005e  42b8              CMP      r0,r7                 ;315
000060  d303              BCC      |L2.106|
000062  f6466031          MOV      r0,#0x6e31            ;316
000066  8028              STRH     r0,[r5,#0]            ;316
000068  e7dc              B        |L2.36|
                  |L2.106|
00006a  9812              LDR      r0,[sp,#0x48]         ;319
00006c  2840              CMP      r0,#0x40              ;319
00006e  d303              BCC      |L2.120|
000070  f2462073          MOV      r0,#0x6273            ;320
000074  8028              STRH     r0,[r5,#0]            ;320
000076  e7d5              B        |L2.36|
                  |L2.120|
000078  9812              LDR      r0,[sp,#0x48]         ;334
00007a  283f              CMP      r0,#0x3f              ;334
00007c  d106              BNE      |L2.140|
00007e  4849              LDR      r0,|L2.420|
000080  4284              CMP      r4,r0                 ;335
000082  d003              BEQ      |L2.140|
000084  f2462073          MOV      r0,#0x6273            ;336
000088  8028              STRH     r0,[r5,#0]            ;336
00008a  e7cb              B        |L2.36|
                  |L2.140|
00008c  4620              MOV      r0,r4                 ;341
00008e  f7fffffe          BL       OS_TaskInitTCB
000092  2000              MOVS     r0,#0                 ;343
000094  8028              STRH     r0,[r5,#0]            ;343
000096  f0090001          AND      r0,r9,#1              ;345
00009a  b188              CBZ      r0,|L2.192|
00009c  f0090002          AND      r0,r9,#2              ;346
0000a0  b170              CBZ      r0,|L2.192|
0000a2  46b3              MOV      r11,r6                ;347
0000a4  2000              MOVS     r0,#0                 ;348
0000a6  9004              STR      r0,[sp,#0x10]         ;348
0000a8  e007              B        |L2.186|
                  |L2.170|
0000aa  2000              MOVS     r0,#0                 ;349
0000ac  f8cb0000          STR      r0,[r11,#0]           ;349
0000b0  f10b0b04          ADD      r11,r11,#4            ;350
0000b4  9804              LDR      r0,[sp,#0x10]         ;348
0000b6  1c40              ADDS     r0,r0,#1              ;348
0000b8  9004              STR      r0,[sp,#0x10]         ;348
                  |L2.186|
0000ba  9804              LDR      r0,[sp,#0x10]         ;348
0000bc  42b8              CMP      r0,r7                 ;348
0000be  d3f4              BCC      |L2.170|
                  |L2.192|
0000c0  9814              LDR      r0,[sp,#0x50]         ;356
0000c2  eb060080          ADD      r0,r6,r0,LSL #2       ;356
0000c6  9003              STR      r0,[sp,#0xc]          ;356
0000c8  e9cd7900          STRD     r7,r9,[sp,#0]         ;361
0000cc  4632              MOV      r2,r6                 ;361
0000ce  4640              MOV      r0,r8                 ;361
0000d0  9b03              LDR      r3,[sp,#0xc]          ;361
0000d2  9908              LDR      r1,[sp,#0x20]         ;361
0000d4  f7fffffe          BL       OSTaskStkInit
0000d8  4683              MOV      r11,r0                ;361
0000da  f8c48028          STR      r8,[r4,#0x28]         ;369
0000de  9808              LDR      r0,[sp,#0x20]         ;370
0000e0  62e0              STR      r0,[r4,#0x2c]         ;370
0000e2  9806              LDR      r0,[sp,#0x18]         ;372
0000e4  6220              STR      r0,[r4,#0x20]         ;372
0000e6  9812              LDR      r0,[sp,#0x48]         ;374
0000e8  f8840037          STRB     r0,[r4,#0x37]         ;374
0000ec  f8c4b000          STR      r11,[r4,#0]           ;376
0000f0  9803              LDR      r0,[sp,#0xc]          ;377
0000f2  60a0              STR      r0,[r4,#8]            ;377
0000f4  9817              LDR      r0,[sp,#0x5c]         ;379
0000f6  6560              STR      r0,[r4,#0x54]         ;379
0000f8  9817              LDR      r0,[sp,#0x5c]         ;381
0000fa  b918              CBNZ     r0,|L2.260|
0000fc  482a              LDR      r0,|L2.424|
0000fe  6800              LDR      r0,[r0,#0]            ;382  ; OSSchedRoundRobinDfltTimeQuanta
000100  65a0              STR      r0,[r4,#0x58]         ;382
000102  e001              B        |L2.264|
                  |L2.260|
000104  9817              LDR      r0,[sp,#0x5c]         ;384
000106  65a0              STR      r0,[r4,#0x58]         ;384
                  |L2.264|
000108  9818              LDR      r0,[sp,#0x60]         ;387
00010a  6060              STR      r0,[r4,#4]            ;387
00010c  6266              STR      r6,[r4,#0x24]         ;388
00010e  63a7              STR      r7,[r4,#0x38]         ;389
000110  f8a4903c          STRH     r9,[r4,#0x3c]         ;390
000114  f04f0a00          MOV      r10,#0                ;393
000118  e008              B        |L2.300|
                  |L2.282|
00011a  2100              MOVS     r1,#0                 ;394
00011c  f104007c          ADD      r0,r4,#0x7c           ;394
000120  f840102a          STR      r1,[r0,r10,LSL #2]    ;394
000124  f10a0001          ADD      r0,r10,#1             ;393
000128  f0000aff          AND      r10,r0,#0xff          ;393
                  |L2.300|
00012c  f1ba0f00          CMP      r10,#0                ;393
000130  d0f3              BEQ      |L2.282|
000132  f1040064          ADD      r0,r4,#0x64           ;399
000136  9916              LDR      r1,[sp,#0x58]         ;399
000138  f7fffffe          BL       OS_MsgQInit
00013c  4620              MOV      r0,r4                 ;405
00013e  f7fffffe          BL       OSTaskCreateHook
000142  bf00              NOP                            ;414
000144  bf00              NOP                            ;414
000146  f7fffffe          BL       CPU_SR_Save
00014a  9002              STR      r0,[sp,#8]            ;414
00014c  bf00              NOP                            ;414
00014e  bf00              NOP                            ;414
000150  f8940037          LDRB     r0,[r4,#0x37]         ;415
000154  f7fffffe          BL       OS_PrioInsert
000158  4620              MOV      r0,r4                 ;416
00015a  f7fffffe          BL       OS_RdyListInsertTail
00015e  4620              MOV      r0,r4                 ;419
000160  f7fffffe          BL       OS_TaskDbgListAdd
000164  4811              LDR      r0,|L2.428|
000166  8800              LDRH     r0,[r0,#0]            ;422  ; OSTaskQty
000168  1c40              ADDS     r0,r0,#1              ;422
00016a  4910              LDR      r1,|L2.428|
00016c  8008              STRH     r0,[r1,#0]            ;422
00016e  4810              LDR      r0,|L2.432|
000170  7800              LDRB     r0,[r0,#0]            ;424  ; OSRunning
000172  2801              CMP      r0,#1                 ;424
000174  d007              BEQ      |L2.390|
000176  bf00              NOP                            ;425
000178  bf00              NOP                            ;425
00017a  9802              LDR      r0,[sp,#8]            ;425
00017c  f7fffffe          BL       CPU_SR_Restore
000180  bf00              NOP                            ;425
000182  bf00              NOP                            ;425
000184  e74e              B        |L2.36|
                  |L2.390|
000186  bf00              NOP                            ;429
000188  bf00              NOP                            ;429
00018a  9802              LDR      r0,[sp,#8]            ;429
00018c  f7fffffe          BL       CPU_SR_Restore
000190  bf00              NOP                            ;429
000192  bf00              NOP                            ;429
000194  f7fffffe          BL       OSSched
000198  bf00              NOP      
00019a  e743              B        |L2.36|
;;;433    
                          ENDP

                  |L2.412|
                          DCD      OSIntNestingCtr
                  |L2.416|
                          DCD      OSCfg_StkSizeMin
                  |L2.420|
                          DCD      OSIdleTaskTCB
                  |L2.424|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L2.428|
                          DCD      OSTaskQty
                  |L2.432|
                          DCD      OSRunning

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;459    #if OS_CFG_TASK_DEL_EN > 0u
;;;460    void  OSTaskDel (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;461                     OS_ERR  *p_err)
;;;462    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;463        CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;464    
;;;465    
;;;466    
;;;467    #ifdef OS_SAFETY_CRITICAL
;;;468        if (p_err == (OS_ERR *)0) {
;;;469            OS_SAFETY_CRITICAL_EXCEPTION();
;;;470            return;
;;;471        }
;;;472    #endif
;;;473    
;;;474    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;475        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
000008  4843              LDR      r0,|L3.280|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L3.24|
;;;476           *p_err = OS_ERR_TASK_DEL_ISR;
000010  f247104e          MOV      r0,#0x714e
000014  8028              STRH     r0,[r5,#0]
                  |L3.22|
;;;477            return;
;;;478        }
;;;479    #endif
;;;480    
;;;481        if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
;;;482           *p_err = OS_ERR_TASK_DEL_IDLE;
;;;483            return;
;;;484        }
;;;485    
;;;486    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;487        if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
;;;488           *p_err = OS_ERR_TASK_DEL_INVALID;
;;;489            return;
;;;490        }
;;;491    #endif
;;;492    
;;;493        if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
;;;494            CPU_CRITICAL_ENTER();
;;;495            p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
;;;496            CPU_CRITICAL_EXIT();
;;;497        }
;;;498    
;;;499        OS_CRITICAL_ENTER();
;;;500        switch (p_tcb->TaskState) {
;;;501            case OS_TASK_STATE_RDY:
;;;502                 OS_RdyListRemove(p_tcb);
;;;503                 break;
;;;504    
;;;505            case OS_TASK_STATE_SUSPENDED:
;;;506                 break;
;;;507    
;;;508            case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
;;;509            case OS_TASK_STATE_DLY_SUSPENDED:
;;;510                 OS_TickListRemove(p_tcb);
;;;511                 break;
;;;512    
;;;513            case OS_TASK_STATE_PEND:
;;;514            case OS_TASK_STATE_PEND_SUSPENDED:
;;;515            case OS_TASK_STATE_PEND_TIMEOUT:
;;;516            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;517                 OS_TickListRemove(p_tcb);
;;;518                 switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
;;;519                     case OS_TASK_PEND_ON_NOTHING:
;;;520                     case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
;;;521                     case OS_TASK_PEND_ON_TASK_SEM:
;;;522                          break;
;;;523    
;;;524                     case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
;;;525                     case OS_TASK_PEND_ON_MULTI:
;;;526                     case OS_TASK_PEND_ON_MUTEX:
;;;527                     case OS_TASK_PEND_ON_Q:
;;;528                     case OS_TASK_PEND_ON_SEM:
;;;529                          OS_PendListRemove(p_tcb);
;;;530                          break;
;;;531    
;;;532                     default:
;;;533                          break;
;;;534                 }
;;;535                 break;
;;;536    
;;;537            default:
;;;538                OS_CRITICAL_EXIT();
;;;539               *p_err = OS_ERR_STATE_INVALID;
;;;540                return;
;;;541        }
;;;542    
;;;543    #if OS_CFG_TASK_Q_EN > 0u
;;;544        (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
;;;545    #endif
;;;546    
;;;547        OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
;;;548    
;;;549    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;550        OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
;;;551    #endif
;;;552    
;;;553    #if OS_CFG_DBG_EN > 0u
;;;554        OS_TaskDbgListRemove(p_tcb);
;;;555    #endif
;;;556        OSTaskQty--;                                            /* One less task being managed                            */
;;;557    
;;;558        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;559        p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
;;;560    
;;;561        OS_CRITICAL_EXIT_NO_SCHED();
;;;562    
;;;563       *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
;;;564    
;;;565        OSSched();                                              /* Find new highest priority task                         */
;;;566    }
000016  bd70              POP      {r4-r6,pc}
                  |L3.24|
000018  4840              LDR      r0,|L3.284|
00001a  4284              CMP      r4,r0                 ;481
00001c  d103              BNE      |L3.38|
00001e  f247104c          MOV      r0,#0x714c            ;482
000022  8028              STRH     r0,[r5,#0]            ;482
000024  e7f7              B        |L3.22|
                  |L3.38|
000026  b97c              CBNZ     r4,|L3.72|
000028  bf00              NOP                            ;494
00002a  bf00              NOP                            ;494
00002c  f7fffffe          BL       CPU_SR_Save
000030  4606              MOV      r6,r0                 ;494
000032  bf00              NOP                            ;494
000034  bf00              NOP                            ;494
000036  483a              LDR      r0,|L3.288|
000038  6804              LDR      r4,[r0,#0]            ;495  ; OSTCBCurPtr
00003a  bf00              NOP                            ;496
00003c  bf00              NOP                            ;496
00003e  4630              MOV      r0,r6                 ;496
000040  f7fffffe          BL       CPU_SR_Restore
000044  bf00              NOP                            ;496
000046  bf00              NOP                            ;496
                  |L3.72|
000048  bf00              NOP                            ;499
00004a  bf00              NOP                            ;499
00004c  f7fffffe          BL       CPU_SR_Save
000050  4606              MOV      r6,r0                 ;499
000052  bf00              NOP                            ;499
000054  bf00              NOP                            ;499
000056  f8940036          LDRB     r0,[r4,#0x36]         ;500
00005a  2808              CMP      r0,#8                 ;500
00005c  d22d              BCS      |L3.186|
00005e  e8dff000          TBB      [pc,r0]               ;500
000062  0409              DCB      0x04,0x09
000064  0e10080a          DCB      0x0e,0x10,0x08,0x0a
000068  0f11              DCB      0x0f,0x11
00006a  4620              MOV      r0,r4                 ;502
00006c  f7fffffe          BL       OS_RdyListRemove
000070  e02e              B        |L3.208|
000072  e02d              B        |L3.208|
000074  bf00              NOP                            ;509
000076  4620              MOV      r0,r4                 ;510
000078  f7fffffe          BL       OS_TickListRemove
00007c  e028              B        |L3.208|
00007e  bf00              NOP                            ;514
000080  bf00              NOP                            ;515
000082  bf00              NOP                            ;516
000084  4620              MOV      r0,r4                 ;517
000086  f7fffffe          BL       OS_TickListRemove
00008a  f8940034          LDRB     r0,[r4,#0x34]         ;518
00008e  2808              CMP      r0,#8                 ;518
000090  d210              BCS      |L3.180|
000092  e8dff000          TBB      [pc,r0]               ;518
000096  0407              DCB      0x04,0x07
000098  0508090a          DCB      0x05,0x08,0x09,0x0a
00009c  0b06              DCB      0x0b,0x06
00009e  bf00              NOP                            ;520
0000a0  bf00              NOP                            ;521
0000a2  e008              B        |L3.182|
0000a4  bf00              NOP                            ;525
0000a6  bf00              NOP                            ;526
0000a8  bf00              NOP                            ;527
0000aa  bf00              NOP                            ;528
0000ac  4620              MOV      r0,r4                 ;529
0000ae  f7fffffe          BL       OS_PendListRemove
0000b2  e000              B        |L3.182|
                  |L3.180|
0000b4  bf00              NOP                            ;533
                  |L3.182|
0000b6  bf00              NOP                            ;522
0000b8  e00a              B        |L3.208|
                  |L3.186|
0000ba  bf00              NOP                            ;538
0000bc  bf00              NOP                            ;538
0000be  4630              MOV      r0,r6                 ;538
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  bf00              NOP                            ;538
0000c6  bf00              NOP                            ;538
0000c8  f646602d          MOV      r0,#0x6e2d            ;539
0000cc  8028              STRH     r0,[r5,#0]            ;539
0000ce  e7a2              B        |L3.22|
                  |L3.208|
0000d0  bf00              NOP                            ;503
0000d2  f1040064          ADD      r0,r4,#0x64           ;544
0000d6  f7fffffe          BL       OS_MsgQFreeAll
0000da  4620              MOV      r0,r4                 ;547
0000dc  f7fffffe          BL       OSTaskDelHook
0000e0  4620              MOV      r0,r4                 ;554
0000e2  f7fffffe          BL       OS_TaskDbgListRemove
0000e6  480f              LDR      r0,|L3.292|
0000e8  8800              LDRH     r0,[r0,#0]            ;556  ; OSTaskQty
0000ea  1e40              SUBS     r0,r0,#1              ;556
0000ec  490d              LDR      r1,|L3.292|
0000ee  8008              STRH     r0,[r1,#0]            ;556
0000f0  4620              MOV      r0,r4                 ;558
0000f2  f7fffffe          BL       OS_TaskInitTCB
0000f6  20ff              MOVS     r0,#0xff              ;559
0000f8  f8840036          STRB     r0,[r4,#0x36]         ;559
0000fc  bf00              NOP                            ;561
0000fe  bf00              NOP                            ;561
000100  4630              MOV      r0,r6                 ;561
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP                            ;561
000108  bf00              NOP                            ;561
00010a  2000              MOVS     r0,#0                 ;563
00010c  8028              STRH     r0,[r5,#0]            ;563
00010e  f7fffffe          BL       OSSched
000112  bf00              NOP      
000114  e77f              B        |L3.22|
;;;567    #endif
                          ENDP

000116  0000              DCW      0x0000
                  |L3.280|
                          DCD      OSIntNestingCtr
                  |L3.284|
                          DCD      OSIdleTaskTCB
                  |L3.288|
                          DCD      OSTCBCurPtr
                  |L3.292|
                          DCD      OSTaskQty

                          AREA ||i.OSTaskQFlush||, CODE, READONLY, ALIGN=2

                  OSTaskQFlush PROC
;;;593    #if OS_CFG_TASK_Q_EN > 0u
;;;594    OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;595                              OS_ERR  *p_err)
;;;596    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;597        OS_MSG_QTY  entries;
;;;598        CPU_SR_ALLOC();
000008  2600              MOVS     r6,#0
;;;599    
;;;600    
;;;601    
;;;602    #ifdef OS_SAFETY_CRITICAL
;;;603        if (p_err == (OS_ERR *)0) {
;;;604            OS_SAFETY_CRITICAL_EXCEPTION();
;;;605            return ((OS_MSG_QTY)0);
;;;606        }
;;;607    #endif
;;;608    
;;;609    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;610        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
00000a  4819              LDR      r0,|L4.112|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  2800              CMP      r0,#0
000010  dd05              BLE      |L4.30|
;;;611           *p_err = OS_ERR_FLUSH_ISR;
000012  f44f506c          MOV      r0,#0x3b00
000016  8028              STRH     r0,[r5,#0]
;;;612            return ((OS_MSG_QTY)0);
000018  2000              MOVS     r0,#0
                  |L4.26|
;;;613        }
;;;614    #endif
;;;615    
;;;616        if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
;;;617            CPU_CRITICAL_ENTER();
;;;618            p_tcb = OSTCBCurPtr;
;;;619            CPU_CRITICAL_EXIT();
;;;620        }
;;;621    
;;;622        OS_CRITICAL_ENTER();
;;;623        entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
;;;624        OS_CRITICAL_EXIT();
;;;625       *p_err   = OS_ERR_NONE;
;;;626        return (entries);
;;;627    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.30|
00001e  b97c              CBNZ     r4,|L4.64|
000020  bf00              NOP                            ;617
000022  bf00              NOP                            ;617
000024  f7fffffe          BL       CPU_SR_Save
000028  4606              MOV      r6,r0                 ;617
00002a  bf00              NOP                            ;617
00002c  bf00              NOP                            ;617
00002e  4811              LDR      r0,|L4.116|
000030  6804              LDR      r4,[r0,#0]            ;618  ; OSTCBCurPtr
000032  bf00              NOP                            ;619
000034  bf00              NOP                            ;619
000036  4630              MOV      r0,r6                 ;619
000038  f7fffffe          BL       CPU_SR_Restore
00003c  bf00              NOP                            ;619
00003e  bf00              NOP                            ;619
                  |L4.64|
000040  bf00              NOP                            ;622
000042  bf00              NOP                            ;622
000044  f7fffffe          BL       CPU_SR_Save
000048  4606              MOV      r6,r0                 ;622
00004a  bf00              NOP                            ;622
00004c  bf00              NOP                            ;622
00004e  f1040064          ADD      r0,r4,#0x64           ;623
000052  f7fffffe          BL       OS_MsgQFreeAll
000056  4607              MOV      r7,r0                 ;623
000058  bf00              NOP                            ;624
00005a  bf00              NOP                            ;624
00005c  4630              MOV      r0,r6                 ;624
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP                            ;624
000064  bf00              NOP                            ;624
000066  2000              MOVS     r0,#0                 ;625
000068  8028              STRH     r0,[r5,#0]            ;625
00006a  4638              MOV      r0,r7                 ;626
00006c  e7d5              B        |L4.26|
;;;628    #endif
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      OSIntNestingCtr
                  |L4.116|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPend||, CODE, READONLY, ALIGN=2

                  OSTaskQPend PROC
;;;671    #if OS_CFG_TASK_Q_EN > 0u
;;;672    void  *OSTaskQPend (OS_TICK       timeout,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;673                        OS_OPT        opt,
;;;674                        OS_MSG_SIZE  *p_msg_size,
;;;675                        CPU_TS       *p_ts,
;;;676                        OS_ERR       *p_err)
;;;677    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;678        OS_MSG_Q     *p_msg_q;
;;;679        void         *p_void;
;;;680        CPU_SR_ALLOC();
00000e  f04f0b00          MOV      r11,#0
;;;681    
;;;682    
;;;683    
;;;684    #ifdef OS_SAFETY_CRITICAL
;;;685        if (p_err == (OS_ERR *)0) {
;;;686            OS_SAFETY_CRITICAL_EXCEPTION();
;;;687            return ((void *)0);
;;;688        }
;;;689    #endif
;;;690    
;;;691    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;692        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
000012  486e              LDR      r0,|L5.460|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000016  2800              CMP      r0,#0
000018  dd05              BLE      |L5.38|
;;;693           *p_err = OS_ERR_PEND_ISR;
00001a  f24610ae          MOV      r0,#0x61ae
00001e  8028              STRH     r0,[r5,#0]
;;;694            return ((void *)0);
000020  2000              MOVS     r0,#0
                  |L5.34|
;;;695        }
;;;696    #endif
;;;697    
;;;698    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;699        if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
;;;700           *p_err = OS_ERR_PTR_INVALID;
;;;701            return ((void *)0);
;;;702        }
;;;703        switch (opt) {                                          /* User must supply a valid option                        */
;;;704            case OS_OPT_PEND_BLOCKING:
;;;705            case OS_OPT_PEND_NON_BLOCKING:
;;;706                 break;
;;;707    
;;;708            default:
;;;709                *p_err = OS_ERR_OPT_INVALID;
;;;710                 return ((void *)0);
;;;711        }
;;;712    #endif
;;;713    
;;;714        if (p_ts != (CPU_TS *)0) {
;;;715           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;716        }
;;;717    
;;;718        CPU_CRITICAL_ENTER();
;;;719        p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
;;;720        p_void  = OS_MsgQGet(p_msg_q,
;;;721                             p_msg_size,
;;;722                             p_ts,
;;;723                             p_err);
;;;724        if (*p_err == OS_ERR_NONE) {
;;;725    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;726            if (p_ts != (CPU_TS *)0) {
;;;727                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
;;;728                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;729                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;730                }
;;;731            }
;;;732    #endif
;;;733            CPU_CRITICAL_EXIT();
;;;734            return (p_void);                                    /* Yes, Return oldest message received                    */
;;;735        }
;;;736    
;;;737        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;738           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;739            CPU_CRITICAL_EXIT();
;;;740            return ((void *)0);
;;;741        } else {                                                /* Yes                                                    */
;;;742            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
;;;743                CPU_CRITICAL_EXIT();
;;;744               *p_err = OS_ERR_SCHED_LOCKED;
;;;745                return ((void *)0);
;;;746            }
;;;747        }
;;;748                                                                /* Lock the scheduler/re-enable interrupts                */
;;;749        OS_CRITICAL_ENTER_CPU_EXIT();
;;;750        OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
;;;751                (OS_PEND_OBJ  *)0,
;;;752                (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
;;;753                (OS_TICK       )timeout);
;;;754        OS_CRITICAL_EXIT_NO_SCHED();
;;;755    
;;;756        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;757    
;;;758        CPU_CRITICAL_ENTER();
;;;759        switch (OSTCBCurPtr->PendStatus) {
;;;760            case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
;;;761                 p_void      = OSTCBCurPtr->MsgPtr;
;;;762                *p_msg_size  = OSTCBCurPtr->MsgSize;
;;;763                 if (p_ts != (CPU_TS *)0) {
;;;764                    *p_ts  = OSTCBCurPtr->TS;
;;;765    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;766                    OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;767                    if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;768                        OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;769                    }
;;;770    #endif
;;;771                 }
;;;772                *p_err = OS_ERR_NONE;
;;;773                 break;
;;;774    
;;;775            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;776                 p_void     = (void      *)0;
;;;777                *p_msg_size = (OS_MSG_SIZE)0;
;;;778                 if (p_ts  != (CPU_TS *)0) {
;;;779                    *p_ts   = (CPU_TS  )0;
;;;780                 }
;;;781                *p_err      =  OS_ERR_PEND_ABORT;
;;;782                 break;
;;;783    
;;;784            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
;;;785            default:
;;;786                 p_void     = (void      *)0;
;;;787                *p_msg_size = (OS_MSG_SIZE)0;
;;;788                 if (p_ts  != (CPU_TS *)0) {
;;;789                    *p_ts   =  OSTCBCurPtr->TS;
;;;790                 }
;;;791                *p_err      =  OS_ERR_TIMEOUT;
;;;792                 break;
;;;793        }
;;;794        CPU_CRITICAL_EXIT();
;;;795        return (p_void);                                        /* Return received message                                */
;;;796    }
000022  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.38|
000026  b926              CBNZ     r6,|L5.50|
000028  f24620d5          MOV      r0,#0x62d5            ;700
00002c  8028              STRH     r0,[r5,#0]            ;700
00002e  2000              MOVS     r0,#0                 ;701
000030  e7f7              B        |L5.34|
                  |L5.50|
000032  b11f              CBZ      r7,|L5.60|
000034  f5b74f00          CMP      r7,#0x8000            ;703
000038  d102              BNE      |L5.64|
00003a  e000              B        |L5.62|
                  |L5.60|
00003c  bf00              NOP                            ;705
                  |L5.62|
00003e  e004              B        |L5.74|
                  |L5.64|
000040  f6456025          MOV      r0,#0x5e25            ;709
000044  8028              STRH     r0,[r5,#0]            ;709
000046  2000              MOVS     r0,#0                 ;710
000048  e7eb              B        |L5.34|
                  |L5.74|
00004a  bf00              NOP                            ;706
00004c  b10c              CBZ      r4,|L5.82|
00004e  2000              MOVS     r0,#0                 ;715
000050  6020              STR      r0,[r4,#0]            ;715
                  |L5.82|
000052  bf00              NOP                            ;718
000054  bf00              NOP                            ;718
000056  f7fffffe          BL       CPU_SR_Save
00005a  4683              MOV      r11,r0                ;718
00005c  bf00              NOP                            ;718
00005e  bf00              NOP                            ;718
000060  485b              LDR      r0,|L5.464|
000062  6800              LDR      r0,[r0,#0]            ;719  ; OSTCBCurPtr
000064  f1000964          ADD      r9,r0,#0x64           ;719
000068  462b              MOV      r3,r5                 ;720
00006a  4622              MOV      r2,r4                 ;720
00006c  4631              MOV      r1,r6                 ;720
00006e  4648              MOV      r0,r9                 ;720
000070  f7fffffe          BL       OS_MsgQGet
000074  4682              MOV      r10,r0                ;720
000076  8828              LDRH     r0,[r5,#0]            ;724
000078  b9f0              CBNZ     r0,|L5.184|
00007a  b1a4              CBZ      r4,|L5.166|
00007c  f7fffffe          BL       CPU_TS_TmrRd
000080  6821              LDR      r1,[r4,#0]            ;727
000082  1a40              SUBS     r0,r0,r1              ;727
000084  4952              LDR      r1,|L5.464|
000086  6809              LDR      r1,[r1,#0]            ;727  ; OSTCBCurPtr
000088  6748              STR      r0,[r1,#0x74]         ;727
00008a  4851              LDR      r0,|L5.464|
00008c  6800              LDR      r0,[r0,#0]            ;728  ; OSTCBCurPtr
00008e  6f80              LDR      r0,[r0,#0x78]         ;728
000090  494f              LDR      r1,|L5.464|
000092  6809              LDR      r1,[r1,#0]            ;728  ; OSTCBCurPtr
000094  6f49              LDR      r1,[r1,#0x74]         ;728
000096  4288              CMP      r0,r1                 ;728
000098  d205              BCS      |L5.166|
00009a  484d              LDR      r0,|L5.464|
00009c  6800              LDR      r0,[r0,#0]            ;729  ; OSTCBCurPtr
00009e  6f40              LDR      r0,[r0,#0x74]         ;729
0000a0  494b              LDR      r1,|L5.464|
0000a2  6809              LDR      r1,[r1,#0]            ;729  ; OSTCBCurPtr
0000a4  6788              STR      r0,[r1,#0x78]         ;729
                  |L5.166|
0000a6  bf00              NOP                            ;733
0000a8  bf00              NOP                            ;733
0000aa  4658              MOV      r0,r11                ;733
0000ac  f7fffffe          BL       CPU_SR_Restore
0000b0  bf00              NOP                            ;733
0000b2  bf00              NOP                            ;733
0000b4  4650              MOV      r0,r10                ;734
0000b6  e7b4              B        |L5.34|
                  |L5.184|
0000b8  f4074000          AND      r0,r7,#0x8000         ;737
0000bc  b158              CBZ      r0,|L5.214|
0000be  f24610b0          MOV      r0,#0x61b0            ;738
0000c2  8028              STRH     r0,[r5,#0]            ;738
0000c4  bf00              NOP                            ;739
0000c6  bf00              NOP                            ;739
0000c8  4658              MOV      r0,r11                ;739
0000ca  f7fffffe          BL       CPU_SR_Restore
0000ce  bf00              NOP                            ;739
0000d0  bf00              NOP                            ;739
0000d2  2000              MOVS     r0,#0                 ;740
0000d4  e7a5              B        |L5.34|
                  |L5.214|
0000d6  483f              LDR      r0,|L5.468|
0000d8  7800              LDRB     r0,[r0,#0]            ;742  ; OSSchedLockNestingCtr
0000da  2800              CMP      r0,#0                 ;742
0000dc  dd0b              BLE      |L5.246|
0000de  bf00              NOP                            ;743
0000e0  bf00              NOP                            ;743
0000e2  4658              MOV      r0,r11                ;743
0000e4  f7fffffe          BL       CPU_SR_Restore
0000e8  bf00              NOP                            ;743
0000ea  bf00              NOP                            ;743
0000ec  f6465063          MOV      r0,#0x6d63            ;744
0000f0  8028              STRH     r0,[r5,#0]            ;744
0000f2  2000              MOVS     r0,#0                 ;745
0000f4  e795              B        |L5.34|
                  |L5.246|
0000f6  4643              MOV      r3,r8                 ;750
0000f8  2202              MOVS     r2,#2                 ;750
0000fa  2100              MOVS     r1,#0                 ;750
0000fc  4608              MOV      r0,r1                 ;750
0000fe  f7fffffe          BL       OS_Pend
000102  bf00              NOP                            ;754
000104  bf00              NOP                            ;754
000106  4658              MOV      r0,r11                ;754
000108  f7fffffe          BL       CPU_SR_Restore
00010c  bf00              NOP                            ;754
00010e  bf00              NOP                            ;754
000110  f7fffffe          BL       OSSched
000114  bf00              NOP                            ;758
000116  bf00              NOP                            ;758
000118  f7fffffe          BL       CPU_SR_Save
00011c  4683              MOV      r11,r0                ;758
00011e  bf00              NOP                            ;758
000120  bf00              NOP                            ;758
000122  482b              LDR      r0,|L5.464|
000124  6800              LDR      r0,[r0,#0]            ;759  ; OSTCBCurPtr
000126  f8900035          LDRB     r0,[r0,#0x35]         ;759
00012a  b120              CBZ      r0,|L5.310|
00012c  2801              CMP      r0,#1                 ;759
00012e  d02a              BEQ      |L5.390|
000130  2803              CMP      r0,#3                 ;759
000132  d132              BNE      |L5.410|
000134  e032              B        |L5.412|
                  |L5.310|
000136  4826              LDR      r0,|L5.464|
000138  6800              LDR      r0,[r0,#0]            ;761  ; OSTCBCurPtr
00013a  f8d0a05c          LDR      r10,[r0,#0x5c]        ;761
00013e  4824              LDR      r0,|L5.464|
000140  6800              LDR      r0,[r0,#0]            ;762  ; OSTCBCurPtr
000142  f8b00060          LDRH     r0,[r0,#0x60]         ;762
000146  8030              STRH     r0,[r6,#0]            ;762
000148  b1d4              CBZ      r4,|L5.384|
00014a  4821              LDR      r0,|L5.464|
00014c  6800              LDR      r0,[r0,#0]            ;764  ; OSTCBCurPtr
00014e  6c00              LDR      r0,[r0,#0x40]         ;764
000150  6020              STR      r0,[r4,#0]            ;764
000152  f7fffffe          BL       CPU_TS_TmrRd
000156  491e              LDR      r1,|L5.464|
000158  6809              LDR      r1,[r1,#0]            ;766  ; OSTCBCurPtr
00015a  6c09              LDR      r1,[r1,#0x40]         ;766
00015c  1a40              SUBS     r0,r0,r1              ;766
00015e  491c              LDR      r1,|L5.464|
000160  6809              LDR      r1,[r1,#0]            ;766  ; OSTCBCurPtr
000162  6748              STR      r0,[r1,#0x74]         ;766
000164  481a              LDR      r0,|L5.464|
000166  6800              LDR      r0,[r0,#0]            ;767  ; OSTCBCurPtr
000168  6f80              LDR      r0,[r0,#0x78]         ;767
00016a  4919              LDR      r1,|L5.464|
00016c  6809              LDR      r1,[r1,#0]            ;767  ; OSTCBCurPtr
00016e  6f49              LDR      r1,[r1,#0x74]         ;767
000170  4288              CMP      r0,r1                 ;767
000172  d205              BCS      |L5.384|
000174  4816              LDR      r0,|L5.464|
000176  6800              LDR      r0,[r0,#0]            ;768  ; OSTCBCurPtr
000178  6f40              LDR      r0,[r0,#0x74]         ;768
00017a  4915              LDR      r1,|L5.464|
00017c  6809              LDR      r1,[r1,#0]            ;768  ; OSTCBCurPtr
00017e  6788              STR      r0,[r1,#0x78]         ;768
                  |L5.384|
000180  2000              MOVS     r0,#0                 ;772
000182  8028              STRH     r0,[r5,#0]            ;772
000184  e017              B        |L5.438|
                  |L5.390|
000186  f04f0a00          MOV      r10,#0                ;776
00018a  2000              MOVS     r0,#0                 ;777
00018c  8030              STRH     r0,[r6,#0]            ;777
00018e  b104              CBZ      r4,|L5.402|
000190  6020              STR      r0,[r4,#0]            ;779
                  |L5.402|
000192  f24610a9          MOV      r0,#0x61a9            ;781
000196  8028              STRH     r0,[r5,#0]            ;781
000198  e00d              B        |L5.438|
                  |L5.410|
00019a  bf00              NOP                            ;784
                  |L5.412|
00019c  f04f0a00          MOV      r10,#0                ;786
0001a0  2000              MOVS     r0,#0                 ;787
0001a2  8030              STRH     r0,[r6,#0]            ;787
0001a4  b11c              CBZ      r4,|L5.430|
0001a6  480a              LDR      r0,|L5.464|
0001a8  6800              LDR      r0,[r0,#0]            ;789  ; OSTCBCurPtr
0001aa  6c00              LDR      r0,[r0,#0x40]         ;789
0001ac  6020              STR      r0,[r4,#0]            ;789
                  |L5.430|
0001ae  f24720d9          MOV      r0,#0x72d9            ;791
0001b2  8028              STRH     r0,[r5,#0]            ;791
0001b4  bf00              NOP                            ;792
                  |L5.438|
0001b6  bf00              NOP                            ;773
0001b8  bf00              NOP                            ;794
0001ba  bf00              NOP                            ;794
0001bc  4658              MOV      r0,r11                ;794
0001be  f7fffffe          BL       CPU_SR_Restore
0001c2  bf00              NOP                            ;794
0001c4  bf00              NOP                            ;794
0001c6  4650              MOV      r0,r10                ;795
0001c8  e72b              B        |L5.34|
;;;797    #endif
                          ENDP

0001ca  0000              DCW      0x0000
                  |L5.460|
                          DCD      OSIntNestingCtr
                  |L5.464|
                          DCD      OSTCBCurPtr
                  |L5.468|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskQPendAbort PROC
;;;827    #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
;;;828    CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;829                                   OS_OPT   opt,
;;;830                                   OS_ERR  *p_err)
;;;831    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;832        CPU_TS         ts;
;;;833        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;834    
;;;835    
;;;836    
;;;837    #ifdef OS_SAFETY_CRITICAL
;;;838        if (p_err == (OS_ERR *)0) {
;;;839            OS_SAFETY_CRITICAL_EXCEPTION();
;;;840            return (DEF_FALSE);
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;845        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
00000c  482b              LDR      r0,|L6.188|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  2800              CMP      r0,#0
000012  dd05              BLE      |L6.32|
;;;846           *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
000014  f24610aa          MOV      r0,#0x61aa
000018  8020              STRH     r0,[r4,#0]
;;;847            return (DEF_FALSE);
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;848        }
;;;849    #endif
;;;850    
;;;851    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;852        switch (opt) {                                          /* User must supply a valid option                        */
;;;853            case OS_OPT_POST_NONE:
;;;854            case OS_OPT_POST_NO_SCHED:
;;;855                 break;
;;;856    
;;;857            default:
;;;858                *p_err = OS_ERR_OPT_INVALID;
;;;859                 return (DEF_FALSE);
;;;860        }
;;;861    #endif
;;;862    
;;;863        CPU_CRITICAL_ENTER();
;;;864    #if OS_CFG_ARG_CHK_EN > 0u
;;;865        if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
;;;866            (p_tcb == OSTCBCurPtr)) {
;;;867            CPU_CRITICAL_EXIT();
;;;868           *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
;;;869            return (DEF_FALSE);
;;;870        }
;;;871    #endif
;;;872    
;;;873        if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
;;;874            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;875           *p_err = OS_ERR_PEND_ABORT_NONE;
;;;876            return (DEF_FALSE);
;;;877        }
;;;878    
;;;879        OS_CRITICAL_ENTER_CPU_EXIT();
;;;880        ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
;;;881        OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
;;;882                     p_tcb,
;;;883                     ts);
;;;884        OS_CRITICAL_EXIT_NO_SCHED();
;;;885        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;886            OSSched();                                          /* Run the scheduler                                      */
;;;887        }
;;;888       *p_err = OS_ERR_NONE;
;;;889        return (DEF_TRUE);
;;;890    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L6.32|
000020  b11e              CBZ      r6,|L6.42|
000022  f5b64f00          CMP      r6,#0x8000            ;852
000026  d102              BNE      |L6.46|
000028  e000              B        |L6.44|
                  |L6.42|
00002a  bf00              NOP                            ;854
                  |L6.44|
00002c  e004              B        |L6.56|
                  |L6.46|
00002e  f6456025          MOV      r0,#0x5e25            ;858
000032  8020              STRH     r0,[r4,#0]            ;858
000034  2000              MOVS     r0,#0                 ;859
000036  e7f1              B        |L6.28|
                  |L6.56|
000038  bf00              NOP                            ;855
00003a  bf00              NOP                            ;863
00003c  bf00              NOP                            ;863
00003e  f7fffffe          BL       CPU_SR_Save
000042  4607              MOV      r7,r0                 ;863
000044  bf00              NOP                            ;863
000046  bf00              NOP                            ;863
000048  b11d              CBZ      r5,|L6.82|
00004a  481d              LDR      r0,|L6.192|
00004c  6800              LDR      r0,[r0,#0]            ;866  ; OSTCBCurPtr
00004e  4285              CMP      r5,r0                 ;866
000050  d10b              BNE      |L6.106|
                  |L6.82|
000052  bf00              NOP                            ;867
000054  bf00              NOP                            ;867
000056  4638              MOV      r0,r7                 ;867
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;867
00005e  bf00              NOP                            ;867
000060  f24610ac          MOV      r0,#0x61ac            ;868
000064  8020              STRH     r0,[r4,#0]            ;868
000066  2000              MOVS     r0,#0                 ;869
000068  e7d8              B        |L6.28|
                  |L6.106|
00006a  f8950034          LDRB     r0,[r5,#0x34]         ;873
00006e  2802              CMP      r0,#2                 ;873
000070  d00b              BEQ      |L6.138|
000072  bf00              NOP                            ;874
000074  bf00              NOP                            ;874
000076  4638              MOV      r0,r7                 ;874
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;874
00007e  bf00              NOP                            ;874
000080  f24610ab          MOV      r0,#0x61ab            ;875
000084  8020              STRH     r0,[r4,#0]            ;875
000086  2000              MOVS     r0,#0                 ;876
000088  e7c8              B        |L6.28|
                  |L6.138|
00008a  f7fffffe          BL       CPU_TS_TmrRd
00008e  4680              MOV      r8,r0                 ;880
000090  4642              MOV      r2,r8                 ;881
000092  4629              MOV      r1,r5                 ;881
000094  2000              MOVS     r0,#0                 ;881
000096  f7fffffe          BL       OS_PendAbort
00009a  bf00              NOP                            ;884
00009c  bf00              NOP                            ;884
00009e  4638              MOV      r0,r7                 ;884
0000a0  f7fffffe          BL       CPU_SR_Restore
0000a4  bf00              NOP                            ;884
0000a6  bf00              NOP                            ;884
0000a8  f4064000          AND      r0,r6,#0x8000         ;885
0000ac  b908              CBNZ     r0,|L6.178|
0000ae  f7fffffe          BL       OSSched
                  |L6.178|
0000b2  2000              MOVS     r0,#0                 ;888
0000b4  8020              STRH     r0,[r4,#0]            ;888
0000b6  2001              MOVS     r0,#1                 ;889
0000b8  e7b0              B        |L6.28|
;;;891    #endif
                          ENDP

0000ba  0000              DCW      0x0000
                  |L6.188|
                          DCD      OSIntNestingCtr
                  |L6.192|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPost||, CODE, READONLY, ALIGN=1

                  OSTaskQPost PROC
;;;929    #if OS_CFG_TASK_Q_EN > 0u
;;;930    void  OSTaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;931                       void         *p_void,
;;;932                       OS_MSG_SIZE   msg_size,
;;;933                       OS_OPT        opt,
;;;934                       OS_ERR       *p_err)
;;;935    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;936        CPU_TS   ts;
;;;937    
;;;938    
;;;939    
;;;940    #ifdef OS_SAFETY_CRITICAL
;;;941        if (p_err == (OS_ERR *)0) {
;;;942            OS_SAFETY_CRITICAL_EXCEPTION();
;;;943            return;
;;;944        }
;;;945    #endif
;;;946    
;;;947    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;948        switch (opt) {                                          /* User must supply a valid option                        */
00000e  b14c              CBZ      r4,|L7.36|
000010  2c10              CMP      r4,#0x10
000012  d008              BEQ      |L7.38|
000014  f5b44f00          CMP      r4,#0x8000
000018  d006              BEQ      |L7.40|
00001a  f5a44000          SUB      r0,r4,#0x8000
00001e  3810              SUBS     r0,r0,#0x10
000020  b920              CBNZ     r0,|L7.44|
000022  e002              B        |L7.42|
                  |L7.36|
;;;949            case OS_OPT_POST_FIFO:
;;;950            case OS_OPT_POST_LIFO:
000024  bf00              NOP      
                  |L7.38|
;;;951            case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
000026  bf00              NOP      
                  |L7.40|
;;;952            case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
000028  bf00              NOP      
                  |L7.42|
;;;953                 break;
00002a  e004              B        |L7.54|
                  |L7.44|
;;;954    
;;;955            default:
;;;956                *p_err = OS_ERR_OPT_INVALID;
00002c  f6456025          MOV      r0,#0x5e25
000030  8028              STRH     r0,[r5,#0]
                  |L7.50|
;;;957                 return;
;;;958        }
;;;959    #endif
;;;960    
;;;961        ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;962    
;;;963    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;964        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
;;;965            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
;;;966                        (void      *)p_tcb,
;;;967                        (void      *)p_void,
;;;968                        (OS_MSG_SIZE)msg_size,
;;;969                        (OS_FLAGS   )0,
;;;970                        (OS_OPT     )opt,
;;;971                        (CPU_TS     )ts,
;;;972                        (OS_ERR    *)p_err);
;;;973            return;
;;;974        }
;;;975    #endif
;;;976    
;;;977        OS_TaskQPost(p_tcb,
;;;978                     p_void,
;;;979                     msg_size,
;;;980                     opt,
;;;981                     ts,
;;;982                     p_err);
;;;983    }
000032  e8bd87fc          POP      {r2-r10,pc}
                  |L7.54|
000036  bf00              NOP                            ;953
000038  f7fffffe          BL       CPU_TS_TmrRd
00003c  4606              MOV      r6,r0                 ;961
00003e  4623              MOV      r3,r4                 ;977
000040  464a              MOV      r2,r9                 ;977
000042  4641              MOV      r1,r8                 ;977
000044  4638              MOV      r0,r7                 ;977
000046  e9cd6500          STRD     r6,r5,[sp,#0]         ;977
00004a  f7fffffe          BL       OS_TaskQPost
00004e  bf00              NOP      
000050  e7ef              B        |L7.50|
;;;984    #endif
                          ENDP


                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1010   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1011   OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1012                         OS_REG_ID   id,
;;;1013                         OS_ERR     *p_err)
;;;1014   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1015       OS_REG     value;
;;;1016       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1017   
;;;1018   
;;;1019   
;;;1020   #ifdef OS_SAFETY_CRITICAL
;;;1021       if (p_err == (OS_ERR *)0) {
;;;1022           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1023           return ((OS_REG)0);
;;;1024       }
;;;1025   #endif
;;;1026   
;;;1027   #if OS_CFG_ARG_CHK_EN > 0u
;;;1028       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
00000e  b12d              CBZ      r5,|L8.28|
;;;1029          *p_err = OS_ERR_REG_ID_INVALID;
000010  f6461079          MOV      r0,#0x6979
000014  8030              STRH     r0,[r6,#0]
;;;1030           return ((OS_REG)0);
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;1031       }
;;;1032   #endif
;;;1033   
;;;1034       CPU_CRITICAL_ENTER();
;;;1035       if (p_tcb == (OS_TCB *)0) {
;;;1036           p_tcb = OSTCBCurPtr;
;;;1037       }
;;;1038       value = p_tcb->RegTbl[id];
;;;1039       CPU_CRITICAL_EXIT();
;;;1040      *p_err = OS_ERR_NONE;
;;;1041       return ((OS_REG)value);
;;;1042   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  bf00              NOP                            ;1034
00001e  bf00              NOP                            ;1034
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0                 ;1034
000026  bf00              NOP                            ;1034
000028  bf00              NOP                            ;1034
00002a  b90c              CBNZ     r4,|L8.48|
00002c  4808              LDR      r0,|L8.80|
00002e  6804              LDR      r4,[r0,#0]            ;1036  ; OSTCBCurPtr
                  |L8.48|
000030  f104007c          ADD      r0,r4,#0x7c           ;1038
000034  f8507025          LDR      r7,[r0,r5,LSL #2]     ;1038
000038  bf00              NOP                            ;1039
00003a  bf00              NOP                            ;1039
00003c  4640              MOV      r0,r8                 ;1039
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;1039
000044  bf00              NOP                            ;1039
000046  2000              MOVS     r0,#0                 ;1040
000048  8030              STRH     r0,[r6,#0]            ;1040
00004a  4638              MOV      r0,r7                 ;1041
00004c  e7e4              B        |L8.24|
;;;1043   #endif
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1063   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1064   OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;1065   {
000002  4604              MOV      r4,r0
;;;1066       OS_REG_ID  id;
;;;1067       CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;1068   
;;;1069   
;;;1070   
;;;1071   #ifdef OS_SAFETY_CRITICAL
;;;1072       if (p_err == (OS_ERR *)0) {
;;;1073           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1074           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
;;;1075       }
;;;1076   #endif
;;;1077   
;;;1078       CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  bf00              NOP      
;;;1079       if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
000014  480f              LDR      r0,|L9.84|
000016  7800              LDRB     r0,[r0,#0]  ; OSTaskRegNextAvailID
000018  b158              CBZ      r0,|L9.50|
;;;1080          *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
00001a  f64510da          MOV      r0,#0x59da
00001e  8020              STRH     r0,[r4,#0]
;;;1081           CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  bf00              NOP      
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       CPU_SR_Restore
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1082           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
00002e  2001              MOVS     r0,#1
                  |L9.48|
;;;1083       }
;;;1084        
;;;1085       id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
;;;1086       OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
;;;1087       CPU_CRITICAL_EXIT();
;;;1088      *p_err = OS_ERR_NONE;
;;;1089       return (id);
;;;1090   }
000030  bd70              POP      {r4-r6,pc}
                  |L9.50|
000032  4808              LDR      r0,|L9.84|
000034  7805              LDRB     r5,[r0,#0]            ;1085  ; OSTaskRegNextAvailID
000036  7800              LDRB     r0,[r0,#0]            ;1086  ; OSTaskRegNextAvailID
000038  1c40              ADDS     r0,r0,#1              ;1086
00003a  4906              LDR      r1,|L9.84|
00003c  7008              STRB     r0,[r1,#0]            ;1086
00003e  bf00              NOP                            ;1087
000040  bf00              NOP                            ;1087
000042  4630              MOV      r0,r6                 ;1087
000044  f7fffffe          BL       CPU_SR_Restore
000048  bf00              NOP                            ;1087
00004a  bf00              NOP                            ;1087
00004c  2000              MOVS     r0,#0                 ;1088
00004e  8020              STRH     r0,[r4,#0]            ;1088
000050  4628              MOV      r0,r5                 ;1089
000052  e7ed              B        |L9.48|
;;;1091   #endif
                          ENDP

                  |L9.84|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1119   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1120   void  OSTaskRegSet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1121                       OS_REG_ID   id,
;;;1122                       OS_REG      value,
;;;1123                       OS_ERR     *p_err)
;;;1124   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;1125       CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;1126   
;;;1127   
;;;1128   
;;;1129   #ifdef OS_SAFETY_CRITICAL
;;;1130       if (p_err == (OS_ERR *)0) {
;;;1131           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1132           return;
;;;1133       }
;;;1134   #endif
;;;1135   
;;;1136   #if OS_CFG_ARG_CHK_EN > 0u
;;;1137       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
000010  b125              CBZ      r5,|L10.28|
;;;1138          *p_err = OS_ERR_REG_ID_INVALID;
000012  f6461079          MOV      r0,#0x6979
000016  8030              STRH     r0,[r6,#0]
                  |L10.24|
;;;1139           return;
;;;1140       }
;;;1141   #endif
;;;1142   
;;;1143       CPU_CRITICAL_ENTER();
;;;1144       if (p_tcb == (OS_TCB *)0) {
;;;1145           p_tcb = OSTCBCurPtr;
;;;1146       }
;;;1147       p_tcb->RegTbl[id] = value;
;;;1148       CPU_CRITICAL_EXIT();
;;;1149      *p_err             = OS_ERR_NONE;
;;;1150   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L10.28|
00001c  bf00              NOP                            ;1143
00001e  bf00              NOP                            ;1143
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0                 ;1143
000026  bf00              NOP                            ;1143
000028  bf00              NOP                            ;1143
00002a  b90c              CBNZ     r4,|L10.48|
00002c  4808              LDR      r0,|L10.80|
00002e  6804              LDR      r4,[r0,#0]            ;1145  ; OSTCBCurPtr
                  |L10.48|
000030  f104007c          ADD      r0,r4,#0x7c           ;1147
000034  f8407025          STR      r7,[r0,r5,LSL #2]     ;1147
000038  bf00              NOP                            ;1148
00003a  bf00              NOP                            ;1148
00003c  4640              MOV      r0,r8                 ;1148
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;1148
000044  bf00              NOP                            ;1148
000046  2000              MOVS     r0,#0                 ;1149
000048  8030              STRH     r0,[r6,#0]            ;1149
00004a  bf00              NOP      
00004c  e7e4              B        |L10.24|
;;;1151   #endif
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;1175   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1176   void  OSTaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1177                       OS_ERR  *p_err)
;;;1178   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1179       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;1180   
;;;1181   
;;;1182   
;;;1183   #ifdef OS_SAFETY_CRITICAL
;;;1184       if (p_err == (OS_ERR *)0) {
;;;1185           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1186           return;
;;;1187       }
;;;1188   #endif
;;;1189   
;;;1190   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1191       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1192       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000008  4815              LDR      r0,|L11.96|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L11.24|
;;;1193          *p_err = OS_ERR_TASK_RESUME_ISR;
000010  f2471055          MOV      r0,#0x7155
000014  8028              STRH     r0,[r5,#0]
                  |L11.22|
;;;1194           return;
;;;1195       }
;;;1196   #endif
;;;1197   
;;;1198   
;;;1199       CPU_CRITICAL_ENTER();
;;;1200   #if OS_CFG_ARG_CHK_EN > 0u
;;;1201       if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
;;;1202           (p_tcb == OSTCBCurPtr)) {
;;;1203           CPU_CRITICAL_EXIT();
;;;1204          *p_err  = OS_ERR_TASK_RESUME_SELF;
;;;1205           return;
;;;1206       }
;;;1207   #endif
;;;1208       CPU_CRITICAL_EXIT();
;;;1209   
;;;1210   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1211       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1212           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
;;;1213                       (void      *)p_tcb,
;;;1214                       (void      *)0,
;;;1215                       (OS_MSG_SIZE)0,
;;;1216                       (OS_FLAGS   )0,
;;;1217                       (OS_OPT     )0,
;;;1218                       (CPU_TS     )0,
;;;1219                       (OS_ERR    *)p_err);
;;;1220           return;
;;;1221       }
;;;1222   #endif
;;;1223   
;;;1224       OS_TaskResume(p_tcb, p_err);
;;;1225   }
000016  bd70              POP      {r4-r6,pc}
                  |L11.24|
000018  bf00              NOP                            ;1199
00001a  bf00              NOP                            ;1199
00001c  f7fffffe          BL       CPU_SR_Save
000020  4606              MOV      r6,r0                 ;1199
000022  bf00              NOP                            ;1199
000024  bf00              NOP                            ;1199
000026  b11c              CBZ      r4,|L11.48|
000028  480e              LDR      r0,|L11.100|
00002a  6800              LDR      r0,[r0,#0]            ;1202  ; OSTCBCurPtr
00002c  4284              CMP      r4,r0                 ;1202
00002e  d10a              BNE      |L11.70|
                  |L11.48|
000030  bf00              NOP                            ;1203
000032  bf00              NOP                            ;1203
000034  4630              MOV      r0,r6                 ;1203
000036  f7fffffe          BL       CPU_SR_Restore
00003a  bf00              NOP                            ;1203
00003c  bf00              NOP                            ;1203
00003e  f2471057          MOV      r0,#0x7157            ;1204
000042  8028              STRH     r0,[r5,#0]            ;1204
000044  e7e7              B        |L11.22|
                  |L11.70|
000046  bf00              NOP                            ;1208
000048  bf00              NOP                            ;1208
00004a  4630              MOV      r0,r6                 ;1208
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP                            ;1208
000052  bf00              NOP                            ;1208
000054  4629              MOV      r1,r5                 ;1224
000056  4620              MOV      r0,r4                 ;1224
000058  f7fffffe          BL       OS_TaskResume
00005c  bf00              NOP      
00005e  e7da              B        |L11.22|
;;;1226   #endif
                          ENDP

                  |L11.96|
                          DCD      OSIntNestingCtr
                  |L11.100|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPend||, CODE, READONLY, ALIGN=2

                  OSTaskSemPend PROC
;;;1261   
;;;1262   OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1263                              OS_OPT    opt,
;;;1264                              CPU_TS   *p_ts,
;;;1265                              OS_ERR   *p_err)
;;;1266   {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1267       OS_SEM_CTR    ctr;
;;;1268       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;1269   
;;;1270   
;;;1271   
;;;1272   #ifdef OS_SAFETY_CRITICAL
;;;1273       if (p_err == (OS_ERR *)0) {
;;;1274           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1275           return ((OS_SEM_CTR)0);
;;;1276       }
;;;1277   #endif
;;;1278   
;;;1279   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1280       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000010  486f              LDR      r0,|L12.464|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  2800              CMP      r0,#0
000016  dd05              BLE      |L12.36|
;;;1281          *p_err = OS_ERR_PEND_ISR;
000018  f24610ae          MOV      r0,#0x61ae
00001c  8028              STRH     r0,[r5,#0]
;;;1282           return ((OS_SEM_CTR)0);
00001e  2000              MOVS     r0,#0
                  |L12.32|
;;;1283       }
;;;1284   #endif
;;;1285   
;;;1286   #if OS_CFG_ARG_CHK_EN > 0u
;;;1287       switch (opt) {                                          /* Validate 'opt'                                         */
;;;1288           case OS_OPT_PEND_BLOCKING:
;;;1289           case OS_OPT_PEND_NON_BLOCKING:
;;;1290                break;
;;;1291   
;;;1292           default:
;;;1293               *p_err = OS_ERR_OPT_INVALID;
;;;1294                return ((OS_SEM_CTR)0);
;;;1295       }
;;;1296   #endif
;;;1297   
;;;1298       if (p_ts != (CPU_TS *)0) {
;;;1299          *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;1300       }
;;;1301   
;;;1302       CPU_CRITICAL_ENTER();
;;;1303       if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
;;;1304           OSTCBCurPtr->SemCtr--;
;;;1305           ctr    = OSTCBCurPtr->SemCtr;
;;;1306           if (p_ts != (CPU_TS *)0) {
;;;1307              *p_ts  = OSTCBCurPtr->TS;
;;;1308           }
;;;1309   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1310           OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1311           if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1312               OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1313           }
;;;1314   #endif
;;;1315           CPU_CRITICAL_EXIT();
;;;1316          *p_err = OS_ERR_NONE;
;;;1317           return (ctr);
;;;1318       }
;;;1319   
;;;1320       if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;1321           CPU_CRITICAL_EXIT();
;;;1322          *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;1323           return ((OS_SEM_CTR)0);
;;;1324       } else {                                                /* Yes                                                    */
;;;1325           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;1326               CPU_CRITICAL_EXIT();
;;;1327              *p_err = OS_ERR_SCHED_LOCKED;
;;;1328               return ((OS_SEM_CTR)0);
;;;1329           }
;;;1330       }
;;;1331                                                               /* Lock the scheduler/re-enable interrupts                */
;;;1332       OS_CRITICAL_ENTER_CPU_EXIT();                           
;;;1333       OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
;;;1334               (OS_PEND_OBJ  *)0,
;;;1335               (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
;;;1336               (OS_TICK       )timeout);
;;;1337       OS_CRITICAL_EXIT_NO_SCHED();
;;;1338   
;;;1339       OSSched();                                              /* Find next highest priority task ready to run           */
;;;1340   
;;;1341       CPU_CRITICAL_ENTER();
;;;1342       switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
;;;1343           case OS_STATUS_PEND_OK:
;;;1344                if (p_ts != (CPU_TS *)0) {
;;;1345                   *p_ts                    =  OSTCBCurPtr->TS;
;;;1346   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1347                   OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1348                   if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1349                       OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1350                   }
;;;1351   #endif
;;;1352                }
;;;1353               *p_err = OS_ERR_NONE;
;;;1354                break;
;;;1355   
;;;1356           case OS_STATUS_PEND_ABORT:
;;;1357                if (p_ts != (CPU_TS *)0) {
;;;1358                   *p_ts  =  OSTCBCurPtr->TS;
;;;1359                }
;;;1360               *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
;;;1361                break;
;;;1362   
;;;1363           case OS_STATUS_PEND_TIMEOUT:
;;;1364                if (p_ts != (CPU_TS *)0) {
;;;1365                   *p_ts  = (CPU_TS  )0;
;;;1366                }
;;;1367               *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
;;;1368                break;
;;;1369   
;;;1370           default:
;;;1371               *p_err = OS_ERR_STATUS_INVALID;
;;;1372                break;
;;;1373       }
;;;1374       ctr = OSTCBCurPtr->SemCtr;
;;;1375       CPU_CRITICAL_EXIT();
;;;1376       return (ctr);
;;;1377   }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L12.36|
000024  b11e              CBZ      r6,|L12.46|
000026  f5b64f00          CMP      r6,#0x8000            ;1287
00002a  d102              BNE      |L12.50|
00002c  e000              B        |L12.48|
                  |L12.46|
00002e  bf00              NOP                            ;1289
                  |L12.48|
000030  e004              B        |L12.60|
                  |L12.50|
000032  f6456025          MOV      r0,#0x5e25            ;1293
000036  8028              STRH     r0,[r5,#0]            ;1293
000038  2000              MOVS     r0,#0                 ;1294
00003a  e7f1              B        |L12.32|
                  |L12.60|
00003c  bf00              NOP                            ;1290
00003e  b10c              CBZ      r4,|L12.68|
000040  2000              MOVS     r0,#0                 ;1299
000042  6020              STR      r0,[r4,#0]            ;1299
                  |L12.68|
000044  bf00              NOP                            ;1302
000046  bf00              NOP                            ;1302
000048  f7fffffe          BL       CPU_SR_Save
00004c  4681              MOV      r9,r0                 ;1302
00004e  bf00              NOP                            ;1302
000050  bf00              NOP                            ;1302
000052  4860              LDR      r0,|L12.468|
000054  6800              LDR      r0,[r0,#0]            ;1303  ; OSTCBCurPtr
000056  6c40              LDR      r0,[r0,#0x44]         ;1303
000058  b3a8              CBZ      r0,|L12.198|
00005a  485e              LDR      r0,|L12.468|
00005c  6800              LDR      r0,[r0,#0]            ;1304  ; OSTCBCurPtr
00005e  6c40              LDR      r0,[r0,#0x44]         ;1304
000060  1e40              SUBS     r0,r0,#1              ;1304
000062  495c              LDR      r1,|L12.468|
000064  6809              LDR      r1,[r1,#0]            ;1304  ; OSTCBCurPtr
000066  6448              STR      r0,[r1,#0x44]         ;1304
000068  485a              LDR      r0,|L12.468|
00006a  6800              LDR      r0,[r0,#0]            ;1305  ; OSTCBCurPtr
00006c  6c47              LDR      r7,[r0,#0x44]         ;1305
00006e  b11c              CBZ      r4,|L12.120|
000070  4858              LDR      r0,|L12.468|
000072  6800              LDR      r0,[r0,#0]            ;1307  ; OSTCBCurPtr
000074  6c00              LDR      r0,[r0,#0x40]         ;1307
000076  6020              STR      r0,[r4,#0]            ;1307
                  |L12.120|
000078  f7fffffe          BL       CPU_TS_TmrRd
00007c  4955              LDR      r1,|L12.468|
00007e  6809              LDR      r1,[r1,#0]            ;1310  ; OSTCBCurPtr
000080  6c09              LDR      r1,[r1,#0x40]         ;1310
000082  1a40              SUBS     r0,r0,r1              ;1310
000084  4953              LDR      r1,|L12.468|
000086  6809              LDR      r1,[r1,#0]            ;1310  ; OSTCBCurPtr
000088  f8c100a4          STR      r0,[r1,#0xa4]         ;1310
00008c  4851              LDR      r0,|L12.468|
00008e  6800              LDR      r0,[r0,#0]            ;1311  ; OSTCBCurPtr
000090  f8d000a8          LDR      r0,[r0,#0xa8]         ;1311
000094  494f              LDR      r1,|L12.468|
000096  6809              LDR      r1,[r1,#0]            ;1311  ; OSTCBCurPtr
000098  f8d110a4          LDR      r1,[r1,#0xa4]         ;1311
00009c  4288              CMP      r0,r1                 ;1311
00009e  d207              BCS      |L12.176|
0000a0  484c              LDR      r0,|L12.468|
0000a2  6800              LDR      r0,[r0,#0]            ;1312  ; OSTCBCurPtr
0000a4  f8d000a4          LDR      r0,[r0,#0xa4]         ;1312
0000a8  494a              LDR      r1,|L12.468|
0000aa  6809              LDR      r1,[r1,#0]            ;1312  ; OSTCBCurPtr
0000ac  f8c100a8          STR      r0,[r1,#0xa8]         ;1312
                  |L12.176|
0000b0  bf00              NOP                            ;1315
0000b2  bf00              NOP                            ;1315
0000b4  4648              MOV      r0,r9                 ;1315
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP                            ;1315
0000bc  bf00              NOP                            ;1315
0000be  2000              MOVS     r0,#0                 ;1316
0000c0  8028              STRH     r0,[r5,#0]            ;1316
0000c2  4638              MOV      r0,r7                 ;1317
0000c4  e7ac              B        |L12.32|
                  |L12.198|
0000c6  e7ff              B        |L12.200|
                  |L12.200|
0000c8  f4064000          AND      r0,r6,#0x8000         ;1320
0000cc  b158              CBZ      r0,|L12.230|
0000ce  bf00              NOP                            ;1321
0000d0  bf00              NOP                            ;1321
0000d2  4648              MOV      r0,r9                 ;1321
0000d4  f7fffffe          BL       CPU_SR_Restore
0000d8  bf00              NOP                            ;1321
0000da  bf00              NOP                            ;1321
0000dc  f24610b0          MOV      r0,#0x61b0            ;1322
0000e0  8028              STRH     r0,[r5,#0]            ;1322
0000e2  2000              MOVS     r0,#0                 ;1323
0000e4  e79c              B        |L12.32|
                  |L12.230|
0000e6  483c              LDR      r0,|L12.472|
0000e8  7800              LDRB     r0,[r0,#0]            ;1325  ; OSSchedLockNestingCtr
0000ea  2800              CMP      r0,#0                 ;1325
0000ec  dd0b              BLE      |L12.262|
0000ee  bf00              NOP                            ;1326
0000f0  bf00              NOP                            ;1326
0000f2  4648              MOV      r0,r9                 ;1326
0000f4  f7fffffe          BL       CPU_SR_Restore
0000f8  bf00              NOP                            ;1326
0000fa  bf00              NOP                            ;1326
0000fc  f6465063          MOV      r0,#0x6d63            ;1327
000100  8028              STRH     r0,[r5,#0]            ;1327
000102  2000              MOVS     r0,#0                 ;1328
000104  e78c              B        |L12.32|
                  |L12.262|
000106  4643              MOV      r3,r8                 ;1333
000108  2207              MOVS     r2,#7                 ;1333
00010a  2100              MOVS     r1,#0                 ;1333
00010c  4608              MOV      r0,r1                 ;1333
00010e  f7fffffe          BL       OS_Pend
000112  bf00              NOP                            ;1337
000114  bf00              NOP                            ;1337
000116  4648              MOV      r0,r9                 ;1337
000118  f7fffffe          BL       CPU_SR_Restore
00011c  bf00              NOP                            ;1337
00011e  bf00              NOP                            ;1337
000120  f7fffffe          BL       OSSched
000124  bf00              NOP                            ;1341
000126  bf00              NOP                            ;1341
000128  f7fffffe          BL       CPU_SR_Save
00012c  4681              MOV      r9,r0                 ;1341
00012e  bf00              NOP                            ;1341
000130  bf00              NOP                            ;1341
000132  4828              LDR      r0,|L12.468|
000134  6800              LDR      r0,[r0,#0]            ;1342  ; OSTCBCurPtr
000136  f8900035          LDRB     r0,[r0,#0x35]         ;1342
00013a  b120              CBZ      r0,|L12.326|
00013c  2801              CMP      r0,#1                 ;1342
00013e  d026              BEQ      |L12.398|
000140  2803              CMP      r0,#3                 ;1342
000142  d134              BNE      |L12.430|
000144  e02c              B        |L12.416|
                  |L12.326|
000146  b1fc              CBZ      r4,|L12.392|
000148  4822              LDR      r0,|L12.468|
00014a  6800              LDR      r0,[r0,#0]            ;1345  ; OSTCBCurPtr
00014c  6c00              LDR      r0,[r0,#0x40]         ;1345
00014e  6020              STR      r0,[r4,#0]            ;1345
000150  f7fffffe          BL       CPU_TS_TmrRd
000154  491f              LDR      r1,|L12.468|
000156  6809              LDR      r1,[r1,#0]            ;1347  ; OSTCBCurPtr
000158  6c09              LDR      r1,[r1,#0x40]         ;1347
00015a  1a40              SUBS     r0,r0,r1              ;1347
00015c  491d              LDR      r1,|L12.468|
00015e  6809              LDR      r1,[r1,#0]            ;1347  ; OSTCBCurPtr
000160  f8c100a4          STR      r0,[r1,#0xa4]         ;1347
000164  481b              LDR      r0,|L12.468|
000166  6800              LDR      r0,[r0,#0]            ;1348  ; OSTCBCurPtr
000168  f8d000a8          LDR      r0,[r0,#0xa8]         ;1348
00016c  4919              LDR      r1,|L12.468|
00016e  6809              LDR      r1,[r1,#0]            ;1348  ; OSTCBCurPtr
000170  f8d110a4          LDR      r1,[r1,#0xa4]         ;1348
000174  4288              CMP      r0,r1                 ;1348
000176  d207              BCS      |L12.392|
000178  4816              LDR      r0,|L12.468|
00017a  6800              LDR      r0,[r0,#0]            ;1349  ; OSTCBCurPtr
00017c  f8d000a4          LDR      r0,[r0,#0xa4]         ;1349
000180  4914              LDR      r1,|L12.468|
000182  6809              LDR      r1,[r1,#0]            ;1349  ; OSTCBCurPtr
000184  f8c100a8          STR      r0,[r1,#0xa8]         ;1349
                  |L12.392|
000188  2000              MOVS     r0,#0                 ;1353
00018a  8028              STRH     r0,[r5,#0]            ;1353
00018c  e013              B        |L12.438|
                  |L12.398|
00018e  b11c              CBZ      r4,|L12.408|
000190  4810              LDR      r0,|L12.468|
000192  6800              LDR      r0,[r0,#0]            ;1358  ; OSTCBCurPtr
000194  6c00              LDR      r0,[r0,#0x40]         ;1358
000196  6020              STR      r0,[r4,#0]            ;1358
                  |L12.408|
000198  f24610a9          MOV      r0,#0x61a9            ;1360
00019c  8028              STRH     r0,[r5,#0]            ;1360
00019e  e00a              B        |L12.438|
                  |L12.416|
0001a0  b10c              CBZ      r4,|L12.422|
0001a2  2000              MOVS     r0,#0                 ;1365
0001a4  6020              STR      r0,[r4,#0]            ;1365
                  |L12.422|
0001a6  f24720d9          MOV      r0,#0x72d9            ;1367
0001aa  8028              STRH     r0,[r5,#0]            ;1367
0001ac  e003              B        |L12.438|
                  |L12.430|
0001ae  f646602e          MOV      r0,#0x6e2e            ;1371
0001b2  8028              STRH     r0,[r5,#0]            ;1371
0001b4  bf00              NOP                            ;1372
                  |L12.438|
0001b6  bf00              NOP                            ;1354
0001b8  4806              LDR      r0,|L12.468|
0001ba  6800              LDR      r0,[r0,#0]            ;1374  ; OSTCBCurPtr
0001bc  6c47              LDR      r7,[r0,#0x44]         ;1374
0001be  bf00              NOP                            ;1375
0001c0  bf00              NOP                            ;1375
0001c2  4648              MOV      r0,r9                 ;1375
0001c4  f7fffffe          BL       CPU_SR_Restore
0001c8  bf00              NOP                            ;1375
0001ca  bf00              NOP                            ;1375
0001cc  4638              MOV      r0,r7                 ;1376
0001ce  e727              B        |L12.32|
;;;1378   
                          ENDP

                  |L12.464|
                          DCD      OSIntNestingCtr
                  |L12.468|
                          DCD      OSTCBCurPtr
                  |L12.472|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskSemPendAbort PROC
;;;1408   #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
;;;1409   CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1410                                    OS_OPT   opt,
;;;1411                                    OS_ERR  *p_err)
;;;1412   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1413       CPU_TS         ts;
;;;1414       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1415   
;;;1416   
;;;1417   
;;;1418   #ifdef OS_SAFETY_CRITICAL
;;;1419       if (p_err == (OS_ERR *)0) {
;;;1420           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1421           return (DEF_FALSE);
;;;1422       }
;;;1423   #endif
;;;1424   
;;;1425   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1426       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
00000c  4832              LDR      r0,|L13.216|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  2800              CMP      r0,#0
000012  dd05              BLE      |L13.32|
;;;1427          *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
000014  f24610aa          MOV      r0,#0x61aa
000018  8020              STRH     r0,[r4,#0]
;;;1428           return (DEF_FALSE);
00001a  2000              MOVS     r0,#0
                  |L13.28|
;;;1429       }
;;;1430   #endif
;;;1431   
;;;1432   #if OS_CFG_ARG_CHK_EN > 0u
;;;1433       switch (opt) {                                          /* Validate 'opt'                                         */
;;;1434           case OS_OPT_POST_NONE:
;;;1435           case OS_OPT_POST_NO_SCHED:
;;;1436                break;
;;;1437   
;;;1438           default:
;;;1439               *p_err =  OS_ERR_OPT_INVALID;
;;;1440                return (DEF_FALSE);
;;;1441       }
;;;1442   #endif
;;;1443   
;;;1444       CPU_CRITICAL_ENTER();
;;;1445       if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
;;;1446           (p_tcb == OSTCBCurPtr)) {
;;;1447           CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
;;;1448          *p_err = OS_ERR_PEND_ABORT_SELF;
;;;1449           return (DEF_FALSE);
;;;1450       }
;;;1451   
;;;1452       if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
;;;1453           CPU_CRITICAL_EXIT();
;;;1454          *p_err = OS_ERR_PEND_ABORT_NONE;
;;;1455           return (DEF_FALSE);
;;;1456       }
;;;1457       CPU_CRITICAL_EXIT();
;;;1458   
;;;1459       OS_CRITICAL_ENTER();
;;;1460       ts = OS_TS_GET();
;;;1461       OS_PendAbort((OS_PEND_OBJ *)0,
;;;1462                    p_tcb,
;;;1463                    ts);
;;;1464       OS_CRITICAL_EXIT_NO_SCHED();
;;;1465       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1466           OSSched();                                          /* Run the scheduler                                      */
;;;1467       }
;;;1468      *p_err = OS_ERR_NONE;
;;;1469       return (DEF_TRUE);
;;;1470   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  b11e              CBZ      r6,|L13.42|
000022  f5b64f00          CMP      r6,#0x8000            ;1433
000026  d102              BNE      |L13.46|
000028  e000              B        |L13.44|
                  |L13.42|
00002a  bf00              NOP                            ;1435
                  |L13.44|
00002c  e004              B        |L13.56|
                  |L13.46|
00002e  f6456025          MOV      r0,#0x5e25            ;1439
000032  8020              STRH     r0,[r4,#0]            ;1439
000034  2000              MOVS     r0,#0                 ;1440
000036  e7f1              B        |L13.28|
                  |L13.56|
000038  bf00              NOP                            ;1436
00003a  bf00              NOP                            ;1444
00003c  bf00              NOP                            ;1444
00003e  f7fffffe          BL       CPU_SR_Save
000042  4607              MOV      r7,r0                 ;1444
000044  bf00              NOP                            ;1444
000046  bf00              NOP                            ;1444
000048  b11d              CBZ      r5,|L13.82|
00004a  4824              LDR      r0,|L13.220|
00004c  6800              LDR      r0,[r0,#0]            ;1446  ; OSTCBCurPtr
00004e  4285              CMP      r5,r0                 ;1446
000050  d10b              BNE      |L13.106|
                  |L13.82|
000052  bf00              NOP                            ;1447
000054  bf00              NOP                            ;1447
000056  4638              MOV      r0,r7                 ;1447
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;1447
00005e  bf00              NOP                            ;1447
000060  f24610ac          MOV      r0,#0x61ac            ;1448
000064  8020              STRH     r0,[r4,#0]            ;1448
000066  2000              MOVS     r0,#0                 ;1449
000068  e7d8              B        |L13.28|
                  |L13.106|
00006a  f8950034          LDRB     r0,[r5,#0x34]         ;1452
00006e  2807              CMP      r0,#7                 ;1452
000070  d00b              BEQ      |L13.138|
000072  bf00              NOP                            ;1453
000074  bf00              NOP                            ;1453
000076  4638              MOV      r0,r7                 ;1453
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;1453
00007e  bf00              NOP                            ;1453
000080  f24610ab          MOV      r0,#0x61ab            ;1454
000084  8020              STRH     r0,[r4,#0]            ;1454
000086  2000              MOVS     r0,#0                 ;1455
000088  e7c8              B        |L13.28|
                  |L13.138|
00008a  bf00              NOP                            ;1457
00008c  bf00              NOP                            ;1457
00008e  4638              MOV      r0,r7                 ;1457
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;1457
000096  bf00              NOP                            ;1457
000098  bf00              NOP                            ;1459
00009a  bf00              NOP                            ;1459
00009c  f7fffffe          BL       CPU_SR_Save
0000a0  4607              MOV      r7,r0                 ;1459
0000a2  bf00              NOP                            ;1459
0000a4  bf00              NOP                            ;1459
0000a6  f7fffffe          BL       CPU_TS_TmrRd
0000aa  4680              MOV      r8,r0                 ;1460
0000ac  4642              MOV      r2,r8                 ;1461
0000ae  4629              MOV      r1,r5                 ;1461
0000b0  2000              MOVS     r0,#0                 ;1461
0000b2  f7fffffe          BL       OS_PendAbort
0000b6  bf00              NOP                            ;1464
0000b8  bf00              NOP                            ;1464
0000ba  4638              MOV      r0,r7                 ;1464
0000bc  f7fffffe          BL       CPU_SR_Restore
0000c0  bf00              NOP                            ;1464
0000c2  bf00              NOP                            ;1464
0000c4  f4064000          AND      r0,r6,#0x8000         ;1465
0000c8  b908              CBNZ     r0,|L13.206|
0000ca  f7fffffe          BL       OSSched
                  |L13.206|
0000ce  2000              MOVS     r0,#0                 ;1468
0000d0  8020              STRH     r0,[r4,#0]            ;1468
0000d2  2001              MOVS     r0,#1                 ;1469
0000d4  e7a2              B        |L13.28|
;;;1471   #endif
                          ENDP

0000d6  0000              DCW      0x0000
                  |L13.216|
                          DCD      OSIntNestingCtr
                  |L13.220|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPost||, CODE, READONLY, ALIGN=1

                  OSTaskSemPost PROC
;;;1496   
;;;1497   OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1498                              OS_OPT   opt,
;;;1499                              OS_ERR  *p_err)
;;;1500   {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;1501       OS_SEM_CTR  ctr;
;;;1502       CPU_TS      ts;
;;;1503   
;;;1504   
;;;1505   
;;;1506   #ifdef OS_SAFETY_CRITICAL
;;;1507       if (p_err == (OS_ERR *)0) {
;;;1508           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1509           return ((OS_SEM_CTR)0);
;;;1510       }
;;;1511   #endif
;;;1512   
;;;1513   #if OS_CFG_ARG_CHK_EN > 0u
;;;1514       switch (opt) {                                          /* Validate 'opt'                                         */
00000a  b11d              CBZ      r5,|L14.20|
00000c  f5b54f00          CMP      r5,#0x8000
000010  d102              BNE      |L14.24|
000012  e000              B        |L14.22|
                  |L14.20|
;;;1515           case OS_OPT_POST_NONE:
;;;1516           case OS_OPT_POST_NO_SCHED:
000014  bf00              NOP      
                  |L14.22|
;;;1517                break;
000016  e005              B        |L14.36|
                  |L14.24|
;;;1518   
;;;1519           default:
;;;1520               *p_err =  OS_ERR_OPT_INVALID;
000018  f6456025          MOV      r0,#0x5e25
00001c  8020              STRH     r0,[r4,#0]
;;;1521                return ((OS_SEM_CTR)0u);
00001e  2000              MOVS     r0,#0
                  |L14.32|
;;;1522       }
;;;1523   #endif
;;;1524   
;;;1525       ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;1526   
;;;1527   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1528       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1529           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
;;;1530                       (void      *)p_tcb,
;;;1531                       (void      *)0,
;;;1532                       (OS_MSG_SIZE)0,
;;;1533                       (OS_FLAGS   )0,
;;;1534                       (OS_OPT     )0,
;;;1535                       (CPU_TS     )ts,
;;;1536                       (OS_ERR    *)p_err);
;;;1537           return ((OS_SEM_CTR)0);
;;;1538       }
;;;1539   #endif
;;;1540   
;;;1541       ctr = OS_TaskSemPost(p_tcb,
;;;1542                            opt,
;;;1543                            ts,
;;;1544                            p_err);
;;;1545   
;;;1546       return (ctr);
;;;1547   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L14.36|
000024  bf00              NOP                            ;1517
000026  f7fffffe          BL       CPU_TS_TmrRd
00002a  4680              MOV      r8,r0                 ;1525
00002c  4623              MOV      r3,r4                 ;1541
00002e  4642              MOV      r2,r8                 ;1541
000030  4629              MOV      r1,r5                 ;1541
000032  4630              MOV      r0,r6                 ;1541
000034  f7fffffe          BL       OS_TaskSemPost
000038  4607              MOV      r7,r0                 ;1541
00003a  4638              MOV      r0,r7                 ;1546
00003c  e7f0              B        |L14.32|
;;;1548   
                          ENDP


                          AREA ||i.OSTaskSemSet||, CODE, READONLY, ALIGN=2

                  OSTaskSemSet PROC
;;;1569   
;;;1570   OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1571                             OS_SEM_CTR   cnt,
;;;1572                             OS_ERR      *p_err)
;;;1573   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1574       OS_SEM_CTR  ctr;
;;;1575       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1576   
;;;1577   
;;;1578   
;;;1579   #ifdef OS_SAFETY_CRITICAL
;;;1580       if (p_err == (OS_ERR *)0) {
;;;1581           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1582           return ((OS_SEM_CTR)0);
;;;1583       }
;;;1584   #endif
;;;1585   
;;;1586   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1587       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
00000e  4810              LDR      r0,|L15.80|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  2800              CMP      r0,#0
000014  dd05              BLE      |L15.34|
;;;1588          *p_err = OS_ERR_SET_ISR;
000016  f64650c6          MOV      r0,#0x6dc6
00001a  8028              STRH     r0,[r5,#0]
;;;1589           return ((OS_SEM_CTR)0);
00001c  2000              MOVS     r0,#0
                  |L15.30|
;;;1590       }
;;;1591   #endif
;;;1592   
;;;1593       CPU_CRITICAL_ENTER();
;;;1594       if (p_tcb == (OS_TCB *)0) {
;;;1595           p_tcb = OSTCBCurPtr;
;;;1596       }
;;;1597       ctr           = p_tcb->SemCtr;
;;;1598       p_tcb->SemCtr = (OS_SEM_CTR)cnt;
;;;1599       CPU_CRITICAL_EXIT();
;;;1600      *p_err         =  OS_ERR_NONE;
;;;1601       return (ctr);
;;;1602   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L15.34|
000022  bf00              NOP                            ;1593
000024  bf00              NOP                            ;1593
000026  f7fffffe          BL       CPU_SR_Save
00002a  4680              MOV      r8,r0                 ;1593
00002c  bf00              NOP                            ;1593
00002e  bf00              NOP                            ;1593
000030  b90c              CBNZ     r4,|L15.54|
000032  4808              LDR      r0,|L15.84|
000034  6804              LDR      r4,[r0,#0]            ;1595  ; OSTCBCurPtr
                  |L15.54|
000036  6c66              LDR      r6,[r4,#0x44]         ;1597
000038  6467              STR      r7,[r4,#0x44]         ;1598
00003a  bf00              NOP                            ;1599
00003c  bf00              NOP                            ;1599
00003e  4640              MOV      r0,r8                 ;1599
000040  f7fffffe          BL       CPU_SR_Restore
000044  bf00              NOP                            ;1599
000046  bf00              NOP                            ;1599
000048  2000              MOVS     r0,#0                 ;1600
00004a  8028              STRH     r0,[r5,#0]            ;1600
00004c  4630              MOV      r0,r6                 ;1601
00004e  e7e6              B        |L15.30|
;;;1603   
                          ENDP

                  |L15.80|
                          DCD      OSIntNestingCtr
                  |L15.84|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;1629   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;1630   void  OSTaskStkChk (OS_TCB        *p_tcb,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1631                       CPU_STK_SIZE  *p_free,
;;;1632                       CPU_STK_SIZE  *p_used,
;;;1633                       OS_ERR        *p_err)
;;;1634   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;1635       CPU_STK_SIZE  free_stk;
;;;1636       CPU_STK      *p_stk;
;;;1637       CPU_SR_ALLOC();
00000c  f04f0a00          MOV      r10,#0
;;;1638   
;;;1639   
;;;1640   
;;;1641   #ifdef OS_SAFETY_CRITICAL
;;;1642       if (p_err == (OS_ERR *)0) {
;;;1643           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1644           return;
;;;1645       }
;;;1646   #endif
;;;1647   
;;;1648   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1649       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
000010  482e              LDR      r0,|L16.204|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  2800              CMP      r0,#0
000016  dd04              BLE      |L16.34|
;;;1650          *p_err = OS_ERR_TASK_STK_CHK_ISR;
000018  f2471059          MOV      r0,#0x7159
00001c  8020              STRH     r0,[r4,#0]
                  |L16.30|
;;;1651           return;
;;;1652       }
;;;1653   #endif
;;;1654   
;;;1655   #if OS_CFG_ARG_CHK_EN > 0u
;;;1656       if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
;;;1657          *p_err  = OS_ERR_PTR_INVALID;
;;;1658           return;
;;;1659       }
;;;1660   
;;;1661       if (p_used == (CPU_STK_SIZE*)0) {
;;;1662          *p_err  = OS_ERR_PTR_INVALID;
;;;1663           return;
;;;1664       }
;;;1665   #endif
;;;1666   
;;;1667       CPU_CRITICAL_ENTER();
;;;1668       if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
;;;1669           p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
;;;1670       }
;;;1671   
;;;1672       if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
;;;1673           CPU_CRITICAL_EXIT();
;;;1674          *p_free = (CPU_STK_SIZE)0;
;;;1675          *p_used = (CPU_STK_SIZE)0;
;;;1676          *p_err  =  OS_ERR_TASK_NOT_EXIST;
;;;1677           return;
;;;1678       }
;;;1679   
;;;1680       if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
;;;1681           CPU_CRITICAL_EXIT();
;;;1682          *p_free = (CPU_STK_SIZE)0;
;;;1683          *p_used = (CPU_STK_SIZE)0;
;;;1684          *p_err  =  OS_ERR_TASK_OPT;
;;;1685           return;
;;;1686       }
;;;1687       CPU_CRITICAL_EXIT();
;;;1688   
;;;1689       free_stk  = 0u;
;;;1690   #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
;;;1691       p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
;;;1692       while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
;;;1693           p_stk++;
;;;1694           free_stk++;
;;;1695       }
;;;1696   #else
;;;1697       p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
;;;1698       while (*p_stk == (CPU_STK)0) {
;;;1699           free_stk++;
;;;1700           p_stk--;
;;;1701       }
;;;1702   #endif
;;;1703      *p_free = free_stk;
;;;1704      *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
;;;1705      *p_err  = OS_ERR_NONE;
;;;1706   }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L16.34|
000022  b91e              CBNZ     r6,|L16.44|
000024  f24620d5          MOV      r0,#0x62d5            ;1657
000028  8020              STRH     r0,[r4,#0]            ;1657
00002a  e7f8              B        |L16.30|
                  |L16.44|
00002c  b91f              CBNZ     r7,|L16.54|
00002e  f24620d5          MOV      r0,#0x62d5            ;1662
000032  8020              STRH     r0,[r4,#0]            ;1662
000034  e7f3              B        |L16.30|
                  |L16.54|
000036  bf00              NOP                            ;1667
000038  bf00              NOP                            ;1667
00003a  f7fffffe          BL       CPU_SR_Save
00003e  4682              MOV      r10,r0                ;1667
000040  bf00              NOP                            ;1667
000042  bf00              NOP                            ;1667
000044  b90d              CBNZ     r5,|L16.74|
000046  4822              LDR      r0,|L16.208|
000048  6805              LDR      r5,[r0,#0]            ;1669  ; OSTCBCurPtr
                  |L16.74|
00004a  6828              LDR      r0,[r5,#0]            ;1672
00004c  b968              CBNZ     r0,|L16.106|
00004e  bf00              NOP                            ;1673
000050  bf00              NOP                            ;1673
000052  4650              MOV      r0,r10                ;1673
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;1673
00005a  bf00              NOP                            ;1673
00005c  2000              MOVS     r0,#0                 ;1674
00005e  6030              STR      r0,[r6,#0]            ;1674
000060  6038              STR      r0,[r7,#0]            ;1675
000062  f2471052          MOV      r0,#0x7152            ;1676
000066  8020              STRH     r0,[r4,#0]            ;1676
000068  e7d9              B        |L16.30|
                  |L16.106|
00006a  f895003c          LDRB     r0,[r5,#0x3c]         ;1680
00006e  f0000001          AND      r0,r0,#1              ;1680
000072  b968              CBNZ     r0,|L16.144|
000074  bf00              NOP                            ;1681
000076  bf00              NOP                            ;1681
000078  4650              MOV      r0,r10                ;1681
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  bf00              NOP                            ;1681
000080  bf00              NOP                            ;1681
000082  2000              MOVS     r0,#0                 ;1682
000084  6030              STR      r0,[r6,#0]            ;1682
000086  6038              STR      r0,[r7,#0]            ;1683
000088  f2471054          MOV      r0,#0x7154            ;1684
00008c  8020              STRH     r0,[r4,#0]            ;1684
00008e  e7c6              B        |L16.30|
                  |L16.144|
000090  bf00              NOP                            ;1687
000092  bf00              NOP                            ;1687
000094  4650              MOV      r0,r10                ;1687
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP                            ;1687
00009c  bf00              NOP                            ;1687
00009e  f04f0800          MOV      r8,#0                 ;1689
0000a2  f8d59024          LDR      r9,[r5,#0x24]         ;1691
0000a6  e003              B        |L16.176|
                  |L16.168|
0000a8  f1090904          ADD      r9,r9,#4              ;1693
0000ac  f1080801          ADD      r8,r8,#1              ;1694
                  |L16.176|
0000b0  f8d90000          LDR      r0,[r9,#0]            ;1692
0000b4  2800              CMP      r0,#0                 ;1692
0000b6  d0f7              BEQ      |L16.168|
0000b8  f8c68000          STR      r8,[r6,#0]            ;1703
0000bc  6ba8              LDR      r0,[r5,#0x38]         ;1704
0000be  eba00008          SUB      r0,r0,r8              ;1704
0000c2  6038              STR      r0,[r7,#0]            ;1704
0000c4  2000              MOVS     r0,#0                 ;1705
0000c6  8020              STRH     r0,[r4,#0]            ;1705
0000c8  bf00              NOP      
0000ca  e7a8              B        |L16.30|
;;;1707   #endif
                          ENDP

                  |L16.204|
                          DCD      OSIntNestingCtr
                  |L16.208|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;1737   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1738   void   OSTaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1739                         OS_ERR  *p_err)
;;;1740   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1741   #ifdef OS_SAFETY_CRITICAL
;;;1742       if (p_err == (OS_ERR *)0) {
;;;1743           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1744           return;
;;;1745       }
;;;1746   #endif
;;;1747   
;;;1748   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1749       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1750       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  480a              LDR      r0,|L17.48|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  2800              CMP      r0,#0
00000c  dd03              BLE      |L17.22|
;;;1751          *p_err = OS_ERR_TASK_SUSPEND_ISR;
00000e  f247105d          MOV      r0,#0x715d
000012  8020              STRH     r0,[r4,#0]
                  |L17.20|
;;;1752           return;
;;;1753       }
;;;1754   #endif
;;;1755   
;;;1756       if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
;;;1757          *p_err = OS_ERR_TASK_SUSPEND_IDLE;
;;;1758           return;
;;;1759       }
;;;1760   
;;;1761   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1762       if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
;;;1763          *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
;;;1764           return;
;;;1765       }
;;;1766   
;;;1767       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1768           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
;;;1769                       (void      *)p_tcb,
;;;1770                       (void      *)0,
;;;1771                       (OS_MSG_SIZE)0,
;;;1772                       (OS_FLAGS   )0,
;;;1773                       (OS_OPT     )0,
;;;1774                       (CPU_TS     )0,
;;;1775                       (OS_ERR    *)p_err);
;;;1776           return;
;;;1777       }
;;;1778   #endif
;;;1779   
;;;1780       OS_TaskSuspend(p_tcb, p_err);
;;;1781   }
000014  bd70              POP      {r4-r6,pc}
                  |L17.22|
000016  4807              LDR      r0,|L17.52|
000018  4285              CMP      r5,r0                 ;1756
00001a  d103              BNE      |L17.36|
00001c  f247105b          MOV      r0,#0x715b            ;1757
000020  8020              STRH     r0,[r4,#0]            ;1757
000022  e7f7              B        |L17.20|
                  |L17.36|
000024  4621              MOV      r1,r4                 ;1780
000026  4628              MOV      r0,r5                 ;1780
000028  f7fffffe          BL       OS_TaskSuspend
00002c  bf00              NOP      
00002e  e7f1              B        |L17.20|
;;;1782   #endif
                          ENDP

                  |L17.48|
                          DCD      OSIntNestingCtr
                  |L17.52|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OSTaskTimeQuantaSet||, CODE, READONLY, ALIGN=2

                  OSTaskTimeQuantaSet PROC
;;;1805   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;1806   void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1807                              OS_TICK   time_quanta,
;;;1808                              OS_ERR   *p_err)
;;;1809   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1810       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1811   
;;;1812   
;;;1813   
;;;1814   #ifdef OS_SAFETY_CRITICAL
;;;1815       if (p_err == (OS_ERR *)0) {
;;;1816           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1817           return;
;;;1818       }
;;;1819   #endif
;;;1820   
;;;1821   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1822       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
00000c  4814              LDR      r0,|L18.96|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  2800              CMP      r0,#0
000012  dd04              BLE      |L18.30|
;;;1823          *p_err = OS_ERR_SET_ISR;
000014  f64650c6          MOV      r0,#0x6dc6
000018  8030              STRH     r0,[r6,#0]
                  |L18.26|
;;;1824           return;
;;;1825       }
;;;1826   #endif
;;;1827   
;;;1828       CPU_CRITICAL_ENTER();
;;;1829       if (p_tcb == (OS_TCB *)0) {
;;;1830           p_tcb = OSTCBCurPtr;
;;;1831       }
;;;1832   
;;;1833       if (time_quanta == 0u) {
;;;1834           p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
;;;1835       } else {
;;;1836           p_tcb->TimeQuanta    = time_quanta;
;;;1837       }
;;;1838       if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
;;;1839           p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
;;;1840       }
;;;1841       CPU_CRITICAL_EXIT();
;;;1842      *p_err = OS_ERR_NONE;
;;;1843   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L18.30|
00001e  bf00              NOP                            ;1828
000020  bf00              NOP                            ;1828
000022  f7fffffe          BL       CPU_SR_Save
000026  4607              MOV      r7,r0                 ;1828
000028  bf00              NOP                            ;1828
00002a  bf00              NOP                            ;1828
00002c  b90c              CBNZ     r4,|L18.50|
00002e  480d              LDR      r0,|L18.100|
000030  6804              LDR      r4,[r0,#0]            ;1830  ; OSTCBCurPtr
                  |L18.50|
000032  b91d              CBNZ     r5,|L18.60|
000034  480c              LDR      r0,|L18.104|
000036  6800              LDR      r0,[r0,#0]            ;1834  ; OSSchedRoundRobinDfltTimeQuanta
000038  6560              STR      r0,[r4,#0x54]         ;1834
00003a  e000              B        |L18.62|
                  |L18.60|
00003c  6565              STR      r5,[r4,#0x54]         ;1836
                  |L18.62|
00003e  e9d40115          LDRD     r0,r1,[r4,#0x54]      ;1838
000042  4288              CMP      r0,r1                 ;1838
000044  d901              BLS      |L18.74|
000046  6d60              LDR      r0,[r4,#0x54]         ;1839
000048  65a0              STR      r0,[r4,#0x58]         ;1839
                  |L18.74|
00004a  bf00              NOP                            ;1841
00004c  bf00              NOP                            ;1841
00004e  4638              MOV      r0,r7                 ;1841
000050  f7fffffe          BL       CPU_SR_Restore
000054  bf00              NOP                            ;1841
000056  bf00              NOP                            ;1841
000058  2000              MOVS     r0,#0                 ;1842
00005a  8030              STRH     r0,[r6,#0]            ;1842
00005c  bf00              NOP      
00005e  e7dc              B        |L18.26|
;;;1844   #endif
                          ENDP

                  |L18.96|
                          DCD      OSIntNestingCtr
                  |L18.100|
                          DCD      OSTCBCurPtr
                  |L18.104|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OS_TaskDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListAdd PROC
;;;1861   #if OS_CFG_DBG_EN > 0u
;;;1862   void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
000000  2100              MOVS     r1,#0
;;;1863   {
;;;1864       p_tcb->DbgPrevPtr                = (OS_TCB *)0;
000002  f8c010b4          STR      r1,[r0,#0xb4]
;;;1865       if (OSTaskDbgListPtr == (OS_TCB *)0) {
000006  4909              LDR      r1,|L19.44|
000008  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
00000a  b919              CBNZ     r1,|L19.20|
;;;1866           p_tcb->DbgNextPtr            = (OS_TCB *)0;
00000c  2100              MOVS     r1,#0
00000e  f8c010b8          STR      r1,[r0,#0xb8]
000012  e007              B        |L19.36|
                  |L19.20|
;;;1867       } else {
;;;1868           p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
000014  4905              LDR      r1,|L19.44|
000016  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000018  f8c010b8          STR      r1,[r0,#0xb8]
;;;1869           OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
00001c  4903              LDR      r1,|L19.44|
00001e  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000020  f8c100b4          STR      r0,[r1,#0xb4]
                  |L19.36|
;;;1870       }
;;;1871       OSTaskDbgListPtr                 =  p_tcb;
000024  4901              LDR      r1,|L19.44|
000026  6008              STR      r0,[r1,#0]  ; OSTaskDbgListPtr
;;;1872   }
000028  4770              BX       lr
;;;1873   
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListRemove PROC
;;;1875   
;;;1876   void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
000000  f8d020b4          LDR      r2,[r0,#0xb4]
;;;1877   {
;;;1878       OS_TCB  *p_tcb_next;
;;;1879       OS_TCB  *p_tcb_prev;
;;;1880   
;;;1881   
;;;1882       p_tcb_prev = p_tcb->DbgPrevPtr;
;;;1883       p_tcb_next = p_tcb->DbgNextPtr;
000004  f8d010b8          LDR      r1,[r0,#0xb8]
;;;1884   
;;;1885       if (p_tcb_prev == (OS_TCB *)0) {
000008  b94a              CBNZ     r2,|L20.30|
;;;1886           OSTaskDbgListPtr = p_tcb_next;
00000a  4b0d              LDR      r3,|L20.64|
00000c  6019              STR      r1,[r3,#0]  ; OSTaskDbgListPtr
;;;1887           if (p_tcb_next != (OS_TCB *)0) {
00000e  b111              CBZ      r1,|L20.22|
;;;1888               p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
000010  2300              MOVS     r3,#0
000012  f8c130b4          STR      r3,[r1,#0xb4]
                  |L20.22|
;;;1889           }
;;;1890           p_tcb->DbgNextPtr = (OS_TCB *)0;
000016  2300              MOVS     r3,#0
000018  f8c030b8          STR      r3,[r0,#0xb8]
00001c  e00f              B        |L20.62|
                  |L20.30|
;;;1891   
;;;1892       } else if (p_tcb_next == (OS_TCB *)0) {
00001e  b929              CBNZ     r1,|L20.44|
;;;1893           p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
000020  2300              MOVS     r3,#0
000022  f8c230b8          STR      r3,[r2,#0xb8]
;;;1894           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
000026  f8c030b4          STR      r3,[r0,#0xb4]
00002a  e008              B        |L20.62|
                  |L20.44|
;;;1895   
;;;1896       } else {
;;;1897           p_tcb_prev->DbgNextPtr =  p_tcb_next;
00002c  f8c210b8          STR      r1,[r2,#0xb8]
;;;1898           p_tcb_next->DbgPrevPtr =  p_tcb_prev;
000030  f8c120b4          STR      r2,[r1,#0xb4]
;;;1899           p_tcb->DbgNextPtr      = (OS_TCB *)0;
000034  2300              MOVS     r3,#0
000036  f8c030b8          STR      r3,[r0,#0xb8]
;;;1900           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
00003a  f8c030b4          STR      r3,[r0,#0xb4]
                  |L20.62|
;;;1901       }
;;;1902   }
00003e  4770              BX       lr
;;;1903   #endif
                          ENDP

                  |L20.64|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskInit||, CODE, READONLY, ALIGN=2

                  OS_TaskInit PROC
;;;1922   
;;;1923   void  OS_TaskInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;1924   {
;;;1925   #ifdef OS_SAFETY_CRITICAL
;;;1926       if (p_err == (OS_ERR *)0) {
;;;1927           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1928           return;
;;;1929       }
;;;1930   #endif
;;;1931   
;;;1932   #if OS_CFG_DBG_EN > 0u
;;;1933       OSTaskDbgListPtr = (OS_TCB      *)0;
000002  4a04              LDR      r2,|L21.20|
000004  6011              STR      r1,[r2,#0]  ; OSTaskDbgListPtr
;;;1934   #endif
;;;1935   
;;;1936       OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
000006  4a04              LDR      r2,|L21.24|
000008  8011              STRH     r1,[r2,#0]
;;;1937       OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
00000a  4a04              LDR      r2,|L21.28|
00000c  6011              STR      r1,[r2,#0]  ; OSTaskCtxSwCtr
;;;1938   
;;;1939      *p_err            = OS_ERR_NONE;
00000e  8001              STRH     r1,[r0,#0]
;;;1940   }
000010  4770              BX       lr
;;;1941   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      OSTaskDbgListPtr
                  |L21.24|
                          DCD      OSTaskQty
                  |L21.28|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OS_TaskInitTCB||, CODE, READONLY, ALIGN=2

                  OS_TaskInitTCB PROC
;;;1956   
;;;1957   void  OS_TaskInitTCB (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1958   {
000002  4604              MOV      r4,r0
;;;1959   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1960       OS_REG_ID   reg_id;
;;;1961   #endif
;;;1962   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;1963       OS_TLS_ID   id;
;;;1964   #endif
;;;1965   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1966       CPU_TS      ts;
;;;1967   #endif
;;;1968   
;;;1969   
;;;1970       p_tcb->StkPtr             = (CPU_STK       *)0;
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;1971       p_tcb->StkLimitPtr        = (CPU_STK       *)0;
000008  60a0              STR      r0,[r4,#8]
;;;1972   
;;;1973       p_tcb->ExtPtr             = (void          *)0;
00000a  6060              STR      r0,[r4,#4]
;;;1974   
;;;1975       p_tcb->NextPtr            = (OS_TCB        *)0;
00000c  60e0              STR      r0,[r4,#0xc]
;;;1976       p_tcb->PrevPtr            = (OS_TCB        *)0;
00000e  6120              STR      r0,[r4,#0x10]
;;;1977   
;;;1978       p_tcb->TickNextPtr        = (OS_TCB        *)0;
000010  6160              STR      r0,[r4,#0x14]
;;;1979       p_tcb->TickPrevPtr        = (OS_TCB        *)0;
000012  61a0              STR      r0,[r4,#0x18]
;;;1980       p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
000014  61e0              STR      r0,[r4,#0x1c]
;;;1981   
;;;1982       p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
000016  a029              ADR      r0,|L22.188|
000018  6220              STR      r0,[r4,#0x20]
;;;1983   
;;;1984       p_tcb->StkBasePtr         = (CPU_STK       *)0;
00001a  2000              MOVS     r0,#0
00001c  6260              STR      r0,[r4,#0x24]
;;;1985   
;;;1986       p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
00001e  62a0              STR      r0,[r4,#0x28]
;;;1987       p_tcb->TaskEntryArg       = (void          *)0;
000020  62e0              STR      r0,[r4,#0x2c]
;;;1988   
;;;1989   #if (OS_CFG_PEND_MULTI_EN > 0u)
;;;1990       p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
000022  6320              STR      r0,[r4,#0x30]
;;;1991       p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
000024  87e0              STRH     r0,[r4,#0x3e]
;;;1992   #endif
;;;1993   
;;;1994       p_tcb->TS                 = (CPU_TS         )0u;
000026  6420              STR      r0,[r4,#0x40]
;;;1995   
;;;1996   #if (OS_MSG_EN > 0u)
;;;1997       p_tcb->MsgPtr             = (void          *)0;
000028  65e0              STR      r0,[r4,#0x5c]
;;;1998       p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
00002a  f8a40060          STRH     r0,[r4,#0x60]
;;;1999   #endif
;;;2000   
;;;2001   #if OS_CFG_TASK_Q_EN > 0u
;;;2002       OS_MsgQInit(&p_tcb->MsgQ,
00002e  2100              MOVS     r1,#0
000030  f1040064          ADD      r0,r4,#0x64
000034  f7fffffe          BL       OS_MsgQInit
;;;2003                   (OS_MSG_QTY)0u);
;;;2004   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2005       p_tcb->MsgQPendTime       = (CPU_TS         )0u;
000038  2000              MOVS     r0,#0
00003a  f8440f74          STR      r0,[r4,#0x74]!
;;;2006       p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
00003e  6060              STR      r0,[r4,#4]
;;;2007   #endif
;;;2008   #endif
;;;2009   
;;;2010   #if OS_CFG_FLAG_EN > 0u
;;;2011       p_tcb->FlagsPend          = (OS_FLAGS       )0u;
000040  60e0              STR      r0,[r4,#0xc]
;;;2012       p_tcb->FlagsOpt           = (OS_OPT         )0u;
000042  82a0              STRH     r0,[r4,#0x14]
;;;2013       p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
000044  6120              STR      r0,[r4,#0x10]
000046  3c74              SUBS     r4,r4,#0x74
;;;2014   #endif
;;;2015   
;;;2016   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2017       for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
000048  2500              MOVS     r5,#0
00004a  e006              B        |L22.90|
                  |L22.76|
;;;2018           p_tcb->RegTbl[reg_id] = (OS_REG)0u;
00004c  2100              MOVS     r1,#0
00004e  f104007c          ADD      r0,r4,#0x7c
000052  f8401025          STR      r1,[r0,r5,LSL #2]
000056  1c68              ADDS     r0,r5,#1              ;2017
000058  b2c5              UXTB     r5,r0                 ;2017
                  |L22.90|
00005a  2d00              CMP      r5,#0                 ;2017
00005c  d0f6              BEQ      |L22.76|
;;;2019       }
;;;2020   #endif
;;;2021   
;;;2022   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2023       for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;2024           p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
;;;2025       }
;;;2026   #endif
;;;2027   
;;;2028       p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
00005e  2000              MOVS     r0,#0
000060  3434              ADDS     r4,r4,#0x34
000062  6120              STR      r0,[r4,#0x10]
;;;2029   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2030       p_tcb->SemPendTime        = (CPU_TS         )0u;
000064  6720              STR      r0,[r4,#0x70]
;;;2031       p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
000066  6760              STR      r0,[r4,#0x74]
;;;2032   #endif
;;;2033   
;;;2034       p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
000068  6060              STR      r0,[r4,#4]
;;;2035   
;;;2036   
;;;2037   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2038       p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
00006a  f8840056          STRB     r0,[r4,#0x56]
;;;2039   #endif
;;;2040   
;;;2041   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;2042       p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
00006e  67e0              STR      r0,[r4,#0x7c]
;;;2043       p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
000070  67a0              STR      r0,[r4,#0x78]
;;;2044   #endif
;;;2045   
;;;2046       p_tcb->Opt                = (OS_OPT         )0u;
000072  8120              STRH     r0,[r4,#8]
;;;2047   
;;;2048       p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
000074  f04f4000          MOV      r0,#0x80000000
000078  6160              STR      r0,[r4,#0x14]
;;;2049       p_tcb->TickCtrMatch       = (OS_TICK        )0u;
00007a  2000              MOVS     r0,#0
00007c  61a0              STR      r0,[r4,#0x18]
;;;2050       p_tcb->TickRemain         = (OS_TICK        )0u;
00007e  61e0              STR      r0,[r4,#0x1c]
;;;2051   
;;;2052       p_tcb->TimeQuanta         = (OS_TICK        )0u;
000080  6220              STR      r0,[r4,#0x20]
;;;2053       p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
000082  6260              STR      r0,[r4,#0x24]
;;;2054   
;;;2055   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2056       p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
000084  f8a40058          STRH     r0,[r4,#0x58]
;;;2057       p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
000088  f8a4005a          STRH     r0,[r4,#0x5a]
;;;2058       p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
00008c  65e0              STR      r0,[r4,#0x5c]
;;;2059       p_tcb->CyclesDelta        = (CPU_TS         )0u;
00008e  6620              STR      r0,[r4,#0x60]
;;;2060       ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
000090  f7fffffe          BL       CPU_TS_TmrRd
000094  4606              MOV      r6,r0
;;;2061       p_tcb->CyclesStart        = ts;
000096  6666              STR      r6,[r4,#0x64]
;;;2062       p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
000098  2000              MOVS     r0,#0
00009a  66a0              STR      r0,[r4,#0x68]
;;;2063   #endif
;;;2064   #ifdef CPU_CFG_INT_DIS_MEAS_EN
;;;2065       p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
;;;2066   #endif
;;;2067   #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;2068       p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
;;;2069   #endif
;;;2070   
;;;2071       p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
00009c  7020              STRB     r0,[r4,#0]
;;;2072       p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
00009e  7060              STRB     r0,[r4,#1]
;;;2073       p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
0000a0  70a0              STRB     r0,[r4,#2]
;;;2074   
;;;2075       p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
0000a2  2040              MOVS     r0,#0x40
0000a4  70e0              STRB     r0,[r4,#3]
;;;2076   
;;;2077   #if OS_CFG_DBG_EN > 0u
;;;2078       p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
0000a6  2000              MOVS     r0,#0
0000a8  f8c40080          STR      r0,[r4,#0x80]
;;;2079       p_tcb->DbgNextPtr         = (OS_TCB        *)0;
0000ac  f8c40084          STR      r0,[r4,#0x84]
;;;2080       p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
0000b0  a004              ADR      r0,|L22.196|
0000b2  f8c40088          STR      r0,[r4,#0x88]
0000b6  3c34              SUBS     r4,r4,#0x34
;;;2081   #endif
;;;2082   }
0000b8  bd70              POP      {r4-r6,pc}
;;;2083   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L22.188|
0000bc  3f546173          DCB      "?Task",0
0000c0  6b00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L22.196|
0000c4  2000              DCB      " ",0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.OS_TaskQPost||, CODE, READONLY, ALIGN=2

                  OS_TaskQPost PROC
;;;2126   #if OS_CFG_TASK_Q_EN > 0u
;;;2127   void  OS_TaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2128                       void         *p_void,
;;;2129                       OS_MSG_SIZE   msg_size,
;;;2130                       OS_OPT        opt,
;;;2131                       CPU_TS        ts,
;;;2132                       OS_ERR       *p_err)
;;;2133   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;2134       CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;2135   
;;;2136   
;;;2137   
;;;2138       OS_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4682              MOV      r10,r0
00001e  bf00              NOP      
000020  bf00              NOP      
;;;2139       if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
000022  b90c              CBNZ     r4,|L23.40|
;;;2140           p_tcb = OSTCBCurPtr;
000024  482d              LDR      r0,|L23.220|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L23.40|
;;;2141       }
;;;2142      *p_err  = OS_ERR_NONE;                                   /* Assume we won't have any errors                        */
000028  2000              MOVS     r0,#0
00002a  8028              STRH     r0,[r5,#0]
;;;2143       switch (p_tcb->TaskState) {
00002c  f8940036          LDRB     r0,[r4,#0x36]
000030  2808              CMP      r0,#8
000032  d245              BCS      |L23.192|
000034  e8dff000          TBB      [pc,r0]
000038  04051819          DCB      0x04,0x05,0x18,0x19
00003c  06071a1b          DCB      0x06,0x07,0x1a,0x1b
;;;2144           case OS_TASK_STATE_RDY:
;;;2145           case OS_TASK_STATE_DLY:
000040  bf00              NOP      
;;;2146           case OS_TASK_STATE_SUSPENDED:
000042  bf00              NOP      
;;;2147           case OS_TASK_STATE_DLY_SUSPENDED:
000044  bf00              NOP      
;;;2148                OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
000046  464b              MOV      r3,r9
000048  4642              MOV      r2,r8
00004a  4639              MOV      r1,r7
00004c  f1040064          ADD      r0,r4,#0x64
000050  e9cd6500          STRD     r6,r5,[sp,#0]
000054  f7fffffe          BL       OS_MsgQPut
;;;2149                           p_void,
;;;2150                           msg_size,
;;;2151                           opt,
;;;2152                           ts,
;;;2153                           p_err);
;;;2154                OS_CRITICAL_EXIT();
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  4650              MOV      r0,r10
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP      
000064  bf00              NOP      
;;;2155                break;
000066  e036              B        |L23.214|
;;;2156   
;;;2157           case OS_TASK_STATE_PEND:
;;;2158           case OS_TASK_STATE_PEND_TIMEOUT:
000068  bf00              NOP      
;;;2159           case OS_TASK_STATE_PEND_SUSPENDED:
00006a  bf00              NOP      
;;;2160           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00006c  bf00              NOP      
;;;2161                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
00006e  f8940034          LDRB     r0,[r4,#0x34]
000072  2802              CMP      r0,#2
000074  d113              BNE      |L23.158|
;;;2162                    OS_Post((OS_PEND_OBJ *)0,
000076  4643              MOV      r3,r8
000078  463a              MOV      r2,r7
00007a  4621              MOV      r1,r4
00007c  2000              MOVS     r0,#0
00007e  9600              STR      r6,[sp,#0]
000080  f7fffffe          BL       OS_Post
;;;2163                            p_tcb,
;;;2164                            p_void,
;;;2165                            msg_size,
;;;2166                            ts);
;;;2167                    OS_CRITICAL_EXIT_NO_SCHED();
000084  bf00              NOP      
000086  bf00              NOP      
000088  4650              MOV      r0,r10
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP      
000090  bf00              NOP      
;;;2168                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
000092  f4094000          AND      r0,r9,#0x8000
000096  b990              CBNZ     r0,|L23.190|
;;;2169                        OSSched();                             /* Run the scheduler                                      */
000098  f7fffffe          BL       OSSched
00009c  e00f              B        |L23.190|
                  |L23.158|
;;;2170                    }
;;;2171                } else {
;;;2172                    OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
00009e  464b              MOV      r3,r9
0000a0  4642              MOV      r2,r8
0000a2  4639              MOV      r1,r7
0000a4  f1040064          ADD      r0,r4,#0x64
0000a8  e9cd6500          STRD     r6,r5,[sp,#0]
0000ac  f7fffffe          BL       OS_MsgQPut
;;;2173                               p_void,                         /*      ... Deposit the message in the task's queue       */
;;;2174                               msg_size,
;;;2175                               opt,
;;;2176                               ts,
;;;2177                               p_err);
;;;2178                    OS_CRITICAL_EXIT();
0000b0  bf00              NOP      
0000b2  bf00              NOP      
0000b4  4650              MOV      r0,r10
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L23.190|
;;;2179                }
;;;2180                break;
0000be  e00a              B        |L23.214|
                  |L23.192|
;;;2181   
;;;2182           default:
;;;2183                OS_CRITICAL_EXIT();
0000c0  bf00              NOP      
0000c2  bf00              NOP      
0000c4  4650              MOV      r0,r10
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
;;;2184               *p_err = OS_ERR_STATE_INVALID;
0000ce  f646602d          MOV      r0,#0x6e2d
0000d2  8028              STRH     r0,[r5,#0]
;;;2185                break;
0000d4  bf00              NOP      
                  |L23.214|
0000d6  bf00              NOP                            ;2155
;;;2186       }
;;;2187   }
0000d8  e8bd87fc          POP      {r2-r10,pc}
;;;2188   #endif
                          ENDP

                  |L23.220|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskResume||, CODE, READONLY, ALIGN=1

                  OS_TaskResume PROC
;;;2214   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2215   void  OS_TaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2216                        OS_ERR  *p_err)
;;;2217   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2218       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2219   
;;;2220   
;;;2221       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;2222      *p_err  = OS_ERR_NONE;
000016  2000              MOVS     r0,#0
000018  8028              STRH     r0,[r5,#0]
;;;2223       switch (p_tcb->TaskState) {
00001a  f8940036          LDRB     r0,[r4,#0x36]
00001e  2808              CMP      r0,#8
000020  d25e              BCS      |L24.224|
000022  e8dff000          TBB      [pc,r0]
000026  0405              DCB      0x04,0x05
000028  06071227          DCB      0x06,0x07,0x12,0x27
00002c  394b              DCB      0x39,0x4b
;;;2224           case OS_TASK_STATE_RDY:
;;;2225           case OS_TASK_STATE_DLY:
00002e  bf00              NOP      
;;;2226           case OS_TASK_STATE_PEND:
000030  bf00              NOP      
;;;2227           case OS_TASK_STATE_PEND_TIMEOUT:
000032  bf00              NOP      
;;;2228                CPU_CRITICAL_EXIT();
000034  bf00              NOP      
000036  bf00              NOP      
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP      
000040  bf00              NOP      
;;;2229               *p_err = OS_ERR_TASK_NOT_SUSPENDED;
000042  f2471053          MOV      r0,#0x7153
000046  8028              STRH     r0,[r5,#0]
;;;2230                break;
000048  e055              B        |L24.246|
;;;2231   
;;;2232           case OS_TASK_STATE_SUSPENDED:
;;;2233                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2234                p_tcb->SuspendCtr--;
00004a  f8140f8a          LDRB     r0,[r4,#0x8a]!
00004e  1e40              SUBS     r0,r0,#1
000050  7020              STRB     r0,[r4,#0]
;;;2235                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
000052  f814098a          LDRB     r0,[r4],#-0x8a
000056  b928              CBNZ     r0,|L24.100|
;;;2236                    p_tcb->TaskState = OS_TASK_STATE_RDY;
000058  2000              MOVS     r0,#0
00005a  f8840036          STRB     r0,[r4,#0x36]
;;;2237                    OS_TaskRdy(p_tcb);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       OS_TaskRdy
                  |L24.100|
;;;2238                }
;;;2239                OS_CRITICAL_EXIT_NO_SCHED();
000064  bf00              NOP      
000066  bf00              NOP      
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       CPU_SR_Restore
00006e  bf00              NOP      
000070  bf00              NOP      
;;;2240                break;
000072  e040              B        |L24.246|
;;;2241   
;;;2242           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2243                p_tcb->SuspendCtr--;
000074  f8140f8a          LDRB     r0,[r4,#0x8a]!
000078  1e40              SUBS     r0,r0,#1
00007a  7020              STRB     r0,[r4,#0]
;;;2244                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
00007c  f814098a          LDRB     r0,[r4],#-0x8a
000080  b910              CBNZ     r0,|L24.136|
;;;2245                    p_tcb->TaskState = OS_TASK_STATE_DLY;
000082  2001              MOVS     r0,#1
000084  f8840036          STRB     r0,[r4,#0x36]
                  |L24.136|
;;;2246                }
;;;2247                CPU_CRITICAL_EXIT();
000088  bf00              NOP      
00008a  bf00              NOP      
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP      
000094  bf00              NOP      
;;;2248                break;
000096  e02e              B        |L24.246|
;;;2249   
;;;2250           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2251                p_tcb->SuspendCtr--;
000098  f8140f8a          LDRB     r0,[r4,#0x8a]!
00009c  1e40              SUBS     r0,r0,#1
00009e  7020              STRB     r0,[r4,#0]
;;;2252                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000a0  f814098a          LDRB     r0,[r4],#-0x8a
0000a4  b910              CBNZ     r0,|L24.172|
;;;2253                    p_tcb->TaskState = OS_TASK_STATE_PEND;
0000a6  2002              MOVS     r0,#2
0000a8  f8840036          STRB     r0,[r4,#0x36]
                  |L24.172|
;;;2254                }
;;;2255                CPU_CRITICAL_EXIT();
0000ac  bf00              NOP      
0000ae  bf00              NOP      
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP      
0000b8  bf00              NOP      
;;;2256                break;
0000ba  e01c              B        |L24.246|
;;;2257   
;;;2258           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2259                p_tcb->SuspendCtr--;
0000bc  f8140f8a          LDRB     r0,[r4,#0x8a]!
0000c0  1e40              SUBS     r0,r0,#1
0000c2  7020              STRB     r0,[r4,#0]
;;;2260                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000c4  f814098a          LDRB     r0,[r4],#-0x8a
0000c8  b910              CBNZ     r0,|L24.208|
;;;2261                    p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
0000ca  2003              MOVS     r0,#3
0000cc  f8840036          STRB     r0,[r4,#0x36]
                  |L24.208|
;;;2262                }
;;;2263                CPU_CRITICAL_EXIT();
0000d0  bf00              NOP      
0000d2  bf00              NOP      
0000d4  4630              MOV      r0,r6
0000d6  f7fffffe          BL       CPU_SR_Restore
0000da  bf00              NOP      
0000dc  bf00              NOP      
;;;2264                break;
0000de  e00a              B        |L24.246|
                  |L24.224|
;;;2265   
;;;2266           default:
;;;2267                CPU_CRITICAL_EXIT();
0000e0  bf00              NOP      
0000e2  bf00              NOP      
0000e4  4630              MOV      r0,r6
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  bf00              NOP      
0000ec  bf00              NOP      
;;;2268               *p_err = OS_ERR_STATE_INVALID;
0000ee  f646602d          MOV      r0,#0x6e2d
0000f2  8028              STRH     r0,[r5,#0]
                  |L24.244|
;;;2269                return;
;;;2270       }
;;;2271   
;;;2272       OSSched();
;;;2273   }
0000f4  bd70              POP      {r4-r6,pc}
                  |L24.246|
0000f6  bf00              NOP                            ;2230
0000f8  f7fffffe          BL       OSSched
0000fc  bf00              NOP      
0000fe  e7f9              B        |L24.244|
;;;2274   #endif
                          ENDP


                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;2291   
;;;2292   void  OS_TaskReturn (void)
000000  b508              PUSH     {r3,lr}
;;;2293   {
;;;2294       OS_ERR  err;
;;;2295   
;;;2296   
;;;2297   
;;;2298       OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
000002  4804              LDR      r0,|L25.20|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000006  f7fffffe          BL       OSTaskReturnHook
;;;2299   #if OS_CFG_TASK_DEL_EN > 0u
;;;2300       OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       OSTaskDel
;;;2301                 (OS_ERR *)&err);
;;;2302   #else
;;;2303       for (;;) {
;;;2304           OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
;;;2305                     (OS_OPT  )OS_OPT_TIME_DLY,
;;;2306                     (OS_ERR *)&err);
;;;2307       }
;;;2308   #endif
;;;2309   }
000012  bd08              POP      {r3,pc}
;;;2310   
                          ENDP

                  |L25.20|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSemPost||, CODE, READONLY, ALIGN=2

                  OS_TaskSemPost PROC
;;;2341   
;;;2342   OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2343                               OS_OPT   opt,
;;;2344                               CPU_TS   ts,
;;;2345                               OS_ERR  *p_err)
;;;2346   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;2347       OS_SEM_CTR  ctr;
;;;2348       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;2349   
;;;2350   
;;;2351   
;;;2352       OS_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4681              MOV      r9,r0
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;2353       if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
00001e  b90c              CBNZ     r4,|L26.36|
;;;2354           p_tcb = OSTCBCurPtr;
000020  4867              LDR      r0,|L26.448|
000022  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L26.36|
;;;2355       }
;;;2356       p_tcb->TS = ts;
000024  6427              STR      r7,[r4,#0x40]
;;;2357      *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
000026  2000              MOVS     r0,#0
000028  8028              STRH     r0,[r5,#0]
;;;2358       switch (p_tcb->TaskState) {
00002a  f8940036          LDRB     r0,[r4,#0x36]
00002e  2808              CMP      r0,#8
000030  d276              BCS      |L26.288|
000032  e8dff000          TBB      [pc,r0]
000036  0405              DCB      0x04,0x05
000038  50510607          DCB      0x50,0x51,0x06,0x07
00003c  5253              DCB      0x52,0x53
;;;2359           case OS_TASK_STATE_RDY:
;;;2360           case OS_TASK_STATE_DLY:
00003e  bf00              NOP      
;;;2361           case OS_TASK_STATE_SUSPENDED:
000040  bf00              NOP      
;;;2362           case OS_TASK_STATE_DLY_SUSPENDED:
000042  bf00              NOP      
;;;2363                switch (sizeof(OS_SEM_CTR)) {
000044  2004              MOVS     r0,#4
000046  2801              CMP      r0,#1
000048  d004              BEQ      |L26.84|
00004a  2802              CMP      r0,#2
00004c  d013              BEQ      |L26.118|
00004e  2804              CMP      r0,#4
000050  d133              BNE      |L26.186|
000052  e022              B        |L26.154|
                  |L26.84|
;;;2364                    case 1u:
;;;2365                         if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
000054  6c60              LDR      r0,[r4,#0x44]
000056  28ff              CMP      r0,#0xff
000058  d10c              BNE      |L26.116|
;;;2366                             OS_CRITICAL_EXIT();
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  4648              MOV      r0,r9
000060  f7fffffe          BL       CPU_SR_Restore
000064  bf00              NOP      
000066  bf00              NOP      
;;;2367                            *p_err = OS_ERR_SEM_OVF;
000068  f64650c5          MOV      r0,#0x6dc5
00006c  8028              STRH     r0,[r5,#0]
;;;2368                             return ((OS_SEM_CTR)0);
00006e  2000              MOVS     r0,#0
                  |L26.112|
;;;2369                         }
;;;2370                         break;
;;;2371   
;;;2372                    case 2u:
;;;2373                         if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2374                             OS_CRITICAL_EXIT();
;;;2375                            *p_err = OS_ERR_SEM_OVF;
;;;2376                             return ((OS_SEM_CTR)0);
;;;2377                         }
;;;2378                         break;
;;;2379   
;;;2380                    case 4u:
;;;2381                         if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2382                             OS_CRITICAL_EXIT();
;;;2383                            *p_err = OS_ERR_SEM_OVF;
;;;2384                             return ((OS_SEM_CTR)0);
;;;2385                         }
;;;2386                         break;
;;;2387   
;;;2388                    default:
;;;2389                         break;
;;;2390                }
;;;2391                p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
;;;2392                ctr = p_tcb->SemCtr;
;;;2393                OS_CRITICAL_EXIT();
;;;2394                break;
;;;2395   
;;;2396           case OS_TASK_STATE_PEND:
;;;2397           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2398           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2399           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2400                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
;;;2401                    OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
;;;2402                            (OS_TCB      *)p_tcb,
;;;2403                            (void        *)0,
;;;2404                            (OS_MSG_SIZE  )0u,
;;;2405                            (CPU_TS       )ts);
;;;2406                    ctr = p_tcb->SemCtr;
;;;2407                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2408                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;2409                        OSSched();                                 /* Run the scheduler                                  */
;;;2410                    }
;;;2411                } else {
;;;2412                    switch (sizeof(OS_SEM_CTR)) {
;;;2413                        case 1u:
;;;2414                             if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2415                                 OS_CRITICAL_EXIT();
;;;2416                                *p_err = OS_ERR_SEM_OVF;
;;;2417                                 return ((OS_SEM_CTR)0);
;;;2418                             }
;;;2419                             break;
;;;2420   
;;;2421                        case 2u:
;;;2422                             if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2423                                 OS_CRITICAL_EXIT();
;;;2424                                *p_err = OS_ERR_SEM_OVF;
;;;2425                                 return ((OS_SEM_CTR)0);
;;;2426                             }
;;;2427                             break;
;;;2428   
;;;2429                        case 4u:
;;;2430                             if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2431                                 OS_CRITICAL_EXIT();
;;;2432                                *p_err = OS_ERR_SEM_OVF;
;;;2433                                 return ((OS_SEM_CTR)0);
;;;2434                             }
;;;2435                             break;
;;;2436   
;;;2437                        default:
;;;2438                             break;
;;;2439                    }
;;;2440                    p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
;;;2441                    ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
;;;2442                    OS_CRITICAL_EXIT();
;;;2443                }
;;;2444                break;
;;;2445   
;;;2446           default:
;;;2447                OS_CRITICAL_EXIT();
;;;2448               *p_err = OS_ERR_STATE_INVALID;
;;;2449                ctr   = (OS_SEM_CTR)0;
;;;2450                break;
;;;2451       }
;;;2452       return (ctr);
;;;2453   }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L26.116|
000074  e022              B        |L26.188|
                  |L26.118|
000076  f64f71ff          MOV      r1,#0xffff            ;2373
00007a  6c60              LDR      r0,[r4,#0x44]         ;2373
00007c  4288              CMP      r0,r1                 ;2373
00007e  d10b              BNE      |L26.152|
000080  bf00              NOP                            ;2374
000082  bf00              NOP                            ;2374
000084  4648              MOV      r0,r9                 ;2374
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;2374
00008c  bf00              NOP                            ;2374
00008e  f64650c5          MOV      r0,#0x6dc5            ;2375
000092  8028              STRH     r0,[r5,#0]            ;2375
000094  2000              MOVS     r0,#0                 ;2376
000096  e7eb              B        |L26.112|
                  |L26.152|
000098  e010              B        |L26.188|
                  |L26.154|
00009a  6c60              LDR      r0,[r4,#0x44]         ;2381
00009c  1c40              ADDS     r0,r0,#1              ;2381
00009e  b958              CBNZ     r0,|L26.184|
0000a0  bf00              NOP                            ;2382
0000a2  bf00              NOP                            ;2382
0000a4  4648              MOV      r0,r9                 ;2382
0000a6  f7fffffe          BL       CPU_SR_Restore
0000aa  bf00              NOP                            ;2382
0000ac  bf00              NOP                            ;2382
0000ae  f64650c5          MOV      r0,#0x6dc5            ;2383
0000b2  8028              STRH     r0,[r5,#0]            ;2383
0000b4  2000              MOVS     r0,#0                 ;2384
0000b6  e7db              B        |L26.112|
                  |L26.184|
0000b8  e000              B        |L26.188|
                  |L26.186|
0000ba  bf00              NOP                            ;2389
                  |L26.188|
0000bc  bf00              NOP                            ;2370
0000be  6c60              LDR      r0,[r4,#0x44]         ;2391
0000c0  1c40              ADDS     r0,r0,#1              ;2391
0000c2  6460              STR      r0,[r4,#0x44]         ;2391
0000c4  6c66              LDR      r6,[r4,#0x44]         ;2392
0000c6  bf00              NOP                            ;2393
0000c8  bf00              NOP                            ;2393
0000ca  4648              MOV      r0,r9                 ;2393
0000cc  f7fffffe          BL       CPU_SR_Restore
0000d0  bf00              NOP                            ;2393
0000d2  bf00              NOP                            ;2393
0000d4  e071              B        |L26.442|
0000d6  bf00              NOP                            ;2397
0000d8  bf00              NOP                            ;2398
0000da  bf00              NOP                            ;2399
0000dc  f8940034          LDRB     r0,[r4,#0x34]         ;2400
0000e0  2807              CMP      r0,#7                 ;2400
0000e2  d115              BNE      |L26.272|
0000e4  2300              MOVS     r3,#0                 ;2401
0000e6  461a              MOV      r2,r3                 ;2401
0000e8  4621              MOV      r1,r4                 ;2401
0000ea  4618              MOV      r0,r3                 ;2401
0000ec  9700              STR      r7,[sp,#0]            ;2401
0000ee  f7fffffe          BL       OS_Post
0000f2  6c66              LDR      r6,[r4,#0x44]         ;2406
0000f4  bf00              NOP                            ;2407
0000f6  bf00              NOP                            ;2407
0000f8  4648              MOV      r0,r9                 ;2407
0000fa  f7fffffe          BL       CPU_SR_Restore
0000fe  bf00              NOP                            ;2407
000100  bf00              NOP                            ;2407
000102  f4084000          AND      r0,r8,#0x8000         ;2408
000106  2800              CMP      r0,#0                 ;2408
000108  d14a              BNE      |L26.416|
00010a  f7fffffe          BL       OSSched
00010e  e047              B        |L26.416|
                  |L26.272|
000110  2004              MOVS     r0,#4                 ;2412
000112  2801              CMP      r0,#1                 ;2412
000114  d005              BEQ      |L26.290|
000116  2802              CMP      r0,#2                 ;2412
000118  d013              BEQ      |L26.322|
00011a  2804              CMP      r0,#4                 ;2412
00011c  d133              BNE      |L26.390|
00011e  e022              B        |L26.358|
                  |L26.288|
000120  e03f              B        |L26.418|
                  |L26.290|
000122  6c60              LDR      r0,[r4,#0x44]         ;2414
000124  28ff              CMP      r0,#0xff              ;2414
000126  d10b              BNE      |L26.320|
000128  bf00              NOP                            ;2415
00012a  bf00              NOP                            ;2415
00012c  4648              MOV      r0,r9                 ;2415
00012e  f7fffffe          BL       CPU_SR_Restore
000132  bf00              NOP                            ;2415
000134  bf00              NOP                            ;2415
000136  f64650c5          MOV      r0,#0x6dc5            ;2416
00013a  8028              STRH     r0,[r5,#0]            ;2416
00013c  2000              MOVS     r0,#0                 ;2417
00013e  e797              B        |L26.112|
                  |L26.320|
000140  e022              B        |L26.392|
                  |L26.322|
000142  f64f71ff          MOV      r1,#0xffff            ;2422
000146  6c60              LDR      r0,[r4,#0x44]         ;2422
000148  4288              CMP      r0,r1                 ;2422
00014a  d10b              BNE      |L26.356|
00014c  bf00              NOP                            ;2423
00014e  bf00              NOP                            ;2423
000150  4648              MOV      r0,r9                 ;2423
000152  f7fffffe          BL       CPU_SR_Restore
000156  bf00              NOP                            ;2423
000158  bf00              NOP                            ;2423
00015a  f64650c5          MOV      r0,#0x6dc5            ;2424
00015e  8028              STRH     r0,[r5,#0]            ;2424
000160  2000              MOVS     r0,#0                 ;2425
000162  e785              B        |L26.112|
                  |L26.356|
000164  e010              B        |L26.392|
                  |L26.358|
000166  6c60              LDR      r0,[r4,#0x44]         ;2430
000168  1c40              ADDS     r0,r0,#1              ;2430
00016a  b958              CBNZ     r0,|L26.388|
00016c  bf00              NOP                            ;2431
00016e  bf00              NOP                            ;2431
000170  4648              MOV      r0,r9                 ;2431
000172  f7fffffe          BL       CPU_SR_Restore
000176  bf00              NOP                            ;2431
000178  bf00              NOP                            ;2431
00017a  f64650c5          MOV      r0,#0x6dc5            ;2432
00017e  8028              STRH     r0,[r5,#0]            ;2432
000180  2000              MOVS     r0,#0                 ;2433
000182  e775              B        |L26.112|
                  |L26.388|
000184  e000              B        |L26.392|
                  |L26.390|
000186  bf00              NOP                            ;2438
                  |L26.392|
000188  bf00              NOP                            ;2419
00018a  6c60              LDR      r0,[r4,#0x44]         ;2440
00018c  1c40              ADDS     r0,r0,#1              ;2440
00018e  6460              STR      r0,[r4,#0x44]         ;2440
000190  6c66              LDR      r6,[r4,#0x44]         ;2441
000192  bf00              NOP                            ;2442
000194  bf00              NOP                            ;2442
000196  4648              MOV      r0,r9                 ;2442
000198  f7fffffe          BL       CPU_SR_Restore
00019c  bf00              NOP                            ;2442
00019e  bf00              NOP                            ;2442
                  |L26.416|
0001a0  e00b              B        |L26.442|
                  |L26.418|
0001a2  bf00              NOP                            ;2447
0001a4  bf00              NOP                            ;2447
0001a6  4648              MOV      r0,r9                 ;2447
0001a8  f7fffffe          BL       CPU_SR_Restore
0001ac  bf00              NOP                            ;2447
0001ae  bf00              NOP                            ;2447
0001b0  f646602d          MOV      r0,#0x6e2d            ;2448
0001b4  8028              STRH     r0,[r5,#0]            ;2448
0001b6  2600              MOVS     r6,#0                 ;2449
0001b8  bf00              NOP                            ;2450
                  |L26.442|
0001ba  bf00              NOP                            ;2394
0001bc  4630              MOV      r0,r6                 ;2452
0001be  e757              B        |L26.112|
;;;2454   
                          ENDP

                  |L26.448|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSuspend||, CODE, READONLY, ALIGN=2

                  OS_TaskSuspend PROC
;;;2485   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2486   void   OS_TaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2487                          OS_ERR  *p_err)
;;;2488   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2489       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2490   
;;;2491   
;;;2492   
;;;2493       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;2494       if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
000016  b90c              CBNZ     r4,|L27.28|
;;;2495           p_tcb = OSTCBCurPtr;
000018  483d              LDR      r0,|L27.272|
00001a  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L27.28|
;;;2496       }
;;;2497   
;;;2498       if (p_tcb == OSTCBCurPtr) {
00001c  483c              LDR      r0,|L27.272|
00001e  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000020  4284              CMP      r4,r0
000022  d10e              BNE      |L27.66|
;;;2499           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
000024  483b              LDR      r0,|L27.276|
000026  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
000028  2800              CMP      r0,#0
00002a  dd0a              BLE      |L27.66|
;;;2500               CPU_CRITICAL_EXIT();
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       CPU_SR_Restore
000036  bf00              NOP      
000038  bf00              NOP      
;;;2501              *p_err = OS_ERR_SCHED_LOCKED;
00003a  f6465063          MOV      r0,#0x6d63
00003e  8028              STRH     r0,[r5,#0]
                  |L27.64|
;;;2502               return;
;;;2503           }
;;;2504       }
;;;2505   
;;;2506      *p_err = OS_ERR_NONE;
;;;2507       switch (p_tcb->TaskState) {
;;;2508           case OS_TASK_STATE_RDY:
;;;2509                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2510                p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
;;;2511                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2512                OS_RdyListRemove(p_tcb);
;;;2513                OS_CRITICAL_EXIT_NO_SCHED();
;;;2514                break;
;;;2515   
;;;2516           case OS_TASK_STATE_DLY:
;;;2517                p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
;;;2518                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2519                CPU_CRITICAL_EXIT();
;;;2520                break;
;;;2521   
;;;2522           case OS_TASK_STATE_PEND:
;;;2523                p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
;;;2524                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2525                CPU_CRITICAL_EXIT();
;;;2526                break;
;;;2527   
;;;2528           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2529                p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
;;;2530                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2531                CPU_CRITICAL_EXIT();
;;;2532                break;
;;;2533   
;;;2534           case OS_TASK_STATE_SUSPENDED:
;;;2535           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2536           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2537           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2538                p_tcb->SuspendCtr++;
;;;2539                CPU_CRITICAL_EXIT();
;;;2540                break;
;;;2541   
;;;2542           default:
;;;2543                CPU_CRITICAL_EXIT();
;;;2544               *p_err = OS_ERR_STATE_INVALID;
;;;2545                return;
;;;2546       }
;;;2547   
;;;2548       OSSched();
;;;2549   }
000040  bd70              POP      {r4-r6,pc}
                  |L27.66|
000042  2000              MOVS     r0,#0                 ;2506
000044  8028              STRH     r0,[r5,#0]            ;2506
000046  f8940036          LDRB     r0,[r4,#0x36]         ;2507
00004a  2808              CMP      r0,#8                 ;2507
00004c  d250              BCS      |L27.240|
00004e  e8dff000          TBB      [pc,r0]               ;2507
000052  0415              DCB      0x04,0x15
000054  23313f40          DCB      0x23,0x31,0x3f,0x40
000058  4142              DCB      0x41,0x42
00005a  2004              MOVS     r0,#4                 ;2510
00005c  f8840036          STRB     r0,[r4,#0x36]         ;2510
000060  2001              MOVS     r0,#1                 ;2511
000062  f884008a          STRB     r0,[r4,#0x8a]         ;2511
000066  4620              MOV      r0,r4                 ;2512
000068  f7fffffe          BL       OS_RdyListRemove
00006c  bf00              NOP                            ;2513
00006e  bf00              NOP                            ;2513
000070  4630              MOV      r0,r6                 ;2513
000072  f7fffffe          BL       CPU_SR_Restore
000076  bf00              NOP                            ;2513
000078  bf00              NOP                            ;2513
00007a  e044              B        |L27.262|
00007c  2005              MOVS     r0,#5                 ;2517
00007e  f8840036          STRB     r0,[r4,#0x36]         ;2517
000082  2001              MOVS     r0,#1                 ;2518
000084  f884008a          STRB     r0,[r4,#0x8a]         ;2518
000088  bf00              NOP                            ;2519
00008a  bf00              NOP                            ;2519
00008c  4630              MOV      r0,r6                 ;2519
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP                            ;2519
000094  bf00              NOP                            ;2519
000096  e036              B        |L27.262|
000098  2006              MOVS     r0,#6                 ;2523
00009a  f8840036          STRB     r0,[r4,#0x36]         ;2523
00009e  2001              MOVS     r0,#1                 ;2524
0000a0  f884008a          STRB     r0,[r4,#0x8a]         ;2524
0000a4  bf00              NOP                            ;2525
0000a6  bf00              NOP                            ;2525
0000a8  4630              MOV      r0,r6                 ;2525
0000aa  f7fffffe          BL       CPU_SR_Restore
0000ae  bf00              NOP                            ;2525
0000b0  bf00              NOP                            ;2525
0000b2  e028              B        |L27.262|
0000b4  2007              MOVS     r0,#7                 ;2529
0000b6  f8840036          STRB     r0,[r4,#0x36]         ;2529
0000ba  2001              MOVS     r0,#1                 ;2530
0000bc  f884008a          STRB     r0,[r4,#0x8a]         ;2530
0000c0  bf00              NOP                            ;2531
0000c2  bf00              NOP                            ;2531
0000c4  4630              MOV      r0,r6                 ;2531
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP                            ;2531
0000cc  bf00              NOP                            ;2531
0000ce  e01a              B        |L27.262|
0000d0  bf00              NOP                            ;2535
0000d2  bf00              NOP                            ;2536
0000d4  bf00              NOP                            ;2537
0000d6  f894008a          LDRB     r0,[r4,#0x8a]         ;2538
0000da  1c40              ADDS     r0,r0,#1              ;2538
0000dc  f884008a          STRB     r0,[r4,#0x8a]         ;2538
0000e0  bf00              NOP                            ;2539
0000e2  bf00              NOP                            ;2539
0000e4  4630              MOV      r0,r6                 ;2539
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  bf00              NOP                            ;2539
0000ec  bf00              NOP                            ;2539
0000ee  e00a              B        |L27.262|
                  |L27.240|
0000f0  bf00              NOP                            ;2543
0000f2  bf00              NOP                            ;2543
0000f4  4630              MOV      r0,r6                 ;2543
0000f6  f7fffffe          BL       CPU_SR_Restore
0000fa  bf00              NOP                            ;2543
0000fc  bf00              NOP                            ;2543
0000fe  f646602d          MOV      r0,#0x6e2d            ;2544
000102  8028              STRH     r0,[r5,#0]            ;2544
000104  e79c              B        |L27.64|
                  |L27.262|
000106  bf00              NOP                            ;2514
000108  f7fffffe          BL       OSSched
00010c  bf00              NOP      
00010e  e797              B        |L27.64|
;;;2550   #endif
                          ENDP

                  |L27.272|
                          DCD      OSTCBCurPtr
                  |L27.276|
                          DCD      OSSchedLockNestingCtr
