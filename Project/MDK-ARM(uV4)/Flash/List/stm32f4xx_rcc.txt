; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f4xx_rcc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\stm32f4xx_rcc.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1789     */
;;;1790   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L1.14|
;;;1791   {
;;;1792     /* Check the parameters */
;;;1793     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1794   
;;;1795     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1796     if (NewState != DISABLE)
;;;1797     {
;;;1798       RCC->AHB1ENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L1.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L1.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L1.24|
                  |L1.14|
;;;1799     }
;;;1800     else
;;;1801     {
;;;1802       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L1.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L1.28|
000016  601a              STR      r2,[r3,#0]
                  |L1.24|
;;;1803     }
;;;1804   }
000018  4770              BX       lr
;;;1805   
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;2195     */
;;;2196   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;2200     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2201     if (NewState != DISABLE)
;;;2202     {
;;;2203       RCC->AHB1LPENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L2.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;2204     }
;;;2205     else
;;;2206     {
;;;2207       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L2.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  601a              STR      r2,[r3,#0]
                  |L2.24|
;;;2208     }
;;;2209   }
000018  4770              BX       lr
;;;2210   
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1995     */
;;;1996   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;1997   {
;;;1998     /* Check the parameters */
;;;1999     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;2000     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2001   
;;;2002     if (NewState != DISABLE)
;;;2003     {
;;;2004       RCC->AHB1RSTR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;2005     }
;;;2006     else
;;;2007     {
;;;2008       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  601a              STR      r2,[r3,#0]
                  |L3.24|
;;;2009     }
;;;2010   }
000018  4770              BX       lr
;;;2011   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1821     */
;;;1822   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;1823   {
;;;1824     /* Check the parameters */
;;;1825     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1826     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1827   
;;;1828     if (NewState != DISABLE)
;;;1829     {
;;;1830       RCC->AHB2ENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;1831     }
;;;1832     else
;;;1833     {
;;;1834       RCC->AHB2ENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  601a              STR      r2,[r3,#0]
                  |L4.24|
;;;1835     }
;;;1836   }
000018  4770              BX       lr
;;;1837   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;2227     */
;;;2228   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;2229   {
;;;2230     /* Check the parameters */
;;;2231     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;2232     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2233     if (NewState != DISABLE)
;;;2234     {
;;;2235       RCC->AHB2LPENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;2236     }
;;;2237     else
;;;2238     {
;;;2239       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  601a              STR      r2,[r3,#0]
                  |L5.24|
;;;2240     }
;;;2241   }
000018  4770              BX       lr
;;;2242   
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;2024     */
;;;2025   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;2026   {
;;;2027     /* Check the parameters */
;;;2028     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;2029     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2030   
;;;2031     if (NewState != DISABLE)
;;;2032     {
;;;2033       RCC->AHB2RSTR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;2034     }
;;;2035     else
;;;2036     {
;;;2037       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  601a              STR      r2,[r3,#0]
                  |L6.24|
;;;2038     }
;;;2039   }
000018  4770              BX       lr
;;;2040   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1851     */
;;;1852   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L7.14|
;;;1853   {
;;;1854     /* Check the parameters */
;;;1855     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1856     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1857   
;;;1858     if (NewState != DISABLE)
;;;1859     {
;;;1860       RCC->AHB3ENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L7.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L7.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L7.24|
                  |L7.14|
;;;1861     }
;;;1862     else
;;;1863     {
;;;1864       RCC->AHB3ENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L7.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L7.28|
000016  601a              STR      r2,[r3,#0]
                  |L7.24|
;;;1865     }
;;;1866   }
000018  4770              BX       lr
;;;1867   #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F446xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;2257     */
;;;2258   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L8.14|
;;;2259   {
;;;2260     /* Check the parameters */
;;;2261     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;2262     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2263     if (NewState != DISABLE)
;;;2264     {
;;;2265       RCC->AHB3LPENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L8.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L8.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;2266     }
;;;2267     else
;;;2268     {
;;;2269       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L8.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L8.28|
000016  601a              STR      r2,[r3,#0]
                  |L8.24|
;;;2270     }
;;;2271   }
000018  4770              BX       lr
;;;2272   #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F446xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;2051     */
;;;2052   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;2053   {
;;;2054     /* Check the parameters */
;;;2055     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;2056     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2057   
;;;2058     if (NewState != DISABLE)
;;;2059     {
;;;2060       RCC->AHB3RSTR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L9.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;2061     }
;;;2062     else
;;;2063     {
;;;2064       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L9.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  601a              STR      r2,[r3,#0]
                  |L9.24|
;;;2065     }
;;;2066   }
000018  4770              BX       lr
;;;2067   #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F446xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1907     */
;;;1908   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;1909   {
;;;1910     /* Check the parameters */
;;;1911     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1912     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1913   
;;;1914     if (NewState != DISABLE)
;;;1915     {
;;;1916       RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L10.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L10.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L10.24|
                  |L10.14|
;;;1917     }
;;;1918     else
;;;1919     {
;;;1920       RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L10.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L10.28|
000016  601a              STR      r2,[r3,#0]
                  |L10.24|
;;;1921     }
;;;1922   }
000018  4770              BX       lr
;;;1923   
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;2313     */
;;;2314   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;2315   {
;;;2316     /* Check the parameters */
;;;2317     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;2318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2319     if (NewState != DISABLE)
;;;2320     {
;;;2321       RCC->APB1LPENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;2322     }
;;;2323     else
;;;2324     {
;;;2325       RCC->APB1LPENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;2326     }
;;;2327   }
000018  4770              BX       lr
;;;2328   
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;2104     */
;;;2105   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L12.14|
;;;2106   {
;;;2107     /* Check the parameters */
;;;2108     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;2109     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2110     if (NewState != DISABLE)
;;;2111     {
;;;2112       RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L12.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L12.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;2113     }
;;;2114     else
;;;2115     {
;;;2116       RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L12.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L12.28|
000016  601a              STR      r2,[r3,#0]
                  |L12.24|
;;;2117     }
;;;2118   }
000018  4770              BX       lr
;;;2119   
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1953     */
;;;1954   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;1955   {
;;;1956     /* Check the parameters */
;;;1957     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1958     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1959   
;;;1960     if (NewState != DISABLE)
;;;1961     {
;;;1962       RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L13.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;1963     }
;;;1964     else
;;;1965     {
;;;1966       RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L13.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  601a              STR      r2,[r3,#0]
                  |L13.24|
;;;1967     }
;;;1968   }
000018  4770              BX       lr
;;;1969   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;2359     */
;;;2360   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L14.14|
;;;2361   {
;;;2362     /* Check the parameters */
;;;2363     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;2364     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2365     if (NewState != DISABLE)
;;;2366     {
;;;2367       RCC->APB2LPENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L14.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L14.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L14.24|
                  |L14.14|
;;;2368     }
;;;2369     else
;;;2370     {
;;;2371       RCC->APB2LPENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L14.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L14.28|
000016  601a              STR      r2,[r3,#0]
                  |L14.24|
;;;2372     }
;;;2373   }
000018  4770              BX       lr
;;;2374   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;2146     */
;;;2147   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;2148   {
;;;2149     /* Check the parameters */
;;;2150     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;2151     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2152     if (NewState != DISABLE)
;;;2153     {
;;;2154       RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L15.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;2155     }
;;;2156     else
;;;2157     {
;;;2158       RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L15.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  601a              STR      r2,[r3,#0]
                  |L15.24|
;;;2159     }
;;;2160   }
000018  4770              BX       lr
;;;2161   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;317      */
;;;318    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;319    {
;;;320      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;321      /* Check the parameters */
;;;322      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;323    
;;;324      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L16.20|
000006  6810              LDR      r0,[r2,#0]
;;;325    
;;;326      /* Clear HSITRIM[4:0] bits */
;;;327      tmpreg &= ~RCC_CR_HSITRIM;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;328    
;;;329      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;330      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;331    
;;;332      /* Store the new value */
;;;333      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;334    }
000012  4770              BX       lr
;;;335    
                          ENDP

                  |L16.20|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1449     */
;;;1450   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1451   {
;;;1452     /* Check the parameters */
;;;1453     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1454     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1455   }
000004  4770              BX       lr
;;;1456   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;2663     */
;;;2664   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L18.16|
;;;2665   {
;;;2666     /* Set RMVF bit to clear the reset flags */
;;;2667     RCC->CSR |= RCC_CSR_RMVF;
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L18.16|
00000a  6008              STR      r0,[r1,#0]
;;;2668   }
00000c  4770              BX       lr
;;;2669   
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;2717     */
;;;2718   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;2719   {
;;;2720     /* Check the parameters */
;;;2721     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;2722   
;;;2723     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;2724        pending bits */
;;;2725     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;2726   }
000004  4770              BX       lr
;;;2727   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;819      */
;;;820    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;821    {
;;;822      /* Check the parameters */
;;;823      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;824      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;825    }
000004  4770              BX       lr
;;;826    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;212      */
;;;213    void RCC_DeInit(void)
000000  4814              LDR      r0,|L21.84|
;;;214    {
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4912              LDR      r1,|L21.84|
00000a  6008              STR      r0,[r1,#0]
;;;217    
;;;218      /* Reset CFGR register */
;;;219      RCC->CFGR = 0x00000000;
00000c  2000              MOVS     r0,#0
00000e  4911              LDR      r1,|L21.84|
000010  3108              ADDS     r1,r1,#8
000012  6008              STR      r0,[r1,#0]
;;;220    
;;;221      /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
;;;222      RCC->CR &= (uint32_t)0xEAF6FFFF;
000014  480f              LDR      r0,|L21.84|
000016  6800              LDR      r0,[r0,#0]
000018  490f              LDR      r1,|L21.88|
00001a  4008              ANDS     r0,r0,r1
00001c  490d              LDR      r1,|L21.84|
00001e  6008              STR      r0,[r1,#0]
;;;223    
;;;224      /* Reset PLLCFGR register */
;;;225      RCC->PLLCFGR = 0x24003010;
000020  480e              LDR      r0,|L21.92|
000022  1d09              ADDS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;226    
;;;227      /* Reset PLLI2SCFGR register */
;;;228      RCC->PLLI2SCFGR = 0x20003000;
000026  480e              LDR      r0,|L21.96|
000028  490a              LDR      r1,|L21.84|
00002a  3184              ADDS     r1,r1,#0x84
00002c  6008              STR      r0,[r1,#0]
;;;229    
;;;230      /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
;;;231      RCC->PLLSAICFGR = 0x24003000;
00002e  480b              LDR      r0,|L21.92|
000030  3810              SUBS     r0,r0,#0x10
000032  1d09              ADDS     r1,r1,#4
000034  6008              STR      r0,[r1,#0]
;;;232     
;;;233      /* Reset HSEBYP bit */
;;;234      RCC->CR &= (uint32_t)0xFFFBFFFF;
000036  4807              LDR      r0,|L21.84|
000038  6800              LDR      r0,[r0,#0]
00003a  f4202080          BIC      r0,r0,#0x40000
00003e  4905              LDR      r1,|L21.84|
000040  6008              STR      r0,[r1,#0]
;;;235    
;;;236      /* Disable all interrupts */
;;;237      RCC->CIR = 0x00000000;
000042  2000              MOVS     r0,#0
000044  4903              LDR      r1,|L21.84|
000046  310c              ADDS     r1,r1,#0xc
000048  6008              STR      r0,[r1,#0]
;;;238    
;;;239      /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
;;;240      RCC->DCKCFGR = 0x00000000; 
00004a  4902              LDR      r1,|L21.84|
00004c  318c              ADDS     r1,r1,#0x8c
00004e  6008              STR      r0,[r1,#0]
;;;241    }
000050  4770              BX       lr
;;;242    
                          ENDP

000052  0000              DCW      0x0000
                  |L21.84|
                          DCD      0x40023800
                  |L21.88|
                          DCD      0xeaf6ffff
                  |L21.92|
                          DCD      0x24003010
                  |L21.96|
                          DCD      0x20003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;1247     */
;;;1248   void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1249   {
;;;1250     uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2400              MOVS     r4,#0
000008  2502              MOVS     r5,#2
00000a  2600              MOVS     r6,#0
00000c  2302              MOVS     r3,#2
;;;1251   #if defined(STM32F446xx)  
;;;1252     uint32_t pllr = 2;
;;;1253   #endif /* STM32F446xx */
;;;1254     
;;;1255     /* Get SYSCLK source -------------------------------------------------------*/
;;;1256     tmp = RCC->CFGR & RCC_CFGR_SWS;
00000e  4f32              LDR      r7,|L22.216|
000010  683f              LDR      r7,[r7,#0]
000012  f007010c          AND      r1,r7,#0xc
;;;1257     
;;;1258     switch (tmp)
000016  b121              CBZ      r1,|L22.34|
000018  2904              CMP      r1,#4
00001a  d005              BEQ      |L22.40|
00001c  2908              CMP      r1,#8
00001e  d137              BNE      |L22.144|
000020  e005              B        |L22.46|
                  |L22.34|
;;;1259     {
;;;1260     case 0x00:  /* HSI used as system clock source */
;;;1261       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000022  4f2e              LDR      r7,|L22.220|
000024  6007              STR      r7,[r0,#0]
;;;1262       break;
000026  e036              B        |L22.150|
                  |L22.40|
;;;1263     case 0x04:  /* HSE used as system clock  source */
;;;1264       RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000028  4f2d              LDR      r7,|L22.224|
00002a  6007              STR      r7,[r0,#0]
;;;1265       break;
00002c  e033              B        |L22.150|
                  |L22.46|
;;;1266     case 0x08:  /* PLL P used as system clock  source */
;;;1267       
;;;1268       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1269       SYSCLK = PLL_VCO / PLLP
;;;1270       */    
;;;1271       pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
00002e  4f2a              LDR      r7,|L22.216|
000030  1f3f              SUBS     r7,r7,#4
000032  683f              LDR      r7,[r7,#0]
000034  f3c75680          UBFX     r6,r7,#22,#1
;;;1272       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000038  4f27              LDR      r7,|L22.216|
00003a  1f3f              SUBS     r7,r7,#4
00003c  683f              LDR      r7,[r7,#0]
00003e  f007033f          AND      r3,r7,#0x3f
;;;1273       
;;;1274       if (pllsource != 0)
000042  b16e              CBZ      r6,|L22.96|
;;;1275       {
;;;1276         /* HSE used as PLL clock source */
;;;1277         pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000044  4f26              LDR      r7,|L22.224|
000046  fbb7f7f3          UDIV     r7,r7,r3
00004a  f8dfc08c          LDR      r12,|L22.216|
00004e  f1ac0c04          SUB      r12,r12,#4
000052  f8dcc000          LDR      r12,[r12,#0]
000056  f3cc1c88          UBFX     r12,r12,#6,#9
00005a  fb07f40c          MUL      r4,r7,r12
00005e  e00c              B        |L22.122|
                  |L22.96|
;;;1278       }
;;;1279       else
;;;1280       {
;;;1281         /* HSI used as PLL clock source */
;;;1282         pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000060  4f1e              LDR      r7,|L22.220|
000062  fbb7f7f3          UDIV     r7,r7,r3
000066  f8dfc070          LDR      r12,|L22.216|
00006a  f1ac0c04          SUB      r12,r12,#4
00006e  f8dcc000          LDR      r12,[r12,#0]
000072  f3cc1c88          UBFX     r12,r12,#6,#9
000076  fb07f40c          MUL      r4,r7,r12
                  |L22.122|
;;;1283       }
;;;1284       
;;;1285       pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00007a  4f17              LDR      r7,|L22.216|
00007c  1f3f              SUBS     r7,r7,#4
00007e  683f              LDR      r7,[r7,#0]
000080  f3c74701          UBFX     r7,r7,#16,#2
000084  1c7f              ADDS     r7,r7,#1
000086  007d              LSLS     r5,r7,#1
;;;1286       RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
000088  fbb4f7f5          UDIV     r7,r4,r5
00008c  6007              STR      r7,[r0,#0]
;;;1287       break;
00008e  e002              B        |L22.150|
                  |L22.144|
;;;1288   
;;;1289   #if defined(STM32F446xx)
;;;1290     case 0x0C:  /* PLL R used as system clock  source */
;;;1291       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1292       SYSCLK = PLL_VCO / PLLR
;;;1293       */    
;;;1294       pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
;;;1295       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
;;;1296       
;;;1297       if (pllsource != 0)
;;;1298       {
;;;1299         /* HSE used as PLL clock source */
;;;1300         pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
;;;1301       }
;;;1302       else
;;;1303       {
;;;1304         /* HSI used as PLL clock source */
;;;1305         pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
;;;1306       }
;;;1307       
;;;1308       pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>28) + 1 ) *2;
;;;1309       RCC_Clocks->SYSCLK_Frequency = pllvco/pllr;    
;;;1310       break;
;;;1311   #endif /* STM32F446xx */
;;;1312       
;;;1313     default:
;;;1314       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000090  4f12              LDR      r7,|L22.220|
000092  6007              STR      r7,[r0,#0]
;;;1315       break;
000094  bf00              NOP      
                  |L22.150|
000096  bf00              NOP                            ;1262
;;;1316     }
;;;1317     /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;1318     
;;;1319     /* Get HCLK prescaler */
;;;1320     tmp = RCC->CFGR & RCC_CFGR_HPRE;
000098  4f0f              LDR      r7,|L22.216|
00009a  683f              LDR      r7,[r7,#0]
00009c  f00701f0          AND      r1,r7,#0xf0
;;;1321     tmp = tmp >> 4;
0000a0  0909              LSRS     r1,r1,#4
;;;1322     presc = APBAHBPrescTable[tmp];
0000a2  4f10              LDR      r7,|L22.228|
0000a4  5c7a              LDRB     r2,[r7,r1]
;;;1323     /* HCLK clock frequency */
;;;1324     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0000a6  6807              LDR      r7,[r0,#0]
0000a8  40d7              LSRS     r7,r7,r2
0000aa  6047              STR      r7,[r0,#4]
;;;1325   
;;;1326     /* Get PCLK1 prescaler */
;;;1327     tmp = RCC->CFGR & RCC_CFGR_PPRE1;
0000ac  4f0a              LDR      r7,|L22.216|
0000ae  683f              LDR      r7,[r7,#0]
0000b0  f40751e0          AND      r1,r7,#0x1c00
;;;1328     tmp = tmp >> 10;
0000b4  0a89              LSRS     r1,r1,#10
;;;1329     presc = APBAHBPrescTable[tmp];
0000b6  4f0b              LDR      r7,|L22.228|
0000b8  5c7a              LDRB     r2,[r7,r1]
;;;1330     /* PCLK1 clock frequency */
;;;1331     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000ba  6847              LDR      r7,[r0,#4]
0000bc  40d7              LSRS     r7,r7,r2
0000be  6087              STR      r7,[r0,#8]
;;;1332   
;;;1333     /* Get PCLK2 prescaler */
;;;1334     tmp = RCC->CFGR & RCC_CFGR_PPRE2;
0000c0  4f05              LDR      r7,|L22.216|
0000c2  683f              LDR      r7,[r7,#0]
0000c4  f4074160          AND      r1,r7,#0xe000
;;;1335     tmp = tmp >> 13;
0000c8  0b49              LSRS     r1,r1,#13
;;;1336     presc = APBAHBPrescTable[tmp];
0000ca  4f06              LDR      r7,|L22.228|
0000cc  5c7a              LDRB     r2,[r7,r1]
;;;1337     /* PCLK2 clock frequency */
;;;1338     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000ce  6847              LDR      r7,[r0,#4]
0000d0  40d7              LSRS     r7,r7,r2
0000d2  60c7              STR      r7,[r0,#0xc]
;;;1339   }
0000d4  bdf0              POP      {r4-r7,pc}
;;;1340   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40023808
                  |L22.220|
                          DCD      0x00f42400
                  |L22.224|
                          DCD      0x017d7840
                  |L22.228|
                          DCD      APBAHBPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;2618     */
;;;2619   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;2620   {
000002  4601              MOV      r1,r0
;;;2621     uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;2622     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;2623     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;2624   
;;;2625     /* Check the parameters */
;;;2626     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;2627   
;;;2628     /* Get the RCC register index */
;;;2629     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;2630     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L23.22|
;;;2631     {
;;;2632       statusreg = RCC->CR;
000010  4c0a              LDR      r4,|L23.60|
000012  6823              LDR      r3,[r4,#0]
000014  e008              B        |L23.40|
                  |L23.22|
;;;2633     }
;;;2634     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d103              BNE      |L23.34|
;;;2635     {
;;;2636       statusreg = RCC->BDCR;
00001a  4c08              LDR      r4,|L23.60|
00001c  3470              ADDS     r4,r4,#0x70
00001e  6823              LDR      r3,[r4,#0]
000020  e002              B        |L23.40|
                  |L23.34|
;;;2637     }
;;;2638     else                       /* The flag to check is in CSR register */
;;;2639     {
;;;2640       statusreg = RCC->CSR;
000022  4c06              LDR      r4,|L23.60|
000024  3474              ADDS     r4,r4,#0x74
000026  6823              LDR      r3,[r4,#0]
                  |L23.40|
;;;2641     }
;;;2642   
;;;2643     /* Get the flag position */
;;;2644     tmp = RCC_FLAG & FLAG_MASK;
000028  f001021f          AND      r2,r1,#0x1f
;;;2645     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00002c  2401              MOVS     r4,#1
00002e  4094              LSLS     r4,r4,r2
000030  401c              ANDS     r4,r4,r3
000032  b10c              CBZ      r4,|L23.56|
;;;2646     {
;;;2647       bitstatus = SET;
000034  2001              MOVS     r0,#1
000036  e000              B        |L23.58|
                  |L23.56|
;;;2648     }
;;;2649     else
;;;2650     {
;;;2651       bitstatus = RESET;
000038  2000              MOVS     r0,#0
                  |L23.58|
;;;2652     }
;;;2653     /* Return the flag status */
;;;2654     return bitstatus;
;;;2655   }
00003a  bd10              POP      {r4,pc}
;;;2656   
                          ENDP

                  |L23.60|
                          DCD      0x40023800

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;2683     */
;;;2684   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;2685   {
;;;2686     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2687   
;;;2688     /* Check the parameters */
;;;2689     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;2690   
;;;2691     /* Check the status of the specified RCC interrupt */
;;;2692     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L24.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L24.16|
;;;2693     {
;;;2694       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L24.18|
                  |L24.16|
;;;2695     }
;;;2696     else
;;;2697     {
;;;2698       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L24.18|
;;;2699     }
;;;2700     /* Return the RCC_IT status */
;;;2701     return  bitstatus;
;;;2702   }
000012  4770              BX       lr
;;;2703   
                          ENDP

                  |L24.20|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;1107     */
;;;1108   uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;1109   {
;;;1110     return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1111   }
000008  4770              BX       lr
;;;1112   
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;1132     */
;;;1133   void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;1134   {
;;;1135     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1136     
;;;1137     /* Check the parameters */
;;;1138     assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;1139   
;;;1140     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L26.20|
000006  6810              LDR      r0,[r2,#0]
;;;1141   
;;;1142     /* Clear HPRE[3:0] bits */
;;;1143     tmpreg &= ~RCC_CFGR_HPRE;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;1144   
;;;1145     /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;1146     tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;1147   
;;;1148     /* Store the new value */
;;;1149     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1150   }
000010  4770              BX       lr
;;;1151   
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;262      */
;;;263    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  2100              MOVS     r1,#0
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_RCC_HSE(RCC_HSE));
;;;267    
;;;268      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;269      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  4a02              LDR      r2,|L27.12|
000004  7011              STRB     r1,[r2,#0]
;;;270    
;;;271      /* Set the new HSE configuration -------------------------------------------*/
;;;272      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  4611              MOV      r1,r2
000008  7008              STRB     r0,[r1,#0]
;;;273    }
00000a  4770              BX       lr
;;;274    
                          ENDP

                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358    
;;;359      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;360    }
000004  4770              BX       lr
;;;361    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1548     */
;;;1549   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1550   {
;;;1551     /* Check the parameters */
;;;1552     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1553   
;;;1554     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;  
000002  6008              STR      r0,[r1,#0]
;;;1555   }
000004  4770              BX       lr
;;;1556   
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      0x4247015c

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;2581     */
;;;2582   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L30.14|
;;;2583   {
;;;2584     /* Check the parameters */
;;;2585     assert_param(IS_RCC_IT(RCC_IT));
;;;2586     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2587     if (NewState != DISABLE)
;;;2588     {
;;;2589       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;2590       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a06              LDR      r2,|L30.28|
000004  7812              LDRB     r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L30.28|
00000a  701a              STRB     r2,[r3,#0]
00000c  e004              B        |L30.24|
                  |L30.14|
;;;2591     }
;;;2592     else
;;;2593     {
;;;2594       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;2595       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00000e  4a03              LDR      r2,|L30.28|
000010  7812              LDRB     r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L30.28|
000016  701a              STRB     r2,[r3,#0]
                  |L30.24|
;;;2596     }
;;;2597   }
000018  4770              BX       lr
;;;2598   
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;378      */
;;;379    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  2100              MOVS     r1,#0
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_RCC_LSE(RCC_LSE));
;;;383    
;;;384      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;385      /* Reset LSEON bit */
;;;386      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a09              LDR      r2,|L31.40|
000004  7011              STRB     r1,[r2,#0]
;;;387    
;;;388      /* Reset LSEBYP bit */
;;;389      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  7011              STRB     r1,[r2,#0]
;;;390    
;;;391      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;392      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L31.18|
00000c  2804              CMP      r0,#4
00000e  d108              BNE      |L31.34|
000010  e003              B        |L31.26|
                  |L31.18|
;;;393      {
;;;394        case RCC_LSE_ON:
;;;395          /* Set LSEON bit */
;;;396          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000012  2101              MOVS     r1,#1
000014  4a04              LDR      r2,|L31.40|
000016  7011              STRB     r1,[r2,#0]
;;;397          break;
000018  e004              B        |L31.36|
                  |L31.26|
;;;398        case RCC_LSE_Bypass:
;;;399          /* Set LSEBYP and LSEON bits */
;;;400          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00001a  2105              MOVS     r1,#5
00001c  4a02              LDR      r2,|L31.40|
00001e  7011              STRB     r1,[r2,#0]
;;;401          break;
000020  e000              B        |L31.36|
                  |L31.34|
;;;402        default:
;;;403          break;
000022  bf00              NOP      
                  |L31.36|
000024  bf00              NOP                            ;397
;;;404      }
;;;405    }
000026  4770              BX       lr
;;;406    
                          ENDP

                  |L31.40|
                          DCD      0x40023870

                          AREA ||i.RCC_LSEModeConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEModeConfig PROC
;;;2383     */
;;;2384   void RCC_LSEModeConfig(uint8_t RCC_Mode)
000000  2801              CMP      r0,#1
;;;2385   {
;;;2386     /* Check the parameters */
;;;2387     assert_param(IS_RCC_LSE_MODE(RCC_Mode));
;;;2388     
;;;2389     if(RCC_Mode == RCC_LSE_HIGHDRIVE_MODE)
000002  d106              BNE      |L32.18|
;;;2390     {
;;;2391       SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
000004  4906              LDR      r1,|L32.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0410108          ORR      r1,r1,#8
00000c  4a04              LDR      r2,|L32.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L32.30|
                  |L32.18|
;;;2392     }
;;;2393     else
;;;2394     {
;;;2395       CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
000012  4903              LDR      r1,|L32.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0210108          BIC      r1,r1,#8
00001a  4a01              LDR      r2,|L32.32|
00001c  6011              STR      r1,[r2,#0]
                  |L32.30|
;;;2396     }
;;;2397   }
00001e  4770              BX       lr
;;;2398   
                          ENDP

                  |L32.32|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;418      */
;;;419    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;423    
;;;424      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;425    }
000004  4770              BX       lr
;;;426    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_LTDCCLKDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_LTDCCLKDivConfig PROC
;;;1710     */
;;;1711   void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
000000  4601              MOV      r1,r0
;;;1712   {
;;;1713     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1714     
;;;1715     /* Check the parameters */
;;;1716     assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
;;;1717     
;;;1718     tmpreg = RCC->DCKCFGR;
000004  4a03              LDR      r2,|L34.20|
000006  6810              LDR      r0,[r2,#0]
;;;1719   
;;;1720     /* Clear PLLSAIDIVR[2:0] bits */
;;;1721     tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
000008  f4203040          BIC      r0,r0,#0x30000
;;;1722   
;;;1723     /* Set PLLSAIDIVR values */
;;;1724     tmpreg |= RCC_PLLSAIDivR;
00000c  4308              ORRS     r0,r0,r1
;;;1725   
;;;1726     /* Store the new value */
;;;1727     RCC->DCKCFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1728   }
000010  4770              BX       lr
;;;1729   
                          ENDP

000012  0000              DCW      0x0000
                  |L34.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;844      */
;;;845    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4602              MOV      r2,r0
;;;846    {
;;;847      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;848      
;;;849      /* Check the parameters */
;;;850      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;851      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;852    
;;;853      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L35.24|
000006  6818              LDR      r0,[r3,#0]
;;;854    
;;;855      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;856      tmpreg &= CFGR_MCO1_RESET_MASK;
000008  f02060ec          BIC      r0,r0,#0x7600000
;;;857    
;;;858      /* Select MCO1 clock source and prescaler */
;;;859      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;860    
;;;861      /* Store the new value */
;;;862      RCC->CFGR = tmpreg;  
000012  4b01              LDR      r3,|L35.24|
000014  6018              STR      r0,[r3,#0]
;;;863    }
000016  4770              BX       lr
;;;864    
                          ENDP

                  |L35.24|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;882      */
;;;883    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4602              MOV      r2,r0
;;;884    {
;;;885      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;886      
;;;887      /* Check the parameters */
;;;888      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;889      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;890      
;;;891      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L36.24|
000006  6818              LDR      r0,[r3,#0]
;;;892      
;;;893      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;894      tmpreg &= CFGR_MCO2_RESET_MASK;
000008  f0204078          BIC      r0,r0,#0xf8000000
;;;895    
;;;896      /* Select MCO2 clock source and prescaler */
;;;897      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;898    
;;;899      /* Store the new value */
;;;900      RCC->CFGR = tmpreg;  
000012  4b01              LDR      r3,|L36.24|
000014  6018              STR      r0,[r3,#0]
;;;901    }
000016  4770              BX       lr
;;;902    
                          ENDP

                  |L36.24|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;1164     */
;;;1165   void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;1166   {
;;;1167     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1168   
;;;1169     /* Check the parameters */
;;;1170     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1171   
;;;1172     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L37.20|
000006  6810              LDR      r0,[r2,#0]
;;;1173   
;;;1174     /* Clear PPRE1[2:0] bits */
;;;1175     tmpreg &= ~RCC_CFGR_PPRE1;
000008  f42050e0          BIC      r0,r0,#0x1c00
;;;1176   
;;;1177     /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;1178     tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;1179   
;;;1180     /* Store the new value */
;;;1181     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1182   }
000010  4770              BX       lr
;;;1183   
                          ENDP

000012  0000              DCW      0x0000
                  |L37.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;1195     */
;;;1196   void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;1197   {
;;;1198     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1199   
;;;1200     /* Check the parameters */
;;;1201     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1202   
;;;1203     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L38.20|
000006  6810              LDR      r0,[r2,#0]
;;;1204   
;;;1205     /* Clear PPRE2[2:0] bits */
;;;1206     tmpreg &= ~RCC_CFGR_PPRE2;
000008  f4204060          BIC      r0,r0,#0xe000
;;;1207   
;;;1208     /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;1209     tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;1210   
;;;1211     /* Store the new value */
;;;1212     RCC->CFGR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;1213   }
000012  4770              BX       lr
;;;1214   
                          ENDP

                  |L38.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;541      */
;;;542    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;543    {
;;;544      /* Check the parameters */
;;;545      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;547    }
000004  4770              BX       lr
;;;548    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;517      */
;;;518    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  9c04              LDR      r4,[sp,#0x10]
;;;520      /* Check the parameters */
;;;521      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;522      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;523      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;524      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;525      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;526    
;;;527      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  ea411582          ORR      r5,r1,r2,LSL #6
000008  2601              MOVS     r6,#1
00000a  ebc60653          RSB      r6,r6,r3,LSR #1
00000e  ea454506          ORR      r5,r5,r6,LSL #16
000012  4305              ORRS     r5,r5,r0
000014  ea456504          ORR      r5,r5,r4,LSL #24
000018  4e01              LDR      r6,|L40.32|
00001a  6035              STR      r5,[r6,#0]
;;;528                     (PLLQ << 24);
;;;529    }
00001c  bd70              POP      {r4-r6,pc}
;;;530    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
                          ENDP

00001e  0000              DCW      0x0000
                  |L40.32|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;710      */
;;;711    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;712    {
;;;713      /* Check the parameters */
;;;714      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;715      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;716    }
000004  4770              BX       lr
;;;717    
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;571      */
;;;572    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0182              LSLS     r2,r0,#6
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;576      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;577    
;;;578      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea427201          ORR      r2,r2,r1,LSL #28
000006  4b01              LDR      r3,|L42.12|
000008  601a              STR      r2,[r3,#0]
;;;579    }
00000a  4770              BX       lr
;;;580    #endif /* STM32F40_41xxx || STM32F401xx */
                          ENDP

                  |L42.12|
                          DCD      0x40023884

                          AREA ||i.RCC_PLLSAICmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAICmd PROC
;;;801      */
;;;802    void RCC_PLLSAICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L43.8|
;;;803    {
;;;804      /* Check the parameters */
;;;805      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;806      *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
000002  6708              STR      r0,[r1,#0x70]
;;;807    }
000004  4770              BX       lr
;;;808    
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLSAIConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAIConfig PROC
;;;781      */
;;;782    void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
000000  b510              PUSH     {r4,lr}
;;;783    {
;;;784      /* Check the parameters */
;;;785      assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
;;;786      assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
;;;787      assert_param(IS_RCC_PLLSAIQ_VALUE(PLLSAIQ));
;;;788      
;;;789      RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
000002  0183              LSLS     r3,r0,#6
000004  ea436301          ORR      r3,r3,r1,LSL #24
000008  ea437302          ORR      r3,r3,r2,LSL #28
00000c  4c01              LDR      r4,|L44.20|
00000e  6023              STR      r3,[r4,#0]
;;;790    }
000010  bd10              POP      {r4,pc}
;;;791    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40023888

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1432     */
;;;1433   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L45.8|
;;;1434   {
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1437   
;;;1438     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1439   }
000004  4770              BX       lr
;;;1440   
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1400     */
;;;1401   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  2100              MOVS     r1,#0
;;;1402   {
;;;1403     uint32_t tmpreg = 0;
;;;1404   
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1407   
;;;1408     if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000002  f4007240          AND      r2,r0,#0x300
000006  f5b27f40          CMP      r2,#0x300
00000a  d108              BNE      |L46.30|
;;;1409     { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1410       tmpreg = RCC->CFGR;
00000c  4a09              LDR      r2,|L46.52|
00000e  6811              LDR      r1,[r2,#0]
;;;1411   
;;;1412       /* Clear RTCPRE[4:0] bits */
;;;1413       tmpreg &= ~RCC_CFGR_RTCPRE;
000010  f42111f8          BIC      r1,r1,#0x1f0000
;;;1414   
;;;1415       /* Configure HSE division factor for RTC clock */
;;;1416       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000014  4a08              LDR      r2,|L46.56|
000016  4002              ANDS     r2,r2,r0
000018  4311              ORRS     r1,r1,r2
;;;1417   
;;;1418       /* Store the new value */
;;;1419       RCC->CFGR = tmpreg;
00001a  4a06              LDR      r2,|L46.52|
00001c  6011              STR      r1,[r2,#0]
                  |L46.30|
;;;1420     }
;;;1421       
;;;1422     /* Select the RTC clock source */
;;;1423     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00001e  4a05              LDR      r2,|L46.52|
000020  3268              ADDS     r2,r2,#0x68
000022  6812              LDR      r2,[r2,#0]
000024  f3c0030b          UBFX     r3,r0,#0,#12
000028  431a              ORRS     r2,r2,r3
00002a  4b02              LDR      r3,|L46.52|
00002c  3368              ADDS     r3,r3,#0x68
00002e  601a              STR      r2,[r3,#0]
;;;1424   }
000030  4770              BX       lr
;;;1425   
                          ENDP

000032  0000              DCW      0x0000
                  |L46.52|
                          DCD      0x40023808
                  |L46.56|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SAIBlockACLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockACLKConfig PROC
;;;1573     */
;;;1574   void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
000000  4601              MOV      r1,r0
;;;1575   {
;;;1576     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1577     
;;;1578     /* Check the parameters */
;;;1579     assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
;;;1580     
;;;1581     tmpreg = RCC->DCKCFGR;
000004  4a03              LDR      r2,|L47.20|
000006  6810              LDR      r0,[r2,#0]
;;;1582   
;;;1583     /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
;;;1584     tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
000008  f4201040          BIC      r0,r0,#0x300000
;;;1585   
;;;1586     /* Set SAI Block A source selection value */
;;;1587     tmpreg |= RCC_SAIBlockACLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;1588   
;;;1589     /* Store the new value */
;;;1590     RCC->DCKCFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1591   }
000010  4770              BX       lr
;;;1592   
                          ENDP

000012  0000              DCW      0x0000
                  |L47.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIBlockBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockBCLKConfig PROC
;;;1609     */
;;;1610   void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
000000  4601              MOV      r1,r0
;;;1611   {
;;;1612     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1613     
;;;1614     /* Check the parameters */
;;;1615     assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
;;;1616     
;;;1617     tmpreg = RCC->DCKCFGR;
000004  4a03              LDR      r2,|L48.20|
000006  6810              LDR      r0,[r2,#0]
;;;1618   
;;;1619     /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
;;;1620     tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
000008  f4200040          BIC      r0,r0,#0xc00000
;;;1621   
;;;1622     /* Set SAI Block B source selection value */
;;;1623     tmpreg |= RCC_SAIBlockBCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;1624   
;;;1625     /* Store the new value */
;;;1626     RCC->DCKCFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1627   }
000010  4770              BX       lr
;;;1628   #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
                          ENDP

000012  0000              DCW      0x0000
                  |L48.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLI2SClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLI2SClkDivConfig PROC
;;;1642     */
;;;1643   void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
000000  4601              MOV      r1,r0
;;;1644   {
;;;1645     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1646     
;;;1647     /* Check the parameters */
;;;1648     assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
;;;1649     
;;;1650     tmpreg = RCC->DCKCFGR;
000004  4a04              LDR      r2,|L49.24|
000006  6810              LDR      r0,[r2,#0]
;;;1651   
;;;1652     /* Clear PLLI2SDIVQ[4:0] bits */
;;;1653     tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
000008  f020001f          BIC      r0,r0,#0x1f
;;;1654   
;;;1655     /* Set PLLI2SDIVQ values */
;;;1656     tmpreg |= (RCC_PLLI2SDivQ - 1);
00000c  1e4a              SUBS     r2,r1,#1
00000e  4310              ORRS     r0,r0,r2
;;;1657   
;;;1658     /* Store the new value */
;;;1659     RCC->DCKCFGR = tmpreg;
000010  4a01              LDR      r2,|L49.24|
000012  6010              STR      r0,[r2,#0]
;;;1660   }
000014  4770              BX       lr
;;;1661   
                          ENDP

000016  0000              DCW      0x0000
                  |L49.24|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLSAIClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLSAIClkDivConfig PROC
;;;1674     */
;;;1675   void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
000000  4601              MOV      r1,r0
;;;1676   {
;;;1677     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1678     
;;;1679     /* Check the parameters */
;;;1680     assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
;;;1681     
;;;1682     tmpreg = RCC->DCKCFGR;
000004  4a04              LDR      r2,|L50.24|
000006  6810              LDR      r0,[r2,#0]
;;;1683   
;;;1684     /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
;;;1685     tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
000008  f42050f8          BIC      r0,r0,#0x1f00
;;;1686   
;;;1687     /* Set PLLSAIDIVQ values */
;;;1688     tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
00000c  1e4a              SUBS     r2,r1,#1
00000e  ea402002          ORR      r0,r0,r2,LSL #8
;;;1689   
;;;1690     /* Store the new value */
;;;1691     RCC->DCKCFGR = tmpreg;
000012  4a01              LDR      r2,|L50.24|
000014  6010              STR      r0,[r2,#0]
;;;1692   }
000016  4770              BX       lr
;;;1693   
                          ENDP

                  |L50.24|
                          DCD      0x4002388c

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;1078     */
;;;1079   void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;1080   {
;;;1081     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;1085   
;;;1086     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L51.20|
000006  6810              LDR      r0,[r2,#0]
;;;1087   
;;;1088     /* Clear SW[1:0] bits */
;;;1089     tmpreg &= ~RCC_CFGR_SW;
000008  f0200003          BIC      r0,r0,#3
;;;1090   
;;;1091     /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;1092     tmpreg |= RCC_SYSCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;1093   
;;;1094     /* Store the new value */
;;;1095     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1096   }
000010  4770              BX       lr
;;;1097   
                          ENDP

000012  0000              DCW      0x0000
                  |L51.20|
                          DCD      0x40023808

                          AREA ||i.RCC_TIMCLKPresConfig||, CODE, READONLY, ALIGN=2

                  RCC_TIMCLKPresConfig PROC
;;;1747     */
;;;1748   void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
000000  4901              LDR      r1,|L52.8|
;;;1749   {
;;;1750     /* Check the parameters */
;;;1751     assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
;;;1752   
;;;1753     *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
000002  6008              STR      r0,[r1,#0]
;;;1754   }
000004  4770              BX       lr
;;;1755   
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      0x424711e0

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;286      */
;;;287    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;288    {
;;;289      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;290      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;291      FlagStatus hsestatus = RESET;
000008  2500              MOVS     r5,#0
;;;292      /* Wait till HSE is ready and if Time out is reached exit */
;;;293      do
00000a  bf00              NOP      
                  |L53.12|
;;;294      {
;;;295        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;296        startupcounter++;
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;297      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
00001a  9800              LDR      r0,[sp,#0]
00001c  f5b04fa0          CMP      r0,#0x5000
000020  d001              BEQ      |L53.38|
000022  2d00              CMP      r5,#0
000024  d0f2              BEQ      |L53.12|
                  |L53.38|
;;;298    
;;;299      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000026  2031              MOVS     r0,#0x31
000028  f7fffffe          BL       RCC_GetFlagStatus
00002c  b108              CBZ      r0,|L53.50|
;;;300      {
;;;301        status = SUCCESS;
00002e  2401              MOVS     r4,#1
000030  e000              B        |L53.52|
                  |L53.50|
;;;302      }
;;;303      else
;;;304      {
;;;305        status = ERROR;
000032  2400              MOVS     r4,#0
                  |L53.52|
;;;306      }
;;;307      return (status);
000034  4620              MOV      r0,r4
;;;308    }
000036  bd38              POP      {r3-r5,pc}
;;;309    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____RRX|
#line 300
|__asm___15_stm32f4xx_rcc_c_49e27980____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
