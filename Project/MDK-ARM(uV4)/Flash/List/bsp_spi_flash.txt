; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_spi_flash.crf ..\..\User\bsp_stm32f4xx\flash\bsp_spi_flash.c]
                          THUMB

                          AREA ||i.SPI2_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPI2_ReadWriteByte PROC
;;;5      //返回值:读取到的字节
;;;6      static u8 SPI2_ReadWriteByte(u8 TxData)
000000  b570              PUSH     {r4-r6,lr}
;;;7      {		
000002  4605              MOV      r5,r0
;;;8      	u8 retry=0;				 	
000004  2400              MOVS     r4,#0
;;;9      	while (SPI_I2S_GetFlagStatus(FLASH_SPI, SPI_I2S_FLAG_TXE) == RESET) //检查指定的SPI标志位设置与否:发送缓存空标志位
000006  e005              B        |L1.20|
                  |L1.8|
;;;10     		{
;;;11     		retry++;
000008  1c60              ADDS     r0,r4,#1
00000a  b2c4              UXTB     r4,r0
;;;12     		if(retry>200)return 0;
00000c  2cc8              CMP      r4,#0xc8
00000e  dd01              BLE      |L1.20|
000010  2000              MOVS     r0,#0
                  |L1.18|
;;;13     		}			  
;;;14     	SPI_I2S_SendData(FLASH_SPI, TxData); //通过外设SPIx发送一个数据
;;;15     	retry=0;
;;;16     
;;;17     	while (SPI_I2S_GetFlagStatus(FLASH_SPI, SPI_I2S_FLAG_RXNE) == RESET)//检查指定的SPI标志位设置与否:接受缓存非空标志位
;;;18     		{
;;;19     		retry++;
;;;20     		if(retry>200)return 0;
;;;21     		}	  						    
;;;22     	return SPI_I2S_ReceiveData(FLASH_SPI); //返回通过SPIx最近接收的数据					    
;;;23     }
000012  bd70              POP      {r4-r6,pc}
                  |L1.20|
000014  2102              MOVS     r1,#2                 ;9
000016  480e              LDR      r0,|L1.80|
000018  f7fffffe          BL       SPI_I2S_GetFlagStatus
00001c  2800              CMP      r0,#0                 ;9
00001e  d0f3              BEQ      |L1.8|
000020  4629              MOV      r1,r5                 ;14
000022  480b              LDR      r0,|L1.80|
000024  f7fffffe          BL       SPI_I2S_SendData
000028  2400              MOVS     r4,#0                 ;15
00002a  e005              B        |L1.56|
                  |L1.44|
00002c  1c60              ADDS     r0,r4,#1              ;19
00002e  b2c4              UXTB     r4,r0                 ;19
000030  2cc8              CMP      r4,#0xc8              ;20
000032  dd01              BLE      |L1.56|
000034  2000              MOVS     r0,#0                 ;20
000036  e7ec              B        |L1.18|
                  |L1.56|
000038  2101              MOVS     r1,#1                 ;17
00003a  4805              LDR      r0,|L1.80|
00003c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000040  2800              CMP      r0,#0                 ;17
000042  d0f3              BEQ      |L1.44|
000044  4802              LDR      r0,|L1.80|
000046  f7fffffe          BL       SPI_I2S_ReceiveData
00004a  b2c0              UXTB     r0,r0                 ;22
00004c  e7e1              B        |L1.18|
;;;24     
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40003800

                          AREA ||i.W25QXX_Erase_Chip||, CODE, READONLY, ALIGN=2

                  W25QXX_Erase_Chip PROC
;;;270    //等待时间超长...
;;;271    void W25QXX_Erase_Chip(void)   
000000  b510              PUSH     {r4,lr}
;;;272    {                                   
;;;273        W25QXX_Write_Enable();                 	 	//SET WEL 
000002  f7fffffe          BL       W25QXX_Write_Enable
;;;274        W25QXX_Wait_Busy();   
000006  f7fffffe          BL       W25QXX_Wait_Busy
;;;275      	SPI_FLASH_CS_LOW();                            	//使能器件   
00000a  f44f5180          MOV      r1,#0x1000
00000e  4807              LDR      r0,|L2.44|
000010  f7fffffe          BL       GPIO_ResetBits
;;;276        SPI2_ReadWriteByte(W25X_ChipErase);        	//发送片擦除命令  
000014  20c7              MOVS     r0,#0xc7
000016  f7fffffe          BL       SPI2_ReadWriteByte
;;;277    		SPI_FLASH_CS_HIGH();                            	//取消片选     	      
00001a  f44f5180          MOV      r1,#0x1000
00001e  4803              LDR      r0,|L2.44|
000020  f7fffffe          BL       GPIO_SetBits
;;;278    		W25QXX_Wait_Busy();   				   		//等待芯片擦除结束
000024  f7fffffe          BL       W25QXX_Wait_Busy
;;;279    }   
000028  bd10              POP      {r4,pc}
;;;280    //擦除一个扇区
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Erase_Sector||, CODE, READONLY, ALIGN=2

                  W25QXX_Erase_Sector PROC
;;;282    //擦除一个山区的最少时间:150ms
;;;283    void W25QXX_Erase_Sector(u32 Dst_Addr)   
000000  b510              PUSH     {r4,lr}
;;;284    {  
000002  4604              MOV      r4,r0
;;;285    	//监视falsh擦除情况,测试用   
;;;286    // 	printf("fe:%x\r\n",Dst_Addr);	  
;;;287    		Dst_Addr*=4096;
000004  0324              LSLS     r4,r4,#12
;;;288        W25QXX_Write_Enable();                  	//SET WEL 	 
000006  f7fffffe          BL       W25QXX_Write_Enable
;;;289        W25QXX_Wait_Busy();   
00000a  f7fffffe          BL       W25QXX_Wait_Busy
;;;290      	SPI_FLASH_CS_LOW();                            	//使能器件   
00000e  f44f5180          MOV      r1,#0x1000
000012  480c              LDR      r0,|L3.68|
000014  f7fffffe          BL       GPIO_ResetBits
;;;291        SPI2_ReadWriteByte(W25X_SectorErase);      	//发送扇区擦除指令 
000018  2020              MOVS     r0,#0x20
00001a  f7fffffe          BL       SPI2_ReadWriteByte
;;;292        SPI2_ReadWriteByte((u8)((Dst_Addr)>>16));  	//发送24bit地址    
00001e  f3c44007          UBFX     r0,r4,#16,#8
000022  f7fffffe          BL       SPI2_ReadWriteByte
;;;293        SPI2_ReadWriteByte((u8)((Dst_Addr)>>8));   
000026  f3c42007          UBFX     r0,r4,#8,#8
00002a  f7fffffe          BL       SPI2_ReadWriteByte
;;;294        SPI2_ReadWriteByte((u8)Dst_Addr);  
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       SPI2_ReadWriteByte
;;;295    		SPI_FLASH_CS_HIGH();                            	//取消片选     	      
000034  f44f5180          MOV      r1,#0x1000
000038  4802              LDR      r0,|L3.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;296        W25QXX_Wait_Busy();   				   		//等待擦除完成
00003e  f7fffffe          BL       W25QXX_Wait_Busy
;;;297    }  
000042  bd10              POP      {r4,pc}
;;;298    
                          ENDP

                  |L3.68|
                          DCD      0x40020400

                          AREA ||i.W25QXX_PowerDown||, CODE, READONLY, ALIGN=2

                  W25QXX_PowerDown PROC
;;;299    //进入掉电模式
;;;300    void W25QXX_PowerDown(void)   
000000  b510              PUSH     {r4,lr}
;;;301    { 
;;;302      	SPI_FLASH_CS_LOW();                           	 	//使能器件   
000002  f44f5180          MOV      r1,#0x1000
000006  4806              LDR      r0,|L4.32|
000008  f7fffffe          BL       GPIO_ResetBits
;;;303        SPI2_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
00000c  20b9              MOVS     r0,#0xb9
00000e  f7fffffe          BL       SPI2_ReadWriteByte
;;;304    		SPI_FLASH_CS_HIGH();                            	//取消片选     	      
000012  f44f5180          MOV      r1,#0x1000
000016  4802              LDR      r0,|L4.32|
000018  f7fffffe          BL       GPIO_SetBits
;;;305    //    delay_us(3);                               //等待TPD  
;;;306    }   
00001c  bd10              POP      {r4,pc}
;;;307    //唤醒
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Read||, CODE, READONLY, ALIGN=2

                  W25QXX_Read PROC
;;;146    //NumByteToRead:要读取的字节数(最大65535)
;;;147    void W25QXX_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    { 
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;149    		u16 i;   										    
;;;150    		SPI_FLASH_CS_LOW();                            	//使能器件   
00000a  f44f5180          MOV      r1,#0x1000
00000e  4811              LDR      r0,|L5.84|
000010  f7fffffe          BL       GPIO_ResetBits
;;;151        SPI2_ReadWriteByte(W25X_ReadData);         	//发送读取命令   
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       SPI2_ReadWriteByte
;;;152        SPI2_ReadWriteByte((u8)((ReadAddr)>>16));  	//发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPI2_ReadWriteByte
;;;153        SPI2_ReadWriteByte((u8)((ReadAddr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPI2_ReadWriteByte
;;;154        SPI2_ReadWriteByte((u8)ReadAddr);   
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPI2_ReadWriteByte
;;;155        for(i=0;i<NumByteToRead;i++)
000030  2500              MOVS     r5,#0
000032  e005              B        |L5.64|
                  |L5.52|
;;;156    		{ 
;;;157            pBuffer[i]=SPI2_ReadWriteByte(0XFF);   	//循环读数  
000034  20ff              MOVS     r0,#0xff
000036  f7fffffe          BL       SPI2_ReadWriteByte
00003a  5570              STRB     r0,[r6,r5]
00003c  1c68              ADDS     r0,r5,#1              ;155
00003e  b285              UXTH     r5,r0                 ;155
                  |L5.64|
000040  42bd              CMP      r5,r7                 ;155
000042  dbf7              BLT      |L5.52|
;;;158        }
;;;159    		SPI_FLASH_CS_HIGH();  				    	      
000044  f44f5180          MOV      r1,#0x1000
000048  4802              LDR      r0,|L5.84|
00004a  f7fffffe          BL       GPIO_SetBits
;;;160    }  
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;161    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      0x40020400

                          AREA ||i.W25QXX_ReadID||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadID PROC
;;;128    //0XEF17,表示芯片型号为W25Q128 	  
;;;129    u16 W25QXX_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131    	u16 Temp = 0;	  
000002  2400              MOVS     r4,#0
;;;132    	SPI_FLASH_CS_LOW();				    
000004  f44f5180          MOV      r1,#0x1000
000008  480f              LDR      r0,|L6.72|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;133    	SPI2_ReadWriteByte(0x90);//发送读取ID命令	    
00000e  2090              MOVS     r0,#0x90
000010  f7fffffe          BL       SPI2_ReadWriteByte
;;;134    	SPI2_ReadWriteByte(0x00); 	    
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       SPI2_ReadWriteByte
;;;135    	SPI2_ReadWriteByte(0x00); 	    
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       SPI2_ReadWriteByte
;;;136    	SPI2_ReadWriteByte(0x00); 	 			   
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       SPI2_ReadWriteByte
;;;137    	Temp|=SPI2_ReadWriteByte(0xFF)<<8;  
000026  20ff              MOVS     r0,#0xff
000028  f7fffffe          BL       SPI2_ReadWriteByte
00002c  ea442400          ORR      r4,r4,r0,LSL #8
;;;138    	Temp|=SPI2_ReadWriteByte(0xFF);	 
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SPI2_ReadWriteByte
000036  4304              ORRS     r4,r4,r0
;;;139    	SPI_FLASH_CS_HIGH();				    
000038  f44f5180          MOV      r1,#0x1000
00003c  4802              LDR      r0,|L6.72|
00003e  f7fffffe          BL       GPIO_SetBits
;;;140    	return Temp;
000042  4620              MOV      r0,r4
;;;141    }   		    
000044  bd10              POP      {r4,pc}
;;;142    //读取SPI FLASH  
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0x40020400

                          AREA ||i.W25QXX_ReadSR||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadSR PROC
;;;80     //默认:0x00
;;;81     u8 W25QXX_ReadSR(void)   
000000  b510              PUSH     {r4,lr}
;;;82     {  
;;;83     	u8 byte=0;   
000002  2400              MOVS     r4,#0
;;;84     	SPI_FLASH_CS_LOW();                            //使能器件   
000004  f44f5180          MOV      r1,#0x1000
000008  4808              LDR      r0,|L7.44|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;85     	SPI2_ReadWriteByte(W25X_ReadStatusReg); //发送读取状态寄存器命令    
00000e  2005              MOVS     r0,#5
000010  f7fffffe          BL       SPI2_ReadWriteByte
;;;86     	byte=SPI2_ReadWriteByte(0Xff);          //读取一个字节  
000014  20ff              MOVS     r0,#0xff
000016  f7fffffe          BL       SPI2_ReadWriteByte
00001a  4604              MOV      r4,r0
;;;87     	SPI_FLASH_CS_HIGH();                            //取消片选     
00001c  f44f5180          MOV      r1,#0x1000
000020  4802              LDR      r0,|L7.44|
000022  f7fffffe          BL       GPIO_SetBits
;;;88     	return byte;   
000026  4620              MOV      r0,r4
;;;89     } 
000028  bd10              POP      {r4,pc}
;;;90     //写W25QXX状态寄存器
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40020400

                          AREA ||i.W25QXX_WAKEUP||, CODE, READONLY, ALIGN=2

                  W25QXX_WAKEUP PROC
;;;307    //唤醒
;;;308    void W25QXX_WAKEUP(void)   
000000  b510              PUSH     {r4,lr}
;;;309    {  
;;;310      	SPI_FLASH_CS_LOW();                            	//使能器件   
000002  f44f5180          MOV      r1,#0x1000
000006  4806              LDR      r0,|L8.32|
000008  f7fffffe          BL       GPIO_ResetBits
;;;311        SPI2_ReadWriteByte(W25X_ReleasePowerDown);	//  send W25X_PowerDown command 0xAB    
00000c  20ab              MOVS     r0,#0xab
00000e  f7fffffe          BL       SPI2_ReadWriteByte
;;;312    		SPI_FLASH_CS_HIGH();                           	//取消片选     	      
000012  f44f5180          MOV      r1,#0x1000
000016  4802              LDR      r0,|L8.32|
000018  f7fffffe          BL       GPIO_SetBits
;;;313    //    delay_us(3);                            	//等待TRES1
;;;314    }   
00001c  bd10              POP      {r4,pc}
;;;315    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Wait_Busy||, CODE, READONLY, ALIGN=1

                  W25QXX_Wait_Busy PROC
;;;116    //等待空闲
;;;117    void W25QXX_Wait_Busy(void)   
000000  b510              PUSH     {r4,lr}
;;;118    {   
;;;119    	while((W25QXX_ReadSR()&0x01)==0x01);  		// 等待BUSY位清空
000002  bf00              NOP      
                  |L9.4|
000004  f7fffffe          BL       W25QXX_ReadSR
000008  f0000001          AND      r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L9.4|
;;;120    }  
000010  bd10              POP      {r4,pc}
;;;121    
                          ENDP


                          AREA ||i.W25QXX_Write||, CODE, READONLY, ALIGN=2

                  W25QXX_Write PROC
;;;219    u8 W25QXX_BUFFER[4096];		 
;;;220    void W25QXX_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;221    { 
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;222    		u32 secpos;
;;;223    		u16 secoff;
;;;224    		u16 secremain;	   
;;;225    		u16 i;    
;;;226    		u8 * W25QXX_BUF;	  
;;;227       	W25QXX_BUF=W25QXX_BUFFER;	     
00000a  f8dfb0a8          LDR      r11,|L10.180|
;;;228    		secpos=WriteAddr/4096;//扇区地址  
00000e  ea4f3817          LSR      r8,r7,#12
;;;229    		secoff=WriteAddr%4096;//在扇区内的偏移
000012  f3c70a0b          UBFX     r10,r7,#0,#12
;;;230    		secremain=4096-secoff;//扇区剩余空间大小   
000016  f5ca5480          RSB      r4,r10,#0x1000
;;;231    		//printf("ad:%X,nb:%X\r\n",WriteAddr,NumByteToWrite);//测试用
;;;232    		if(NumByteToWrite<=secremain)
00001a  42a6              CMP      r6,r4
00001c  dc00              BGT      |L10.32|
;;;233    			secremain=NumByteToWrite;//不大于4096个字节
00001e  4634              MOV      r4,r6
                  |L10.32|
;;;234    		while(1) 
000020  e044              B        |L10.172|
                  |L10.34|
;;;235    		{	
;;;236    			W25QXX_Read(W25QXX_BUF,secpos*4096,4096);//读出整个扇区的内容
000022  ea4f3108          LSL      r1,r8,#12
000026  f44f5280          MOV      r2,#0x1000
00002a  4658              MOV      r0,r11
00002c  f7fffffe          BL       W25QXX_Read
;;;237    			for(i=0;i<secremain;i++)//校验数据
000030  2500              MOVS     r5,#0
000032  e008              B        |L10.70|
                  |L10.52|
;;;238    			{
;;;239    				if(W25QXX_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
000034  eb0a0005          ADD      r0,r10,r5
000038  f81b0000          LDRB     r0,[r11,r0]
00003c  28ff              CMP      r0,#0xff
00003e  d000              BEQ      |L10.66|
000040  e003              B        |L10.74|
                  |L10.66|
000042  1c68              ADDS     r0,r5,#1              ;237
000044  b285              UXTH     r5,r0                 ;237
                  |L10.70|
000046  42a5              CMP      r5,r4                 ;237
000048  dbf4              BLT      |L10.52|
                  |L10.74|
00004a  bf00              NOP      
;;;240    			}
;;;241    			if(i < secremain)//需要擦除
00004c  42a5              CMP      r5,r4
00004e  da16              BGE      |L10.126|
;;;242    			{
;;;243    				W25QXX_Erase_Sector(secpos);		//擦除这个扇区
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       W25QXX_Erase_Sector
;;;244    				for(i=0;i<secremain;i++)	   		//复制
000056  2500              MOVS     r5,#0
000058  e007              B        |L10.106|
                  |L10.90|
;;;245    				{
;;;246    					W25QXX_BUF[i+secoff]=pBuffer[i];	  
00005a  f8190005          LDRB     r0,[r9,r5]
00005e  eb05010a          ADD      r1,r5,r10
000062  f80b0001          STRB     r0,[r11,r1]
000066  1c68              ADDS     r0,r5,#1              ;244
000068  b285              UXTH     r5,r0                 ;244
                  |L10.106|
00006a  42a5              CMP      r5,r4                 ;244
00006c  dbf5              BLT      |L10.90|
;;;247    				}
;;;248    				W25QXX_Write_NoCheck(W25QXX_BUF,secpos*4096,4096);//写入整个扇区  
00006e  ea4f3108          LSL      r1,r8,#12
000072  f44f5280          MOV      r2,#0x1000
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       W25QXX_Write_NoCheck
00007c  e004              B        |L10.136|
                  |L10.126|
;;;249    			}
;;;250    			else 
;;;251    				W25QXX_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
00007e  4622              MOV      r2,r4
000080  4639              MOV      r1,r7
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       W25QXX_Write_NoCheck
                  |L10.136|
;;;252    			if(NumByteToWrite == secremain)
000088  42a6              CMP      r6,r4
00008a  d100              BNE      |L10.142|
;;;253    						break;//写入结束了
00008c  e00f              B        |L10.174|
                  |L10.142|
;;;254    			else//写入未结束
;;;255    			{
;;;256    				secpos++;//扇区地址增1
00008e  f1080801          ADD      r8,r8,#1
;;;257    				secoff=0;//偏移位置为0 	 
000092  f04f0a00          MOV      r10,#0
;;;258    
;;;259    				pBuffer += secremain;  				//指针偏移
000096  44a1              ADD      r9,r9,r4
;;;260    				WriteAddr += secremain;				//写地址偏移	   
000098  4427              ADD      r7,r7,r4
;;;261    				NumByteToWrite -= secremain;			//字节数递减
00009a  1b30              SUBS     r0,r6,r4
00009c  b286              UXTH     r6,r0
;;;262    				if(NumByteToWrite>4096)
00009e  f5b65f80          CMP      r6,#0x1000
0000a2  dd02              BLE      |L10.170|
;;;263    					secremain=4096;//下一个扇区还是写不完
0000a4  f44f5480          MOV      r4,#0x1000
0000a8  e000              B        |L10.172|
                  |L10.170|
;;;264    				else 
;;;265    					secremain = NumByteToWrite;		//下一个扇区可以写完了
0000aa  4634              MOV      r4,r6
                  |L10.172|
0000ac  e7b9              B        |L10.34|
                  |L10.174|
0000ae  bf00              NOP                            ;253
;;;266    			}	 
;;;267    		}	 
;;;268    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;269    //擦除整个芯片		  
                          ENDP

                  |L10.180|
                          DCD      W25QXX_BUFFER

                          AREA ||i.W25QXX_Write_Disable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Disable PROC
;;;108    //将WEL清零  
;;;109    void W25QXX_Write_Disable(void)   
000000  b510              PUSH     {r4,lr}
;;;110    {  
;;;111    		SPI_FLASH_CS_LOW();                            //使能器件   
000002  f44f5180          MOV      r1,#0x1000
000006  4806              LDR      r0,|L11.32|
000008  f7fffffe          BL       GPIO_ResetBits
;;;112        SPI2_ReadWriteByte(W25X_WriteDisable);  //发送写禁止指令    
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       SPI2_ReadWriteByte
;;;113    		SPI_FLASH_CS_HIGH();                           //取消片选     	      
000012  f44f5180          MOV      r1,#0x1000
000016  4802              LDR      r0,|L11.32|
000018  f7fffffe          BL       GPIO_SetBits
;;;114    } 	
00001c  bd10              POP      {r4,pc}
;;;115    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Write_Enable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Enable PROC
;;;100    //将WEL置位   
;;;101    void W25QXX_Write_Enable(void)   
000000  b510              PUSH     {r4,lr}
;;;102    {
;;;103    		SPI_FLASH_CS_LOW();                         	//使能器件   
000002  f44f5180          MOV      r1,#0x1000
000006  4806              LDR      r0,|L12.32|
000008  f7fffffe          BL       GPIO_ResetBits
;;;104        SPI2_ReadWriteByte(W25X_WriteEnable); 	//发送写使能  
00000c  2006              MOVS     r0,#6
00000e  f7fffffe          BL       SPI2_ReadWriteByte
;;;105    		SPI_FLASH_CS_HIGH();                          	//取消片选     	      
000012  f44f5180          MOV      r1,#0x1000
000016  4802              LDR      r0,|L12.32|
000018  f7fffffe          BL       GPIO_SetBits
;;;106    } 
00001c  bd10              POP      {r4,pc}
;;;107    //W25QXX写禁止	
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  W25QXX_Write_NoCheck PROC
;;;188    //CHECK OK
;;;189    void W25QXX_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;190    { 			 		 
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;191    	u16 pageremain;	   
;;;192    	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
00000a  b2f0              UXTB     r0,r6
00000c  f5c07580          RSB      r5,r0,#0x100
;;;193    	if(NumByteToWrite<=pageremain)
000010  42ac              CMP      r4,r5
000012  dc00              BGT      |L13.22|
;;;194    		pageremain=NumByteToWrite;//不大于256个字节
000014  4625              MOV      r5,r4
                  |L13.22|
;;;195    	while(1)
000016  e012              B        |L13.62|
                  |L13.24|
;;;196    	{	   
;;;197    		W25QXX_Write_Page(pBuffer,WriteAddr,pageremain);
000018  462a              MOV      r2,r5
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       W25QXX_Write_Page
;;;198    		if(NumByteToWrite==pageremain)
000022  42ac              CMP      r4,r5
000024  d100              BNE      |L13.40|
;;;199    			break;//写入结束了
000026  e00b              B        |L13.64|
                  |L13.40|
;;;200    	 	else //NumByteToWrite>pageremain
;;;201    		{
;;;202    			pBuffer += pageremain;
000028  442f              ADD      r7,r7,r5
;;;203    			WriteAddr += pageremain;	
00002a  442e              ADD      r6,r6,r5
;;;204    
;;;205    			NumByteToWrite -= pageremain;			  //减去已经写入了的字节数
00002c  1b60              SUBS     r0,r4,r5
00002e  b284              UXTH     r4,r0
;;;206    			if(NumByteToWrite > 256)
000030  f5b47f80          CMP      r4,#0x100
000034  dd02              BLE      |L13.60|
;;;207    					pageremain = 256; //一次可以写入256个字节
000036  f44f7580          MOV      r5,#0x100
00003a  e000              B        |L13.62|
                  |L13.60|
;;;208    			else
;;;209    					pageremain = NumByteToWrite; 	  //不够256个字节了
00003c  4625              MOV      r5,r4
                  |L13.62|
00003e  e7eb              B        |L13.24|
                  |L13.64|
000040  bf00              NOP                            ;199
;;;210    		}
;;;211    	};	    
;;;212    } 
000042  e8bd81f0          POP      {r4-r8,pc}
;;;213    //写SPI FLASH  
                          ENDP


                          AREA ||i.W25QXX_Write_Page||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Page PROC
;;;165    //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 
;;;166    void W25QXX_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;168    		u16 i;  
;;;169        W25QXX_Write_Enable();                  	//SET WEL 
00000a  f7fffffe          BL       W25QXX_Write_Enable
;;;170    		SPI_FLASH_CS_LOW();                          	//使能器件   
00000e  f44f5180          MOV      r1,#0x1000
000012  4811              LDR      r0,|L14.88|
000014  f7fffffe          BL       GPIO_ResetBits
;;;171        SPI2_ReadWriteByte(W25X_PageProgram);      	//发送写页命令   
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       SPI2_ReadWriteByte
;;;172        SPI2_ReadWriteByte((u8)((WriteAddr)>>16)); 	//发送24bit地址    
00001e  f3c44007          UBFX     r0,r4,#16,#8
000022  f7fffffe          BL       SPI2_ReadWriteByte
;;;173        SPI2_ReadWriteByte((u8)((WriteAddr)>>8));   
000026  f3c42007          UBFX     r0,r4,#8,#8
00002a  f7fffffe          BL       SPI2_ReadWriteByte
;;;174        SPI2_ReadWriteByte((u8)WriteAddr);   
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       SPI2_ReadWriteByte
;;;175        for(i=0;i<NumByteToWrite;i++)
000034  2500              MOVS     r5,#0
000036  e004              B        |L14.66|
                  |L14.56|
;;;176    			SPI2_ReadWriteByte(pBuffer[i]);//循环写数  
000038  5d70              LDRB     r0,[r6,r5]
00003a  f7fffffe          BL       SPI2_ReadWriteByte
00003e  1c68              ADDS     r0,r5,#1              ;175
000040  b285              UXTH     r5,r0                 ;175
                  |L14.66|
000042  42bd              CMP      r5,r7                 ;175
000044  dbf8              BLT      |L14.56|
;;;177    		SPI_FLASH_CS_HIGH();                           	//取消片选 
000046  f44f5180          MOV      r1,#0x1000
00004a  4803              LDR      r0,|L14.88|
00004c  f7fffffe          BL       GPIO_SetBits
;;;178    		W25QXX_Wait_Busy();					   		//等待写入结束
000050  f7fffffe          BL       W25QXX_Wait_Busy
;;;179    } 
000054  e8bd81f0          POP      {r4-r8,pc}
;;;180    
                          ENDP

                  |L14.88|
                          DCD      0x40020400

                          AREA ||i.W25QXX_Write_SR||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_SR PROC
;;;91     //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;92     void W25QXX_Write_SR(u8 sr)   
000000  b510              PUSH     {r4,lr}
;;;93     {   
000002  4604              MOV      r4,r0
;;;94     	SPI_FLASH_CS_LOW();                     //使能器件   
000004  f44f5180          MOV      r1,#0x1000
000008  4807              LDR      r0,|L15.40|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;95     	SPI2_ReadWriteByte(W25X_WriteStatusReg);//发送写取状态寄存器命令    
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       SPI2_ReadWriteByte
;;;96     	SPI2_ReadWriteByte(sr);               	//写入一个字节  
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI2_ReadWriteByte
;;;97     	SPI_FLASH_CS_HIGH();                    //取消片选     	      
00001a  f44f5180          MOV      r1,#0x1000
00001e  4802              LDR      r0,|L15.40|
000020  f7fffffe          BL       GPIO_SetBits
;;;98     }   
000024  bd10              POP      {r4,pc}
;;;99     //W25QXX写使能	
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      0x40020400

                          AREA ||i.bsp_FlashInit||, CODE, READONLY, ALIGN=2

                  bsp_FlashInit PROC
;;;24     
;;;25     void bsp_FlashInit(void)
000000  b500              PUSH     {lr}
;;;26     {
000002  b087              SUB      sp,sp,#0x1c
;;;27     		GPIO_InitTypeDef GPIO_InitStructure;
;;;28       	SPI_InitTypeDef  SPI_InitStructure;
;;;29     
;;;30     		RCC_AHB1PeriphClockCmd(	FLASH_SPI_GPIO_CLK, ENABLE );//PORTB时钟使能 
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;31     		RCC_APB1PeriphClockCmd(	FLASH_SPI_CLK,  ENABLE );//SPI2时钟使能 	
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;32     	 
;;;33     		GPIO_PinAFConfig(FLASH_SPI_GPIO_PORT, FLASH_SPI_SCK_PinSource, FLASH_SPI_AF);
000014  2205              MOVS     r2,#5
000016  210d              MOVS     r1,#0xd
000018  4831              LDR      r0,|L16.224|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;34     	  GPIO_PinAFConfig(FLASH_SPI_GPIO_PORT, FLASH_SPI_MISO_PinSource, FLASH_SPI_AF);
00001e  2205              MOVS     r2,#5
000020  210e              MOVS     r1,#0xe
000022  482f              LDR      r0,|L16.224|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;35     		GPIO_PinAFConfig(FLASH_SPI_GPIO_PORT, FLASH_SPI_MOSI_PinSource, FLASH_SPI_AF);
000028  2205              MOVS     r2,#5
00002a  210f              MOVS     r1,#0xf
00002c  482c              LDR      r0,|L16.224|
00002e  f7fffffe          BL       GPIO_PinAFConfig
;;;36     	
;;;37     		GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN | FLASH_SPI_MISO_PIN | FLASH_SPI_MOSI_PIN;
000032  f44f4060          MOV      r0,#0xe000
000036  9005              STR      r0,[sp,#0x14]
;;;38     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;  //PB13/14/15复用推挽输出 
000038  2002              MOVS     r0,#2
00003a  f88d0018          STRB     r0,[sp,#0x18]
;;;39     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00003e  2003              MOVS     r0,#3
000040  f88d0019          STRB     r0,[sp,#0x19]
;;;40     		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000044  2000              MOVS     r0,#0
000046  f88d001a          STRB     r0,[sp,#0x1a]
;;;41     		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; 
00004a  f88d001b          STRB     r0,[sp,#0x1b]
;;;42     		GPIO_Init(FLASH_SPI_GPIO_PORT, &GPIO_InitStructure);//初始化GPIOB
00004e  a905              ADD      r1,sp,#0x14
000050  4823              LDR      r0,|L16.224|
000052  f7fffffe          BL       GPIO_Init
;;;43     	
;;;44     		GPIO_SetBits(FLASH_SPI_GPIO_PORT,FLASH_SPI_SCK_PIN | FLASH_SPI_MISO_PIN | FLASH_SPI_MOSI_PIN);  //PB13/14/15上拉
000056  f44f4160          MOV      r1,#0xe000
00005a  4821              LDR      r0,|L16.224|
00005c  f7fffffe          BL       GPIO_SetBits
;;;45     		
;;;46     		GPIO_InitStructure.GPIO_Pin = FLASH_CS_PIN;  // PB12 推挽 
000060  f44f5080          MOV      r0,#0x1000
000064  9005              STR      r0,[sp,#0x14]
;;;47     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000066  2001              MOVS     r0,#1
000068  f88d0018          STRB     r0,[sp,#0x18]
;;;48     		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00006c  2000              MOVS     r0,#0
00006e  f88d001a          STRB     r0,[sp,#0x1a]
;;;49     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000072  2002              MOVS     r0,#2
000074  f88d0019          STRB     r0,[sp,#0x19]
;;;50     		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000078  2000              MOVS     r0,#0
00007a  f88d001b          STRB     r0,[sp,#0x1b]
;;;51     		GPIO_Init(FLASH_SPI_GPIO_PORT, &GPIO_InitStructure);
00007e  a905              ADD      r1,sp,#0x14
000080  4817              LDR      r0,|L16.224|
000082  f7fffffe          BL       GPIO_Init
;;;52     	 
;;;53     		SPI_FLASH_CS_HIGH();				//SPI FLASH不选中
000086  f44f5180          MOV      r1,#0x1000
00008a  4815              LDR      r0,|L16.224|
00008c  f7fffffe          BL       GPIO_SetBits
;;;54     		
;;;55     		SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000090  2000              MOVS     r0,#0
000092  f8ad0000          STRH     r0,[sp,#0]
;;;56     		SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000096  f44f7082          MOV      r0,#0x104
00009a  f8ad0002          STRH     r0,[sp,#2]
;;;57     		SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
00009e  2000              MOVS     r0,#0
0000a0  f8ad0004          STRH     r0,[sp,#4]
;;;58     		SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
0000a4  2002              MOVS     r0,#2
0000a6  f8ad0006          STRH     r0,[sp,#6]
;;;59     		SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
0000aa  2001              MOVS     r0,#1
0000ac  f8ad0008          STRH     r0,[sp,#8]
;;;60     		SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
0000b0  0240              LSLS     r0,r0,#9
0000b2  f8ad000a          STRH     r0,[sp,#0xa]
;;;61     		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;		//定义波特率预分频的值:波特率预分频值为2
0000b6  2000              MOVS     r0,#0
0000b8  f8ad000c          STRH     r0,[sp,#0xc]
;;;62     		SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
0000bc  f8ad000e          STRH     r0,[sp,#0xe]
;;;63     		SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
0000c0  2007              MOVS     r0,#7
0000c2  f8ad0010          STRH     r0,[sp,#0x10]
;;;64     		SPI_Init(FLASH_SPI, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000c6  4669              MOV      r1,sp
0000c8  4806              LDR      r0,|L16.228|
0000ca  f7fffffe          BL       SPI_Init
;;;65     	 
;;;66     		SPI_Cmd(FLASH_SPI, ENABLE); //使能SPI外设
0000ce  2101              MOVS     r1,#1
0000d0  4804              LDR      r0,|L16.228|
0000d2  f7fffffe          BL       SPI_Cmd
;;;67     		
;;;68     		SPI2_ReadWriteByte(0xff);//启动传输		 
0000d6  20ff              MOVS     r0,#0xff
0000d8  f7fffffe          BL       SPI2_ReadWriteByte
;;;69     	 
;;;70     
;;;71     }   
0000dc  b007              ADD      sp,sp,#0x1c
0000de  bd00              POP      {pc}
;;;72     
                          ENDP

                  |L16.224|
                          DCD      0x40020400
                  |L16.228|
                          DCD      0x40003800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  W25QXX_BUFFER
                          %        4096

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\flash\\bsp_spi_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_e0c9aa38____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_spi_flash_c_e0c9aa38____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_e0c9aa38____REVSH|
#line 144
|__asm___15_bsp_spi_flash_c_e0c9aa38____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_e0c9aa38____RRX|
#line 300
|__asm___15_bsp_spi_flash_c_e0c9aa38____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
