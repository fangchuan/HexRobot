L 1 "..\..\uCOS-III\uC-LIB\lib_str.c"
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.c
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 BAN
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*********************************************************************************************************
N* Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
N*                     us permission to reprint portions of their documentation.  Portions of this text are
N*                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
N*                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
N*                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
N*                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
N*                     discrepancy between these versions and the original IEEE and The Open Group Standard,
N*                     the original IEEE and The Open Group Standard is the referee document.  The original
N*                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#define    MICRIUM_SOURCE
N#define    LIB_STR_MODULE
N#include  <lib_str.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_str.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.h
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This string library header file is protected from multiple pre-processor inclusion through 
N*               use of the string library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_MODULE_PRESENT                                 /* See Note #1.                                         */
N#define  LIB_STR_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                 ASCII STRING CONFIGURATION DEFINES
N*
N* Note(s) : (1) Some ASCII string configuration #define's MUST be available PRIOR to including any 
N*               application configuration (see 'INCLUDE FILES  Note #1a').
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                    STRING FLOATING POINT DEFINES
N*
N* Note(s) : (1) (a) (1) The maximum accuracy for 32-bit floating-point numbers :
N*
N*
N*                             Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
N*                       32-bit Floating-point Number  =  -----------------------------------------------------
N*                                                                         log [External-Base]
N*
N*                                                         log [2 ^ 24]
N*                                                     =  --------------
N*                                                           log [10]
N*
N*                                                     <  7.225  Base-10 Digits
N*
N*                           where
N*                                   Internal-Base                   Internal number base of floating-
N*                                                                       point numbers (i.e.  2)
N*                                   External-Base                   External number base of floating-
N*                                                                       point numbers (i.e. 10)
N*                                   Number-Internal-Base-Digits     Number of internal number base
N*                                                                       significant digits (i.e. 24)
N*
N*                   (2) Also, since some 32-bit floating-point calculations are converted to 32-bit 
N*                       unsigned numbers, the maximum accuracy is limited to the maximum accuracy
N*                       for 32-bit unsigned numbers of 9 digits.
N*
N*               (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the 
N*                   maximum accuracy.
N*********************************************************************************************************
N*/
N
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MIN                    1u
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MAX                    9u   /* See Note #1a2.                                       */
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT                   7u   /* See Note #1a1.                                       */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\lib_cfg.h
N*
N*               (b) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) '\<Custom Library Directory>\' directory                            See Note #1b
N*
N*               (c) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard library header files SHOULD be removed once all custom
N*               library functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'STANDARD LIBRARY MACRO'S  Note #1'.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
L 1 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M4
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.29.01.00
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_MODULE_PRESENT                                     /* See Note #1.                                         */
N#define  CPU_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<Your Product Application>\cpu_cfg.h
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                               <cpu>                           directory name for specific CPU
N*                               <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
N*
N*           (3) Since NO custom library modules are included, 'cpu.h' may ONLY use configurations from
N*               CPU configuration file 'cpu_cfg.h' that do NOT reference any custom library definitions.
N*
N*               In other words, 'cpu.h' may use 'cpu_cfg.h' configurations that are #define'd to numeric
N*               constants or to NULL (i.e. NULL-valued #define's); but may NOT use configurations to
N*               custom library #define's (e.g. DEF_DISABLED or DEF_ENABLED).
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\uCOS-III\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.29.01
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU definition header file is protected from multiple pre-processor inclusion 
N*               through use of the CPU definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_DEF_MODULE_PRESENT
N#define  CPU_DEF_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                   CORE CPU MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The core CPU module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer 
N*                                                       portion denotes the major version number & the unscaled 
N*                                                       fractional portion denotes the (concatenated) minor 
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  CPU_CORE_VERSION                              12901u   /* See Note #1.                                         */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ---------------------- CPU WORD SIZE ----------------------- */
N#define  CPU_WORD_SIZE_08                          1    /*  8-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_16                          2    /* 16-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_32                          4    /* 32-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_64                          8    /* 64-bit word size (in octets).                                */
N
N
N                                                        /* ------------------ CPU WORD-ENDIAN ORDER ------------------- */
N#define  CPU_ENDIAN_TYPE_NONE                      0u
N#define  CPU_ENDIAN_TYPE_BIG                       1u   /* Big-   endian word order (see Note #1a).                     */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2u   /* Little-endian word order (see Note #1b).                     */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack 
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack 
N*                                                   memory address after data is pushed onto the stack
N*********************************************************************************************************
N*/
N
N                                                        /* ------------------ CPU STACK GROWTH ORDER ------------------ */
N#define  CPU_STK_GROWTH_NONE                       0u
N#define  CPU_STK_GROWTH_LO_TO_HI                   1u   /* CPU stk incs towards higher mem addrs (see Note #1a).        */
N#define  CPU_STK_GROWTH_HI_TO_LO                   2u   /* CPU stk decs towards lower  mem addrs (see Note #1b).        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need 
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, 
N*                        if used, MUST be declared following ALL other local variables (see any 'cpu.h  
N*                        CRITICAL SECTION CONFIGURATION  Note #3a1').
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to 
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0u   /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1u   /* DIS/EN       ints                    (see Note #1a).         */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2u   /* Push/Pop     int status onto stk     (see Note #1b).         */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3u   /* Save/Restore int status to local var (see Note #1c).         */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                  /* End of CPU def module include.                               */
N
L 88 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView\cpu.h" 2
N#include  <cpu_cfg.h>                                           /* See Note #3.                                         */
L 1 "..\..\User\cpu_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       CPU CONFIGURATION FILE
N*
N*                                              TEMPLATE
N*
N* Filename      : cpu_cfg.h
N* Version       : V1.29.01
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                       CPU NAME CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_NAME_EN to enable/disable CPU host name feature :
N*
N*               (a) CPU host name storage
N*               (b) CPU host name API functions
N*
N*           (2) Configure CPU_CFG_NAME_SIZE with the desired ASCII string size of the CPU host name, 
N*               including the terminating NULL character.
N*
N*               See also 'cpu_core.h  GLOBAL VARIABLES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU host name feature (see Note #1) :      */
N#define  CPU_CFG_NAME_EN                         DEF_ENABLED
N                                                                /*   DEF_DISABLED  CPU host name DISABLED               */
N                                                                /*   DEF_ENABLED   CPU host name ENABLED                */
N
N                                                                /* Configure CPU host name ASCII string size ...        */
N#define  CPU_CFG_NAME_SIZE                                16    /* ... (see Note #2).                                   */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                     CPU TIMESTAMP CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_TS_xx_EN to enable/disable CPU timestamp features :
N*
N*               (a) CPU_CFG_TS_32_EN   enable/disable 32-bit CPU timestamp feature
N*               (b) CPU_CFG_TS_64_EN   enable/disable 64-bit CPU timestamp feature
N*
N*           (2) (a) Configure CPU_CFG_TS_TMR_SIZE with the CPU timestamp timer's word size :
N*
N*                       CPU_WORD_SIZE_08         8-bit word size
N*                       CPU_WORD_SIZE_16        16-bit word size
N*                       CPU_WORD_SIZE_32        32-bit word size
N*                       CPU_WORD_SIZE_64        64-bit word size
N*
N*               (b) If the size of the CPU timestamp timer is not a binary multiple of 8-bit octets 
N*                   (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple octet word 
N*                   size SHOULD be configured (e.g. to 16-bits).  However, the minimum supported word 
N*                   size for CPU timestamp timers is 8-bits.
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU timestamp features (see Note #1) :     */
N#define  CPU_CFG_TS_32_EN                       DEF_ENABLED
N#define  CPU_CFG_TS_64_EN                       DEF_DISABLED
N                                                                /*   DEF_DISABLED  CPU timestamps DISABLED              */
N                                                                /*   DEF_ENABLED   CPU timestamps ENABLED               */
N
N                                                                /* Configure CPU timestamp timer word size ...          */
N                                                                /* ... (see Note #2) :                                  */
N#define  CPU_CFG_TS_TMR_SIZE                    CPU_WORD_SIZE_32
N
N
N/*
N*********************************************************************************************************
N*                        CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_INT_DIS_MEAS_EN to enable/disable measuring CPU's interrupts 
N*                   disabled time :
N*
N*                   (a)  Enabled,       if CPU_CFG_INT_DIS_MEAS_EN      #define'd in 'cpu_cfg.h'
N*
N*                   (b) Disabled,       if CPU_CFG_INT_DIS_MEAS_EN  NOT #define'd in 'cpu_cfg.h'
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  Note #1'.
N*
N*               (b) Configure CPU_CFG_INT_DIS_MEAS_OVRHD_NBR with the number of times to measure & 
N*                   average the interrupts disabled time measurements overhead.
N*
N*                   Recommend a single (1) overhead time measurement, even for instruction-cache-enabled 
N*                   CPUs, since critical sections are NOT typically called within instruction-cached loops.
N*                   Thus a single non-cached/non-averaged time measurement is a more realistic overhead 
N*                   for the majority of non-cached interrupts disabled time measurements.
N*
N*                   See also 'cpu_core.c  CPU_IntDisMeasInit()  Note #3a'.
N*********************************************************************************************************
N*/
N
N#if 0                                                           /* Configure CPU interrupts disabled time ...           */
S#define  CPU_CFG_INT_DIS_MEAS_EN                                /* ... measurements feature (see Note #1a).             */
N#endif
N
N                                                                /* Configure number of interrupts disabled overhead ... */
N#define  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR                    1u   /* ... time measurements (see Note #1b).                */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N#if 1                                                           /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N#endif
N
N#if 0                                                           /* Configure CPU count trailing zeros bits ...          */
S#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module include.                       */
N
L 89 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView\cpu.h" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *p_obj
N*
N*                           FnctName(p_obj);
N*********************************************************************************************************
N*/
N
Ntypedef            void        CPU_VOID;
Ntypedef            char        CPU_CHAR;                        /*  8-bit character                                     */
Ntypedef  unsigned  char        CPU_BOOLEAN;                     /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char        CPU_INT08U;                      /*  8-bit unsigned integer                              */
Ntypedef    signed  char        CPU_INT08S;                      /*  8-bit   signed integer                              */
Ntypedef  unsigned  short       CPU_INT16U;                      /* 16-bit unsigned integer                              */
Ntypedef    signed  short       CPU_INT16S;                      /* 16-bit   signed integer                              */
Ntypedef  unsigned  int         CPU_INT32U;                      /* 32-bit unsigned integer                              */
Ntypedef    signed  int         CPU_INT32S;                      /* 32-bit   signed integer                              */
Ntypedef  unsigned  long  long  CPU_INT64U;                      /* 64-bit unsigned integer                              */
Ntypedef    signed  long  long  CPU_INT64S;                      /* 64-bit   signed integer                              */
N
Ntypedef            float       CPU_FP32;                        /* 32-bit floating point                                */
Ntypedef            double      CPU_FP64;                        /* 64-bit floating point                                */
N
N
Ntypedef  volatile  CPU_INT08U  CPU_REG08;                       /*  8-bit register                                      */
Ntypedef  volatile  CPU_INT16U  CPU_REG16;                       /* 16-bit register                                      */
Ntypedef  volatile  CPU_INT32U  CPU_REG32;                       /* 32-bit register                                      */
Ntypedef  volatile  CPU_INT64U  CPU_REG64;                       /* 64-bit register                                      */
N
N
Ntypedef            void      (*CPU_FNCT_VOID)(void);            /* See Note #2a.                                        */
Ntypedef            void      (*CPU_FNCT_PTR )(void *p_obj);     /* See Note #2b.                                        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE, CPU_CFG_DATA_SIZE, & CPU_CFG_DATA_SIZE_MAX with CPU's &/or 
N*               compiler's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE_MAX          CPU_WORD_SIZE_64        /* Defines CPU maximum word size  (in octets).          */
N
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order (see Note #2). */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_ADDR    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack
N*                                                   memory address after data is pushed onto the stack
N*********************************************************************************************************
N*/
N
N#define  CPU_CFG_STK_GROWTH     CPU_STK_GROWTH_HI_TO_LO         /* Defines CPU stack growth order (see Note #1).        */
N
Ntypedef  CPU_INT32U             CPU_STK;                        /* Defines CPU stack word size (in octets).             */
Ntypedef  CPU_ADDR               CPU_STK_SIZE;                   /* Defines CPU stack      size (in number of CPU_STKs). */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, if 
N*                        used, MUST be declared following ALL other local variables.
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD    CPU_CRITICAL_METHOD_STATUS_LOCAL
N
Ntypedef  CPU_INT32U                 CPU_SR;                     /* Defines   CPU status register size (see Note #3b).   */
N
N                                                                /* Allocates CPU status register word (see Note #3a).   */
N#if     (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if     (3u == 3u)
N#define  CPU_SR_ALLOC()             CPU_SR  cpu_sr = (CPU_SR)0
N#else
S#define  CPU_SR_ALLOC()
N#endif
N
N
N
N#define  CPU_INT_DIS()         do { cpu_sr = CPU_SR_Save(); } while (0) /* Save    CPU status word & disable interrupts.*/
N#define  CPU_INT_EN()          do { CPU_SR_Restore(cpu_sr); } while (0) /* Restore CPU status word.                     */
N
N
N#ifdef   CPU_CFG_INT_DIS_MEAS_EN
S                                                                        /* Disable interrupts, ...                      */
S                                                                        /* & start interrupts disabled time measurement.*/
S#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();         \
S                                    CPU_IntDisMeasStart(); }  while (0)
X#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();                                             CPU_IntDisMeasStart(); }  while (0)
S                                                                        /* Stop & measure   interrupts disabled time,   */
S                                                                        /* ...  & re-enable interrupts.                 */
S#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();  \
S                                    CPU_INT_EN();          }  while (0)
X#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();                                      CPU_INT_EN();          }  while (0)
S
N#else
N
N#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS(); } while (0)          /* Disable   interrupts.                        */
N#define  CPU_CRITICAL_EXIT()   do { CPU_INT_EN();  } while (0)          /* Re-enable interrupts.                        */
N
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N
N                                                                /* Configure CPU count trailing zeros bits ...          */
N#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
Nvoid        CPU_IntSrcPendClr(CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
N
NCPU_DATA    CPU_RevBits      (CPU_DATA    val);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0u
N#define  CPU_INT_RESET                                     1u
N#define  CPU_INT_NMI                                       2u
N#define  CPU_INT_HFAULT                                    3u
N#define  CPU_INT_MEM                                       4u
N#define  CPU_INT_BUSFAULT                                  5u
N#define  CPU_INT_USAGEFAULT                                6u
N#define  CPU_INT_RSVD_07                                   7u
N#define  CPU_INT_RSVD_08                                   8u
N#define  CPU_INT_RSVD_09                                   9u
N#define  CPU_INT_RSVD_10                                  10u
N#define  CPU_INT_SVCALL                                   11u
N#define  CPU_INT_DBGMON                                   12u
N#define  CPU_INT_RSVD_13                                  13u
N#define  CPU_INT_PENDSV                                   14u
N#define  CPU_INT_SYSTICK                                  15u
N#define  CPU_INT_EXT0                                     16u
N
N/*
N*********************************************************************************************************
N*                                            CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC           (*((CPU_REG32 *)(0xE000E004)))             /* Int Ctrl'er Type Reg.                */
N#define  CPU_REG_NVIC_ST_CTRL        (*((CPU_REG32 *)(0xE000E010)))             /* SysTick Ctrl & Status Reg.           */
N#define  CPU_REG_NVIC_ST_RELOAD      (*((CPU_REG32 *)(0xE000E014)))             /* SysTick Reload      Value Reg.       */
N#define  CPU_REG_NVIC_ST_CURRENT     (*((CPU_REG32 *)(0xE000E018)))             /* SysTick Current     Value Reg.       */
N#define  CPU_REG_NVIC_ST_CAL         (*((CPU_REG32 *)(0xE000E01C)))             /* SysTick Calibration Value Reg.       */
N
N#define  CPU_REG_NVIC_SETEN(n)       (*((CPU_REG32 *)(0xE000E100 + (n) * 4u)))  /* IRQ Set En Reg.                      */
N#define  CPU_REG_NVIC_CLREN(n)       (*((CPU_REG32 *)(0xE000E180 + (n) * 4u)))  /* IRQ Clr En Reg.                      */
N#define  CPU_REG_NVIC_SETPEND(n)     (*((CPU_REG32 *)(0xE000E200 + (n) * 4u)))  /* IRQ Set Pending Reg.                 */
N#define  CPU_REG_NVIC_CLRPEND(n)     (*((CPU_REG32 *)(0xE000E280 + (n) * 4u)))  /* IRQ Clr Pending Reg.                 */
N#define  CPU_REG_NVIC_ACTIVE(n)      (*((CPU_REG32 *)(0xE000E300 + (n) * 4u)))  /* IRQ Active Reg.                      */
N#define  CPU_REG_NVIC_PRIO(n)        (*((CPU_REG32 *)(0xE000E400 + (n) * 4u)))  /* IRQ Prio Reg.                        */
N
N#define  CPU_REG_NVIC_CPUID          (*((CPU_REG32 *)(0xE000ED00)))             /* CPUID Base Reg.                      */
N#define  CPU_REG_NVIC_ICSR           (*((CPU_REG32 *)(0xE000ED04)))             /* Int Ctrl State  Reg.                 */
N#define  CPU_REG_NVIC_VTOR           (*((CPU_REG32 *)(0xE000ED08)))             /* Vect Tbl Offset Reg.                 */
N#define  CPU_REG_NVIC_AIRCR          (*((CPU_REG32 *)(0xE000ED0C)))             /* App Int/Reset Ctrl Reg.              */
N#define  CPU_REG_NVIC_SCR            (*((CPU_REG32 *)(0xE000ED10)))             /* System Ctrl Reg.                     */
N#define  CPU_REG_NVIC_CCR            (*((CPU_REG32 *)(0xE000ED14)))             /* Cfg    Ctrl Reg.                     */
N#define  CPU_REG_NVIC_SHPRI1         (*((CPU_REG32 *)(0xE000ED18)))             /* System Handlers  4 to  7 Prio.       */
N#define  CPU_REG_NVIC_SHPRI2         (*((CPU_REG32 *)(0xE000ED1C)))             /* System Handlers  8 to 11 Prio.       */
N#define  CPU_REG_NVIC_SHPRI3         (*((CPU_REG32 *)(0xE000ED20)))             /* System Handlers 12 to 15 Prio.       */
N#define  CPU_REG_NVIC_SHCSR          (*((CPU_REG32 *)(0xE000ED24)))             /* System Handler Ctrl & State Reg.     */
N#define  CPU_REG_NVIC_CFSR           (*((CPU_REG32 *)(0xE000ED28)))             /* Configurable Fault Status Reg.       */
N#define  CPU_REG_NVIC_HFSR           (*((CPU_REG32 *)(0xE000ED2C)))             /* Hard  Fault Status Reg.              */
N#define  CPU_REG_NVIC_DFSR           (*((CPU_REG32 *)(0xE000ED30)))             /* Debug Fault Status Reg.              */
N#define  CPU_REG_NVIC_MMFAR          (*((CPU_REG32 *)(0xE000ED34)))             /* Mem Manage Addr Reg.                 */
N#define  CPU_REG_NVIC_BFAR           (*((CPU_REG32 *)(0xE000ED38)))             /* Bus Fault  Addr Reg.                 */
N#define  CPU_REG_NVIC_AFSR           (*((CPU_REG32 *)(0xE000ED3C)))             /* Aux Fault Status Reg.                */
N
N#define  CPU_REG_NVIC_PFR0           (*((CPU_REG32 *)(0xE000ED40)))             /* Processor Feature Reg 0.             */
N#define  CPU_REG_NVIC_PFR1           (*((CPU_REG32 *)(0xE000ED44)))             /* Processor Feature Reg 1.             */
N#define  CPU_REG_NVIC_DFR0           (*((CPU_REG32 *)(0xE000ED48)))             /* Debug     Feature Reg 0.             */
N#define  CPU_REG_NVIC_AFR0           (*((CPU_REG32 *)(0xE000ED4C)))             /* Aux       Feature Reg 0.             */
N#define  CPU_REG_NVIC_MMFR0          (*((CPU_REG32 *)(0xE000ED50)))             /* Memory Model Feature Reg 0.          */
N#define  CPU_REG_NVIC_MMFR1          (*((CPU_REG32 *)(0xE000ED54)))             /* Memory Model Feature Reg 1.          */
N#define  CPU_REG_NVIC_MMFR2          (*((CPU_REG32 *)(0xE000ED58)))             /* Memory Model Feature Reg 2.          */
N#define  CPU_REG_NVIC_MMFR3          (*((CPU_REG32 *)(0xE000ED5C)))             /* Memory Model Feature Reg 3.          */
N#define  CPU_REG_NVIC_ISAFR0         (*((CPU_REG32 *)(0xE000ED60)))             /* ISA Feature Reg 0.                   */
N#define  CPU_REG_NVIC_ISAFR1         (*((CPU_REG32 *)(0xE000ED64)))             /* ISA Feature Reg 1.                   */
N#define  CPU_REG_NVIC_ISAFR2         (*((CPU_REG32 *)(0xE000ED68)))             /* ISA Feature Reg 2.                   */
N#define  CPU_REG_NVIC_ISAFR3         (*((CPU_REG32 *)(0xE000ED6C)))             /* ISA Feature Reg 3.                   */
N#define  CPU_REG_NVIC_ISAFR4         (*((CPU_REG32 *)(0xE000ED70)))             /* ISA Feature Reg 4.                   */
N#define  CPU_REG_NVIC_SW_TRIG        (*((CPU_REG32 *)(0xE000EF00)))             /* Software Trigger Int Reg.            */
N
N#define  CPU_REG_MPU_TYPE            (*((CPU_REG32 *)(0xE000ED90)))             /* MPU Type Reg.                        */
N#define  CPU_REG_MPU_CTRL            (*((CPU_REG32 *)(0xE000ED94)))             /* MPU Ctrl Reg.                        */
N#define  CPU_REG_MPU_REG_NBR         (*((CPU_REG32 *)(0xE000ED98)))             /* MPU Region Nbr Reg.                  */
N#define  CPU_REG_MPU_REG_BASE        (*((CPU_REG32 *)(0xE000ED9C)))             /* MPU Region Base Addr Reg.            */
N#define  CPU_REG_MPU_REG_ATTR        (*((CPU_REG32 *)(0xE000EDA0)))             /* MPU Region Attrib & Size Reg.        */
N
N#define  CPU_REG_DBG_CTRL            (*((CPU_REG32 *)(0xE000EDF0)))             /* Debug Halting Ctrl & Status Reg.     */
N#define  CPU_REG_DBG_SELECT          (*((CPU_REG32 *)(0xE000EDF4)))             /* Debug Core Reg Selector Reg.         */
N#define  CPU_REG_DBG_DATA            (*((CPU_REG32 *)(0xE000EDF8)))             /* Debug Core Reg Data     Reg.         */
N#define  CPU_REG_DBG_INT             (*((CPU_REG32 *)(0xE000EDFC)))             /* Debug Except & Monitor Ctrl Reg.     */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG           0x00010000
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE           0x00000004
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT             0x00000002
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE              0x00000001
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF                0x80000000
N#define  CPU_REG_NVIC_ST_CAL_SKEW                 0x40000000
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET             0x80000000
N#define  CPU_REG_NVIC_ICSR_PENDSVSET              0x10000000
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR              0x08000000
N#define  CPU_REG_NVIC_ICSR_PENDSTSET              0x04000000
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR              0x02000000
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT             0x00800000
N#define  CPU_REG_NVIC_ICSR_ISRPENDING             0x00400000
N#define  CPU_REG_NVIC_ICSR_RETTOBASE              0x00000800
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE                0x20000000
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS            0x00008000
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ           0x00000004
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE         0x00000002
N#define  CPU_REG_NVIC_AIRCR_VECTRESET             0x00000001
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND               0x00000010
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP               0x00000004
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT             0x00000002
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN                0x00000200
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN               0x00000100
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP               0x00000010
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP             0x00000008
N#define  CPU_REG_NVIC_CCR_USERSETMPEND            0x00000002
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA          0x00000001
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA           0x00040000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA           0x00020000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA           0x00010000
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED          0x00008000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED        0x00004000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED        0x00002000
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED        0x00001000
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT            0x00000800
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT             0x00000400
N#define  CPU_REG_NVIC_SHCSR_MONITORACT            0x00000100
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT             0x00000080
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT           0x00000008
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT           0x00000002
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT           0x00000001
N
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO              0x02000000
N#define  CPU_REG_NVIC_CFSR_UNALIGNED              0x01000000
N#define  CPU_REG_NVIC_CFSR_NOCP                   0x00080000
N#define  CPU_REG_NVIC_CFSR_INVPC                  0x00040000
N#define  CPU_REG_NVIC_CFSR_INVSTATE               0x00020000
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR             0x00010000
N#define  CPU_REG_NVIC_CFSR_BFARVALID              0x00008000
N#define  CPU_REG_NVIC_CFSR_STKERR                 0x00001000
N#define  CPU_REG_NVIC_CFSR_UNSTKERR               0x00000800
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR            0x00000400
N#define  CPU_REG_NVIC_CFSR_PRECISERR              0x00000200
N#define  CPU_REG_NVIC_CFSR_IBUSERR                0x00000100
N#define  CPU_REG_NVIC_CFSR_MMARVALID              0x00000080
N#define  CPU_REG_NVIC_CFSR_MSTKERR                0x00000010
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR              0x00000008
N#define  CPU_REG_NVIC_CFSR_DACCVIOL               0x00000002
N#define  CPU_REG_NVIC_CFSR_IACCVIOL               0x00000001
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT               0x80000000
N#define  CPU_REG_NVIC_HFSR_FORCED                 0x40000000
N#define  CPU_REG_NVIC_HFSR_VECTTBL                0x00000002
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL               0x00000010
N#define  CPU_REG_NVIC_DFSR_VCATCH                 0x00000008
N#define  CPU_REG_NVIC_DFSR_DWTTRAP                0x00000004
N#define  CPU_REG_NVIC_DFSR_BKPT                   0x00000002
N#define  CPU_REG_NVIC_DFSR_HALTED                 0x00000001
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER MASK
N*********************************************************************************************************
N*/
N
N#define  CPU_MSK_NVIC_ICSR_VECT_ACTIVE            0x000001FF
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4 != 1) &&         (4 != 2) &&         (4 != 4) &&         (4 != 8))
S#error  "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4 != 1) &&         (4 != 2) &&         (4 != 4) &&         (4 != 8))
S#error  "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX          not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_64))
X#elif  ((8 != 1) &&         (8 != 2) &&         (8 != 4) &&         (8 != 8))
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N
N#if     (CPU_CFG_DATA_SIZE_MAX < CPU_CFG_DATA_SIZE)
X#if     (8 < 4)
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h' "
S#error  "                         [MUST be  >= CPU_CFG_DATA_SIZE]"
N#endif
N
N
N
N
N/*$PAGE*/
N#ifndef  CPU_CFG_ENDIAN_TYPE
S#error  "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif  ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S        (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif  ((2u != 1u   ) &&         (2u != 2u))
S#error  "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_STK_GROWTH
S#error  "CPU_CFG_STK_GROWTH             not #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
S
S#elif  ((CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_LO_TO_HI) && \
S        (CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_HI_TO_LO))
X#elif  ((2u != 1u) &&         (2u != 2u))
S#error  "CPU_CFG_STK_GROWTH       illegally #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_CRITICAL_METHOD
S#error  "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif  ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif  ((3u != 1u  ) &&         (3u != 2u  ) &&         (3u != 3u))
S#error  "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU module include.                           */
N
L 156 "..\..\uCOS-III\uC-LIB\lib_str.h" 2
N
N#include  <lib_def.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 FBJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/CPU V1.29.00
N*
N*
N*                 (2) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This library definition header file is protected from multiple pre-processor inclusion 
N*               through use of the library definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer 
N*                                                       portion denotes the major version number & the unscaled 
N*                                                       fractional portion denotes the (concatenated) minor 
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                   13700u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
N#include  <cpu.h>
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N#define  DEF_NULL                                 ((void *)0)
N
N
N                                                                /* ----------------- BOOLEAN DEFINES ------------------ */
N#define  DEF_FALSE                                         0u
N#define  DEF_TRUE                                          1u
N
N#define  DEF_NO                                            0u
N#define  DEF_YES                                           1u
N
N#define  DEF_DISABLED                                      0u
N#define  DEF_ENABLED                                       1u
N
N#define  DEF_INACTIVE                                      0u
N#define  DEF_ACTIVE                                        1u
N
N#define  DEF_INVALID                                       0u
N#define  DEF_VALID                                         1u
N
N#define  DEF_OFF                                           0u
N#define  DEF_ON                                            1u
N
N#define  DEF_CLR                                           0u
N#define  DEF_SET                                           1u
N
N#define  DEF_FAIL                                          0u
N#define  DEF_OK                                            1u
N
N
N                                                                /* ------------------- BIT DEFINES -------------------- */
N#define  DEF_BIT_NONE                                   0x00u
N
N#define  DEF_BIT_00                                     0x01u
N#define  DEF_BIT_01                                     0x02u
N#define  DEF_BIT_02                                     0x04u
N#define  DEF_BIT_03                                     0x08u
N#define  DEF_BIT_04                                     0x10u
N#define  DEF_BIT_05                                     0x20u
N#define  DEF_BIT_06                                     0x40u
N#define  DEF_BIT_07                                     0x80u
N
N#define  DEF_BIT_08                                   0x0100u
N#define  DEF_BIT_09                                   0x0200u
N#define  DEF_BIT_10                                   0x0400u
N#define  DEF_BIT_11                                   0x0800u
N#define  DEF_BIT_12                                   0x1000u
N#define  DEF_BIT_13                                   0x2000u
N#define  DEF_BIT_14                                   0x4000u
N#define  DEF_BIT_15                                   0x8000u
N
N#define  DEF_BIT_16                               0x00010000u
N#define  DEF_BIT_17                               0x00020000u
N#define  DEF_BIT_18                               0x00040000u
N#define  DEF_BIT_19                               0x00080000u
N#define  DEF_BIT_20                               0x00100000u
N#define  DEF_BIT_21                               0x00200000u
N#define  DEF_BIT_22                               0x00400000u
N#define  DEF_BIT_23                               0x00800000u
N
N#define  DEF_BIT_24                               0x01000000u
N#define  DEF_BIT_25                               0x02000000u
N#define  DEF_BIT_26                               0x04000000u
N#define  DEF_BIT_27                               0x08000000u
N#define  DEF_BIT_28                               0x10000000u
N#define  DEF_BIT_29                               0x20000000u
N#define  DEF_BIT_30                               0x40000000u
N#define  DEF_BIT_31                               0x80000000u
N/*$PAGE*/
N#define  DEF_BIT_32                       0x0000000100000000u
N#define  DEF_BIT_33                       0x0000000200000000u
N#define  DEF_BIT_34                       0x0000000400000000u
N#define  DEF_BIT_35                       0x0000000800000000u
N#define  DEF_BIT_36                       0x0000001000000000u
N#define  DEF_BIT_37                       0x0000002000000000u
N#define  DEF_BIT_38                       0x0000004000000000u
N#define  DEF_BIT_39                       0x0000008000000000u
N
N#define  DEF_BIT_40                       0x0000010000000000u
N#define  DEF_BIT_41                       0x0000020000000000u
N#define  DEF_BIT_42                       0x0000040000000000u
N#define  DEF_BIT_43                       0x0000080000000000u
N#define  DEF_BIT_44                       0x0000100000000000u
N#define  DEF_BIT_45                       0x0000200000000000u
N#define  DEF_BIT_46                       0x0000400000000000u
N#define  DEF_BIT_47                       0x0000800000000000u
N
N#define  DEF_BIT_48                       0x0001000000000000u
N#define  DEF_BIT_49                       0x0002000000000000u
N#define  DEF_BIT_50                       0x0004000000000000u
N#define  DEF_BIT_51                       0x0008000000000000u
N#define  DEF_BIT_52                       0x0010000000000000u
N#define  DEF_BIT_53                       0x0020000000000000u
N#define  DEF_BIT_54                       0x0040000000000000u
N#define  DEF_BIT_55                       0x0080000000000000u
N
N#define  DEF_BIT_56                       0x0100000000000000u
N#define  DEF_BIT_57                       0x0200000000000000u
N#define  DEF_BIT_58                       0x0400000000000000u
N#define  DEF_BIT_59                       0x0800000000000000u
N#define  DEF_BIT_60                       0x1000000000000000u
N#define  DEF_BIT_61                       0x2000000000000000u
N#define  DEF_BIT_62                       0x4000000000000000u
N#define  DEF_BIT_63                       0x8000000000000000u
N
N
N                                                                /* ------------------ ALIGN DEFINES ------------------- */
N#define  DEF_ALIGN_MAX_NBR_OCTETS                       4096u
N
N
N                                                                /* ------------------ OCTET DEFINES ------------------- */
N#define  DEF_OCTET_NBR_BITS                                8u
N#define  DEF_OCTET_MASK                                 0xFFu
N
N#define  DEF_OCTET_TO_BIT_NBR_BITS                         3u
N#define  DEF_OCTET_TO_BIT_SHIFT                          DEF_OCTET_TO_BIT_NBR_BITS
N#define  DEF_OCTET_TO_BIT_MASK                          0x07u
N
N
N#define  DEF_NIBBLE_NBR_BITS                               4u
N#define  DEF_NIBBLE_MASK                                0x0Fu
N
N
N                                                                /* --------------- NUMBER BASE DEFINES ---------------- */
N#define  DEF_NBR_BASE_BIN                                  2u
N#define  DEF_NBR_BASE_OCT                                  8u
N#define  DEF_NBR_BASE_DEC                                 10u
N#define  DEF_NBR_BASE_HEX                                 16u
N
N
N/*$PAGE*/
N                                                                /* ----------------- INTEGER DEFINES ------------------ */
N#define  DEF_INT_08_NBR_BITS                               8u
N#define  DEF_INT_08_MASK                                0xFFu
N
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                  (-127)
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N#define  DEF_INT_08S_MIN_VAL                            (DEF_INT_08S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_08S_MAX_VAL                             DEF_INT_08S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_08U_NBR_DIG_MIN                           1u
N#define  DEF_INT_08U_NBR_DIG_MAX                           3u
N
N#define  DEF_INT_08S_NBR_DIG_MIN                           3u
N#define  DEF_INT_08S_NBR_DIG_MAX                           3u
N
N
N
N#define  DEF_INT_16_NBR_BITS                              16u
N#define  DEF_INT_16_MASK                              0xFFFFu
N
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                (-32767)
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N#define  DEF_INT_16S_MIN_VAL                            (DEF_INT_16S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_16S_MAX_VAL                             DEF_INT_16S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_16U_NBR_DIG_MIN                           1u
N#define  DEF_INT_16U_NBR_DIG_MAX                           5u
N
N#define  DEF_INT_16S_NBR_DIG_MIN                           5u
N#define  DEF_INT_16S_NBR_DIG_MAX                           5u
N
N
N
N#define  DEF_INT_32_NBR_BITS                              32u
N#define  DEF_INT_32_MASK                          0xFFFFFFFFu
N
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL           (-2147483647)
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N#define  DEF_INT_32S_MIN_VAL                            (DEF_INT_32S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_32S_MAX_VAL                             DEF_INT_32S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_32U_NBR_DIG_MIN                           1u
N#define  DEF_INT_32U_NBR_DIG_MAX                          10u
N
N#define  DEF_INT_32S_NBR_DIG_MIN                          10u
N#define  DEF_INT_32S_NBR_DIG_MAX                          10u
N
N
N
N#define  DEF_INT_64_NBR_BITS                              64u
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFFu
N
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL  (-9223372036854775807)
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL                            (DEF_INT_64S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_64S_MAX_VAL                             DEF_INT_64S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_64U_NBR_DIG_MIN                           1u
N#define  DEF_INT_64U_NBR_DIG_MAX                          20u
N
N#define  DEF_INT_64S_NBR_DIG_MIN                          19u
N#define  DEF_INT_64S_NBR_DIG_MAX                          19u
N
N
N
N/*$PAGE*/
N                                                                /* --------------- CPU INTEGER DEFINES ---------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE     * DEF_OCTET_NBR_BITS)
N#define  DEF_INT_CPU_NBR_BITS_MAX                       (CPU_CFG_DATA_SIZE_MAX * DEF_OCTET_NBR_BITS)
N
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4 * 8u) == 8u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4 * 8u) == 16u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4 * 8u) == 32u)
N
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S
S
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N
N/*$PAGE*/
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_DAY_PER_WK                           7u
N#define  DEF_TIME_NBR_DAY_PER_YR                         365u
N#define  DEF_TIME_NBR_DAY_PER_YR_LEAP                    366u
N
N#define  DEF_TIME_NBR_HR_PER_DAY                          24u
N#define  DEF_TIME_NBR_HR_PER_WK                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_HR_PER_YR                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_HR_PER_YR_LEAP                    (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60u
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_MIN_PER_WK                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_MIN_PER_YR                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_MIN_PER_YR_LEAP                   (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60u
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR     )
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_SEC_PER_WK                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_SEC_PER_YR                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_SEC_PER_YR_LEAP                   (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000u
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000u
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000u
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All library error codes are #define'd in 'lib_def.h';
N*********************************************************************************************************
N*/
N
Ntypedef enum lib_err {
N
N    LIB_ERR_NONE                            =         0u,
N
N    LIB_MEM_ERR_NONE                        =     10000u,
N    LIB_MEM_ERR_NULL_PTR                    =     10001u,       /* Ptr arg(s) passed NULL ptr(s).                       */
N
N    LIB_MEM_ERR_INVALID_MEM_SIZE            =     10100u,       /* Invalid mem     size.                                */
N    LIB_MEM_ERR_INVALID_MEM_ALIGN           =     10101u,       /* Invalid mem     align.                               */
N    LIB_MEM_ERR_INVALID_SEG_SIZE            =     10110u,       /* Invalid mem seg size.                                */
N    LIB_MEM_ERR_INVALID_SEG_OVERLAP         =     10111u,       /* Invalid mem seg overlaps other mem seg(s).           */
N    LIB_MEM_ERR_INVALID_POOL                =     10120u,       /* Invalid mem pool.                                    */
N    LIB_MEM_ERR_INVALID_BLK_NBR             =     10130u,       /* Invalid mem pool blk nbr.                            */
N    LIB_MEM_ERR_INVALID_BLK_SIZE            =     10131u,       /* Invalid mem pool blk size.                           */
N    LIB_MEM_ERR_INVALID_BLK_ALIGN           =     10132u,       /* Invalid mem pool blk align.                          */
N    LIB_MEM_ERR_INVALID_BLK_IX              =     10133u,       /* Invalid mem pool ix.                                 */
N    LIB_MEM_ERR_INVALID_BLK_ADDR            =     10135u,       /* Invalid mem pool blk addr.                           */
N    LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL    =     10136u,       /* Mem pool blk addr already in mem pool.               */
N
N    LIB_MEM_ERR_SEG_EMPTY                   =     10200u,       /* Mem seg  empty; i.e. NO avail mem in seg.            */
N    LIB_MEM_ERR_SEG_OVF                     =     10201u,       /* Mem seg  ovf;   i.e. req'd mem ovfs rem mem in seg.  */
N    LIB_MEM_ERR_POOL_FULL                   =     10205u,       /* Mem pool full;  i.e. all mem blks avail in mem pool. */
N    LIB_MEM_ERR_POOL_EMPTY                  =     10206u,       /* Mem pool empty; i.e. NO  mem blks avail in mem pool. */
N
N    LIB_MEM_ERR_HEAP_EMPTY                  =     10210u,       /* Heap seg empty; i.e. NO avail mem in heap.           */
N    LIB_MEM_ERR_HEAP_OVF                    =     10211u,       /* Heap seg ovf;   i.e. req'd mem ovfs rem mem in heap. */
N    LIB_MEM_ERR_HEAP_NOT_FOUND              =     10215u        /* Heap seg NOT found.                                  */
N
N} LIB_ERR;
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               TRACING
N*********************************************************************************************************
N*/
N
N                                                                /* Trace level, default to TRACE_LEVEL_OFF.             */
N#ifndef  TRACE_LEVEL_OFF
N#define  TRACE_LEVEL_OFF                                   0u
N#endif
N
N#ifndef  TRACE_LEVEL_INFO
N#define  TRACE_LEVEL_INFO                                  1u
N#endif
N
N#ifndef  TRACE_LEVEL_DBG
N#define  TRACE_LEVEL_DBG                                   2u
N#endif
N
N#ifndef  TRACE_LEVEL_LOG
N#define  TRACE_LEVEL_LOG                                   3u
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative 
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                                                   (1u << (bit))
N
N
N/*
N*********************************************************************************************************
N*                                             DEF_BITxx()
N*
N* Description : Create bit mask of specified bit size with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative 
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is cast to specified integer data type size.
N*
N*               (3) Ideally, DEF_BITxx() macro's should be named DEF_BIT_xx(); however, these names already 
N*                   previously-released for bit constant #define's (see 'STANDARD DEFINES  BIT DEFINES').
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT08(bit)                        ((CPU_INT08U)((CPU_INT08U)1u  << (bit)))
N
N#define  DEF_BIT16(bit)                        ((CPU_INT16U)((CPU_INT16U)1u  << (bit)))
N
N#define  DEF_BIT32(bit)                        ((CPU_INT32U)((CPU_INT32U)1u  << (bit)))
N
N#define  DEF_BIT64(bit)                        ((CPU_INT64U)((CPU_INT64U)1u  << (bit)))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)                                     ((bit_mask) << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_MASK_xx()
N*
N* Description : Shift a bit mask of specified bit size.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK_08(bit_mask, bit_shift)         ((CPU_INT08U)((CPU_INT08U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_16(bit_mask, bit_shift)         ((CPU_INT16U)((CPU_INT16U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_32(bit_mask, bit_shift)         ((CPU_INT32U)((CPU_INT32U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_64(bit_mask, bit_shift)         ((CPU_INT64U)((CPU_INT64U)(bit_mask) << (bit_shift)))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler 
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate 
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is suffixed with 'L'ong integer modifier.
N*
N*                       This may still be insufficient for CPUs &/or compilers that support 'long long' 
N*                       integer data types, in which case 'LL' integer modifier should be suffixed.  
N*                       However, since almost all 16- & 32-bit CPUs & compilers support 'long' integer 
N*                       data types but many may NOT support 'long long' integer data types, only 'long' 
N*                       integer data types & modifiers are supported.
N*
N*                       See also 'DEF_BIT_FIELD_xx()  Note #1b'.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)     \
N                                                                                                                     : (DEF_BIT(bit_field) - 1uL)) \
N                                                                                                                            << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                                          : (DEF_BIT(bit_field) - 1uL))                                                                                                                             << (bit_shift))
N
N/*
N*********************************************************************************************************
N*                                         DEF_BIT_FIELD_xx()
N*
N* Description : Create & shift a contiguous bit field of specified bit size.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler 
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate 
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is cast to specified integer data type size.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                                                                                                                                                    : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                                                                                                                                                    : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                                                                                                                                                    : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                                                                                                                                                    : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u))                                                                                                                                                      << (bit_shift)))
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_SET_xx()
N*
N* Description : Set specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET_08(val, mask)                     ((val) = (CPU_INT08U)(((CPU_INT08U)(val)) | ((CPU_INT08U) (mask))))
N
N#define  DEF_BIT_SET_16(val, mask)                     ((val) = (CPU_INT16U)(((CPU_INT16U)(val)) | ((CPU_INT16U) (mask))))
N
N#define  DEF_BIT_SET_32(val, mask)                     ((val) = (CPU_INT32U)(((CPU_INT32U)(val)) | ((CPU_INT32U) (mask))))
N
N#define  DEF_BIT_SET_64(val, mask)                     ((val) = (CPU_INT64U)(((CPU_INT64U)(val)) | ((CPU_INT64U) (mask))))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :   \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) : 0))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                   ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) : 0)))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_SET_64(val, mask) : 0))))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_SET_64(val, mask) : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_CLR_xx()
N*
N* Description : Clear specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_CLR_08(val, mask)                     ((val) = (CPU_INT08U)(((CPU_INT08U)(val)) & ((CPU_INT08U)~(mask))))
N
N#define  DEF_BIT_CLR_16(val, mask)                     ((val) = (CPU_INT16U)(((CPU_INT16U)(val)) & ((CPU_INT16U)~(mask))))
N
N#define  DEF_BIT_CLR_32(val, mask)                     ((val) = (CPU_INT32U)(((CPU_INT32U)(val)) & ((CPU_INT32U)~(mask))))
N
N#define  DEF_BIT_CLR_64(val, mask)                     ((val) = (CPU_INT64U)(((CPU_INT64U)(val)) & ((CPU_INT64U)~(mask))))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :   \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                   ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                           ((((mask)  !=  0u)  && \
N                                                      (((val) & (mask)) == (mask))) ? (DEF_YES) : (DEF_NO ))
X#define  DEF_BIT_IS_SET(val, mask)                           ((((mask)  !=  0u)  &&                                                       (((val) & (mask)) == (mask))) ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                           ((((mask)  !=  0u)  && \
N                                                      (((val) & (mask)) ==  0u))    ? (DEF_YES) : (DEF_NO ))
X#define  DEF_BIT_IS_CLR(val, mask)                           ((((mask)  !=  0u)  &&                                                       (((val) & (mask)) ==  0u))    ? (DEF_YES) : (DEF_NO ))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)               ((((val) & (mask)) ==  0u)     ? (DEF_NO ) : (DEF_YES))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) == (mask))  ? (DEF_NO ) : (DEF_YES))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            VALUE MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MIN()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MIN() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_min' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) && \
N                                                     ((((val_min) >= 1) && ((val)     < 1))  || \
N                                                       ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) &&                                                      ((((val_min) >= 1) && ((val)     < 1))  ||                                                        ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MAX()
N*
N* Description : Validate a value as less than or equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is less than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MAX() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_max' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) && \
N                                                     ((((val)     >= 1) && ((val_max) < 1))  || \
N                                                       ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) &&                                                      ((((val)     >= 1) && ((val_max) < 1))  ||                                                        ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DEF_CHK_VAL()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value & less than or 
N*                   equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value AND 
N*                                   less    than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) DEF_CHK_VAL() does NOT validate that the maximum value ('val_max') is greater than 
N*                   or equal to the minimum value ('val_min').
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN(val, val_min) == DEF_FAIL) ||                  \
N                                                       (DEF_CHK_VAL_MAX(val, val_max) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN(val, val_min) == DEF_FAIL) ||                                                                         (DEF_CHK_VAL_MAX(val, val_max) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         DEF_GET_U_MAX_VAL()
N*
N* Description : Get the maximum unsigned value that can be represented in an unsigned integer variable 
N*                   of the same data type size as an object.
N*
N* Argument(s) : obj         Object or data type to return maximum unsigned value (see Note #1).
N*
N* Return(s)   : Maximum unsigned integer value that can be represented by the object, if NO error(s).
N*
N*               0,                                                                    otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'obj' SHOULD be an integer object or data type but COULD also be a character or 
N*                   pointer object or data type.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :   \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                   ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*
N* Note(s) : (1) Ideally, ALL mathematical macro's & functions SHOULD be defined in the custom mathematics 
N*               library ('lib_math.*').  #### However, to maintain backwards compatibility with previously-
N*               released modules, mathematical macro & function definitions should only be moved to the 
N*               custom mathematics library once all previously-released modules are updated to include the 
N*               custom mathematics library.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'lib_def.h  Note #1a'.                           */
N#if     (CPU_CORE_VERSION < 12900u)
X#if     (12901u < 12900u)
S#error  "CPU_CORE_VERSION  [SHOULD be >= V1.29.00]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 158 "..\..\uCOS-III\uC-LIB\lib_str.h" 2
N#include  <lib_ascii.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_ascii.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     ASCII CHARACTER OPERATIONS
N*
N* Filename      : lib_ascii.h
N* Version       : V1.37.01
N* Programmer(s) : BAN
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*
N*                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
N*                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
N*
N*                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
N*                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
N*                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
N*                             All other characters are explicitly specified.
N*
N*                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
N*                             in the 7-bit character set.
N*
N*                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
N*                             standard in specified ways.
N*
N*                     (b) The character set represented in this file reproduces the Internation Reference
N*                         Version.  This is identical to the 7-bit character set which occupies Unicode
N*                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
N*                         Unicode specification, with certain abbreviations so that the resulting #define
N*                         names will not violate ANSI C naming restriction :
N*
N*                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
N*                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This ASCII library header file is protected from multiple pre-processor inclusion through 
N*               use of the ASCII library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_ASCII_MODULE_PRESENT                               /* See Note #1.                                         */
N#define  LIB_ASCII_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <lib_def.h>
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_ASCII_MODULE
S#define  LIB_ASCII_EXT
N#else
N#define  LIB_ASCII_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         ASCII CHARACTER DEFINES
N*********************************************************************************************************
N*/
N
N                                                                /* -------------------- C0 CONTROLS ------------------- */
N#define  ASCII_CHAR_NULL                                0x00    /* '\0'                                                 */
N#define  ASCII_CHAR_START_OF_HEADING                    0x01
N#define  ASCII_CHAR_START_OF_TEXT                       0x02
N#define  ASCII_CHAR_END_OF_TEXT                         0x03
N#define  ASCII_CHAR_END_OF_TRANSMISSION                 0x04
N#define  ASCII_CHAR_ENQUIRY                             0x05
N#define  ASCII_CHAR_ACKNOWLEDGE                         0x06
N#define  ASCII_CHAR_BELL                                0x07    /* '\a'                                                 */
N#define  ASCII_CHAR_BACKSPACE                           0x08    /* '\b'                                                 */
N#define  ASCII_CHAR_CHARACTER_TABULATION                0x09    /* '\t'                                                 */
N#define  ASCII_CHAR_LINE_FEED                           0x0A    /* '\n'                                                 */
N#define  ASCII_CHAR_LINE_TABULATION                     0x0B    /* '\v'                                                 */
N#define  ASCII_CHAR_FORM_FEED                           0x0C    /* '\f'                                                 */
N#define  ASCII_CHAR_CARRIAGE_RETURN                     0x0D    /* '\r'                                                 */
N#define  ASCII_CHAR_SHIFT_OUT                           0x0E
N#define  ASCII_CHAR_SHIFT_IN                            0x0F
N#define  ASCII_CHAR_DATA_LINK_ESCAPE                    0x10
N#define  ASCII_CHAR_DEVICE_CONTROL_ONE                  0x11
N#define  ASCII_CHAR_DEVICE_CONTROL_TWO                  0x12
N#define  ASCII_CHAR_DEVICE_CONTROL_THREE                0x13
N#define  ASCII_CHAR_DEVICE_CONTROL_FOUR                 0x14
N#define  ASCII_CHAR_NEGATIVE_ACKNOWLEDGE                0x15
N#define  ASCII_CHAR_SYNCHRONOUS_IDLE                    0x16
N#define  ASCII_CHAR_END_OF_TRANSMISSION_BLOCK           0x17
N#define  ASCII_CHAR_CANCEL                              0x18
N#define  ASCII_CHAR_END_OF_MEDIUM                       0x19
N#define  ASCII_CHAR_SUBSITUTE                           0x1A
N#define  ASCII_CHAR_ESCAPE                              0x1B
N#define  ASCII_CHAR_INFO_SEPARATOR_FOUR                 0x1C
N#define  ASCII_CHAR_INFO_SEPARATOR_THREE                0x1D
N#define  ASCII_CHAR_INFO_SEPARATOR_TWO                  0x1E
N#define  ASCII_CHAR_INFO_SEPARATOR_ONE                  0x1F
N
N#define  ASCII_CHAR_NUL                                 ASCII_CHAR_NULL
N#define  ASCII_CHAR_SOH                                 ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_START_HEADING                       ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_STX                                 ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_START_TEXT                          ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_ETX                                 ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_END_TEXT                            ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_EOT                                 ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_END_TRANSMISSION                    ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_ENQ                                 ASCII_CHAR_ENQUIRY
N#define  ASCII_CHAR_ACK                                 ASCII_CHAR_ACKNOWLEDGE
N#define  ASCII_CHAR_BEL                                 ASCII_CHAR_BELL
N#define  ASCII_CHAR_BS                                  ASCII_CHAR_BACKSPACE
N#define  ASCII_CHAR_HT                                  ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_TAB                                 ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_LF                                  ASCII_CHAR_LINE_FEED
N#define  ASCII_CHAR_VT                                  ASCII_CHAR_LINE_TABULATION
N#define  ASCII_CHAR_FF                                  ASCII_CHAR_FORM_FEED
N#define  ASCII_CHAR_CR                                  ASCII_CHAR_CARRIAGE_RETURN
N#define  ASCII_CHAR_SO                                  ASCII_CHAR_SHIFT_OUT
N#define  ASCII_CHAR_SI                                  ASCII_CHAR_SHIFT_IN
N#define  ASCII_CHAR_DLE                                 ASCII_CHAR_DATA_LINK_ESCAPE
N#define  ASCII_CHAR_DC1                                 ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DC2                                 ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DC3                                 ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DC4                                 ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_DEV_CTRL_ONE                        ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DEV_CTRL_TWO                        ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DEV_CTRL_THREE                      ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DEV_CTRL_FOUR                       ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_NAK                                 ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_NEG_ACK                             ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_SYN                                 ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_SYNC_IDLE                           ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_ETB                                 ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_END_TRANSMISSION_BLK                ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_CAN                                 ASCII_CHAR_CANCEL
N#define  ASCII_CHAR_EM                                  ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_END_MEDIUM                          ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_SUB                                 ASCII_CHAR_SUBSITUTE
N#define  ASCII_CHAR_ESC                                 ASCII_CHAR_ESCAPE
N#define  ASCII_CHAR_IS1                                 ASCII_CHAR_INFO_SEPARATOR_ONE
N#define  ASCII_CHAR_IS2                                 ASCII_CHAR_INFO_SEPARATOR_TWO
N#define  ASCII_CHAR_IS3                                 ASCII_CHAR_INFO_SEPARATOR_THREE
N#define  ASCII_CHAR_IS4                                 ASCII_CHAR_INFO_SEPARATOR_FOUR
N
N
N/*$PAGE*/
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_SPACE                               0x20    /* ' '                                                  */
N#define  ASCII_CHAR_EXCLAMATION_MARK                    0x21    /* '!'                                                  */
N#define  ASCII_CHAR_QUOTATION_MARK                      0x22    /* '\"'                                                 */
N#define  ASCII_CHAR_NUMBER_SIGN                         0x23    /* '#'                                                  */
N#define  ASCII_CHAR_DOLLAR_SIGN                         0x24    /* '$'                                                  */
N#define  ASCII_CHAR_PERCENTAGE_SIGN                     0x25    /* '%'                                                  */
N#define  ASCII_CHAR_AMPERSAND                           0x26    /* '&'                                                  */
N#define  ASCII_CHAR_APOSTROPHE                          0x27    /* '\''                                                 */
N#define  ASCII_CHAR_LEFT_PARENTHESIS                    0x28    /* '('                                                  */
N#define  ASCII_CHAR_RIGHT_PARENTHESIS                   0x29    /* ')'                                                  */
N#define  ASCII_CHAR_ASTERISK                            0x2A    /* '*'                                                  */
N#define  ASCII_CHAR_PLUS_SIGN                           0x2B    /* '+'                                                  */
N#define  ASCII_CHAR_COMMA                               0x2C    /* ','                                                  */
N#define  ASCII_CHAR_HYPHEN_MINUS                        0x2D    /* '-'                                                  */
N#define  ASCII_CHAR_FULL_STOP                           0x2E    /* '.'                                                  */
N#define  ASCII_CHAR_SOLIDUS                             0x2F    /* '/'                                                  */
N
N#define  ASCII_CHAR_PAREN_LEFT                          ASCII_CHAR_LEFT_PARENTHESIS
N#define  ASCII_CHAR_PAREN_RIGHT                         ASCII_CHAR_RIGHT_PARENTHESIS
N
N
N                                                                /* ------------------- ASCII DIGITS ------------------- */
N#define  ASCII_CHAR_DIGIT_ZERO                          0x30    /* '0'                                                  */
N#define  ASCII_CHAR_DIGIT_ONE                           0x31    /* '1'                                                  */
N#define  ASCII_CHAR_DIGIT_TWO                           0x32    /* '2'                                                  */
N#define  ASCII_CHAR_DIGIT_THREE                         0x33    /* '3'                                                  */
N#define  ASCII_CHAR_DIGIT_FOUR                          0x34    /* '4'                                                  */
N#define  ASCII_CHAR_DIGIT_FIVE                          0x35    /* '5'                                                  */
N#define  ASCII_CHAR_DIGIT_SIX                           0x36    /* '6'                                                  */
N#define  ASCII_CHAR_DIGIT_SEVEN                         0x37    /* '7'                                                  */
N#define  ASCII_CHAR_DIGIT_EIGHT                         0x38    /* '8'                                                  */
N#define  ASCII_CHAR_DIGIT_NINE                          0x39    /* '9'                                                  */
N
N#define  ASCII_CHAR_DIG_ZERO                            ASCII_CHAR_DIGIT_ZERO
N#define  ASCII_CHAR_DIG_ONE                             ASCII_CHAR_DIGIT_ONE
N#define  ASCII_CHAR_DIG_TWO                             ASCII_CHAR_DIGIT_TWO
N#define  ASCII_CHAR_DIG_THREE                           ASCII_CHAR_DIGIT_THREE
N#define  ASCII_CHAR_DIG_FOUR                            ASCII_CHAR_DIGIT_FOUR
N#define  ASCII_CHAR_DIG_FIVE                            ASCII_CHAR_DIGIT_FIVE
N#define  ASCII_CHAR_DIG_SIX                             ASCII_CHAR_DIGIT_SIX
N#define  ASCII_CHAR_DIG_SEVEN                           ASCII_CHAR_DIGIT_SEVEN
N#define  ASCII_CHAR_DIG_EIGHT                           ASCII_CHAR_DIGIT_EIGHT
N#define  ASCII_CHAR_DIG_NINE                            ASCII_CHAR_DIGIT_NINE
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_COLON                               0x3A    /* ':'                                                  */
N#define  ASCII_CHAR_SEMICOLON                           0x3B    /* ';'                                                  */
N#define  ASCII_CHAR_LESS_THAN_SIGN                      0x3C    /* '<'                                                  */
N#define  ASCII_CHAR_EQUALS_SIGN                         0x3D    /* '='                                                  */
N#define  ASCII_CHAR_GREATER_THAN_SIGN                   0x3E    /* '>'                                                  */
N#define  ASCII_CHAR_QUESTION_MARK                       0x3F    /* '\?'                                                 */
N#define  ASCII_CHAR_COMMERCIAL_AT                       0x40    /* '@'                                                  */
N
N#define  ASCII_CHAR_AT_SIGN                             ASCII_CHAR_COMMERCIAL_AT
N
N
N/*$PAGE*/
N                                                                /* ------------- UPPERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_UPPER_A                       0x41    /* 'A'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_B                       0x42    /* 'B'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_C                       0x43    /* 'C'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_D                       0x44    /* 'D'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_E                       0x45    /* 'E'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_F                       0x46    /* 'F'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_G                       0x47    /* 'G'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_H                       0x48    /* 'H'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_I                       0x49    /* 'I'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_J                       0x4A    /* 'J'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_K                       0x4B    /* 'K'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_L                       0x4C    /* 'L'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_M                       0x4D    /* 'M'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_N                       0x4E    /* 'N'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_O                       0x4F    /* 'O'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_P                       0x50    /* 'P'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Q                       0x51    /* 'Q'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_R                       0x52    /* 'R'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_S                       0x53    /* 'S'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_T                       0x54    /* 'T'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_U                       0x55    /* 'U'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_V                       0x56    /* 'V'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_W                       0x57    /* 'W'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_X                       0x58    /* 'X'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Y                       0x59    /* 'Y'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Z                       0x5A    /* 'Z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_SQUARE_BRACKET                 0x5B    /* '['                                                  */
N#define  ASCII_CHAR_REVERSE_SOLIDUS                     0x5C    /* '\\'                                                 */
N#define  ASCII_CHAR_RIGHT_SQUARE_BRACKET                0x5D    /* ']'                                                  */
N#define  ASCII_CHAR_CIRCUMFLEX_ACCENT                   0x5E    /* '^'                                                  */
N#define  ASCII_CHAR_LOW_LINE                            0x5F    /* '_'                                                  */
N#define  ASCII_CHAR_GRAVE_ACCENT                        0x60    /* '`'                                                  */
N
N#define  ASCII_CHAR_BRACKET_SQUARE_LEFT                 ASCII_CHAR_LEFT_SQUARE_BRACKET
N#define  ASCII_CHAR_BRACKET_SQUARE_RIGHT                ASCII_CHAR_RIGHT_SQUARE_BRACKET
N
N
N                                                                /* ------------- LOWERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_LOWER_A                       0x61    /* 'a'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_B                       0x62    /* 'b'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_C                       0x63    /* 'c'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_D                       0x64    /* 'd'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_E                       0x65    /* 'e'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_F                       0x66    /* 'f'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_G                       0x67    /* 'g'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_H                       0x68    /* 'h'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_I                       0x69    /* 'i'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_J                       0x6A    /* 'j'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_K                       0x6B    /* 'k'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_L                       0x6C    /* 'l'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_M                       0x6D    /* 'm'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_N                       0x6E    /* 'n'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_O                       0x6F    /* 'o'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_P                       0x70    /* 'p'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Q                       0x71    /* 'q'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_R                       0x72    /* 'r'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_S                       0x73    /* 's'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_T                       0x74    /* 't'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_U                       0x75    /* 'u'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_V                       0x76    /* 'v'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_W                       0x77    /* 'w'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_X                       0x78    /* 'x'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Y                       0x79    /* 'y'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Z                       0x7A    /* 'z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_CURLY_BRACKET                  0x7B    /* '{'                                                  */
N#define  ASCII_CHAR_VERTICAL_LINE                       0x7C    /* '|'                                                  */
N#define  ASCII_CHAR_RIGHT_CURLY_BRACKET                 0x7D    /* '}'                                                  */
N#define  ASCII_CHAR_TILDE                               0x7E    /* '~'                                                  */
N
N#define  ASCII_CHAR_BRACKET_CURLY_LEFT                  ASCII_CHAR_LEFT_CURLY_BRACKET
N#define  ASCII_CHAR_BRACKET_CURLY_RIGHT                 ASCII_CHAR_RIGHT_CURLY_BRACKET
N
N
N                                                                /* ---------------- CONTROL CHARACTERS ---------------- */
N#define  ASCII_CHAR_DELETE                              0x7F
N
N#define  ASCII_CHAR_DEL                                 ASCII_CHAR_DELETE
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                               ASCII CHARACTER CLASSIFICATION MACRO's
N*
N* Note(s) : (1) ISO/IEC 9899:TC2, Section 7.4.1.(1) states that "character classification functions ...
N*               return nonzero (true) if and only if the value of the argument 'c' conforms to ... the
N*               description of the function."
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_DIG()
N*
N* Description : Determine whether a character is a decimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a decimal-digit character.
N*
N*               DEF_NO,	 if character is NOT a decimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
N*                   decimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG(c)               ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_NINE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_OCT()
N*
N* Description : Determine whether a character is an octal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an octal-digit character.
N*
N*               DEF_NO,	 if character is NOT an octal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_OCT(c)          ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_SEVEN)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_HEX()
N*
N* Description : Determine whether a character is a hexadecimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
N*
N*               DEF_NO,	 if character is NOT a hexadecimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
N*                   hexadecimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) || \
N                                        (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) || \
N                                        (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) ||                                         (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) ||                                         (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_LOWER()
N*
N* Description : Determine whether a character is a lowercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
N*
N*               DEF_NO,	 if character is NOT a lowercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
N*                   the lowercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_LOWER(c)             ((((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_UPPER()
N*
N* Description : Determine whether a character is an uppercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
N*
N*               DEF_NO,	 if character is NOT an uppercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
N*                   the uppercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_UPPER(c)             ((((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_ALPHA()
N*
N* Description : Determine whether a character is an alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphabetic character.
N*
N*               DEF_NO,	 if character is NOT an alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
N*                   characters for which isupper() or islower() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) || \
N                                         ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) ||                                          ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                        ASCII_IS_ALPHA_NUM()
N*
N* Description : Determine whether a character is an alphanumeric character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphanumeric character.
N*
N*               DEF_NO,	 if character is NOT an alphanumeric character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
N*                   for which isalpha() or isdigit() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) || \
N                                         ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) ||                                          ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_BLANK()
N*
N* Description : Determine whether a character is a standard blank character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a standard blank character.
N*
N*               DEF_NO,	 if character is NOT a standard blank character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
N*                       the standard blank characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
N*                       the "space (' '), and horizontal tab ('\t')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_BLANK(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_HT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_SPACE()
N*
N* Description : Determine whether a character is a white-space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a white-space character.
N*
N*               DEF_NO,	 if character is NOT a white-space character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
N*                       for the standard white-space characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
N*                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
N*                       horizontal tab ('\t'), and vertical tab ('\v')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) || \
N                                         ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) || \
N                                         ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) ||                                          ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) ||                                          ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PRINT()
N*
N* Description : Determine whether a character is a printing character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a printing character.
N*
N*               DEF_NO,	 if character is NOT a printing character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
N*                       printing character including space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PRINT(c)             ((((c) >= ASCII_CHAR_SPACE) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_GRAPH()
N*
N* Description : Determine whether a character is any printing character except a space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a graphic character.
N*
N*               DEF_NO,	 if character is NOT a graphic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
N*                       printing character except space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_GRAPH(c)             ((((c) >= ASCII_CHAR_EXCLAMATION_MARK) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PUNCT()
N*
N* Description : Determine whether a character is a punctuation character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a punctuation character.
N*
N*               DEF_NO,	 if character is NOT a punctuation character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
N*                   printing character for which neither isspace() nor isalnum() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) && \
N                                         ((ASCII_IS_SPACE(c)) == DEF_NO ) && \
N                                         ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) &&                                          ((ASCII_IS_SPACE(c)) == DEF_NO ) &&                                          ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_CTRL()
N*
N* Description : Determine whether a character is a control character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a control character.
N*
N*               DEF_NO,	 if character is NOT a control character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
N*                       control character".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, ... the control characters are those whose values lie from
N*                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) || \
N                                                                                   ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) ||                                                                                    ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                ASCII CHARACTER CASE MAPPING MACRO's
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_LOWER()
N*
N* Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                  (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
N*                       uppercase letter to a corresponding lowercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which isupper() is true and there are
N*                                one or more corresponding characters ... for which islower() is true," ...
N*                           (B) "tolower() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_LOWER(c)              (((ASCII_IS_UPPER(c)) == DEF_YES) ? ((c) + (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_UPPER()
N*
N* Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                 (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
N*                       lowercase letter to a corresponding uppercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which islower() is true and there are
N*                                one or more corresponding characters ... for which isupper() is true," ...
N*                           (B) "toupper() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_UPPER(c)              (((ASCII_IS_LOWER(c)) == DEF_YES) ? ((c) - (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
NCPU_BOOLEAN  ASCII_IsAlpha   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsAlphaNum(CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsLower   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsUpper   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDig     (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigOct  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigHex  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsBlank   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsSpace   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPrint   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsGraph   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPunct   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsCtrl    (CPU_CHAR  c);
N
N
NCPU_CHAR     ASCII_ToLower   (CPU_CHAR  c);
N
NCPU_CHAR     ASCII_ToUpper   (CPU_CHAR  c);
N
N
NCPU_BOOLEAN  ASCII_Cmp       (CPU_CHAR  c1,
N                              CPU_CHAR  c2);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_ascii.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib ascii module include.                     */
N
L 159 "..\..\uCOS-III\uC-LIB\lib_str.h" 2
N
N#include  <lib_cfg.h>
L 1 "..\..\User\lib_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                  CUSTOM LIBRARY CONFIGURATION FILE
N*
N*                                     ST Microelectronics STM32
N*                                              on the
N*
N*                                           STM3240G-EVAL
N*                                         Evaluation Board
N*
N* Filename      : lib_cfg.h
N* Version       : V1.35.00
N* Programmer(s) : DC
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_CFG_MODULE_PRESENT
N#define  LIB_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          uC/LIB CONFIGURATION
N*********************************************************************************************************
N*/
N
N#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_ENABLED
N                                                        /*   DEF_DISABLED     Argument check DISABLED                   */
N                                                        /*   DEF_ENABLED      Argument check ENABLED                    */
N
N#define  LIB_MEM_CFG_OPTIMIZE_ASM_EN    DEF_ENABLED
N                                                        /*   DEF_DISABLED     Assembly-optimized function(s) DISABLED   */
N                                                        /*   DEF_ENABLED      Assembly-optimized function(s) ENABLED    */
N
N#define  LIB_MEM_CFG_ALLOC_EN           DEF_ENABLED
N                                                        /*   DEF_DISABLED     Memory allocation DISABLED                */
N                                                        /*   DEF_ENABLED      Memory allocation ENABLED                 */
N
N
N#define  LIB_MEM_CFG_HEAP_SIZE          23u * 1024u     /* Configure Heap Memory Size                                   */
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                  /* End of lib cfg module include.                               */
N
L 161 "..\..\uCOS-III\uC-LIB\lib_str.h" 2
N
N#if 0                                                           /* See Note #4.                                         */
S#include  <stdio.h>
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_STR_MODULE
N#define  LIB_STR_EXT
N#else
S#define  LIB_STR_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                 STRING FLOATING POINT CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*
N*           (2) Configure LIB_STR_CFG_FP_MAX_NBR_DIG_SIG to configure the maximum number of significant 
N*               digits to calculate &/or display for floating point string function(s).
N*
N*               See also 'STRING FLOATING POINT DEFINES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure floating point feature(s) [see Note #1] :  */
N#ifndef  LIB_STR_CFG_FP_EN
N#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
N                                                                /*   DEF_DISABLED     Floating point functions DISABLED */
N                                                                /*   DEF_ENABLED      Floating point functions ENABLED  */
N#endif
N
N                                                                /* Configure floating point feature(s)' number of ...   */
N                                                                /* ... significant digits (see Note #2).                */
N#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
N#define  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG         LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  STR_CR_LF                     "\r\n"
N#define  STR_LF_CR                     "\n\r"
N#define  STR_NEW_LINE                   STR_CR_LF
N#define  STR_PARENT_PATH               ".."
N
N#define  STR_CR_LF_LEN                 (sizeof(STR_CR_LF)       - 1)
N#define  STR_LF_CR_LEN                 (sizeof(STR_LF_CR)       - 1)
N#define  STR_NEW_LINE_LEN              (sizeof(STR_NEW_LINE)    - 1)
N#define  STR_PARENT_PATH_LEN           (sizeof(STR_PARENT_PATH) - 1)
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      STANDARD LIBRARY MACRO'S
N*
N* Note(s) : (1) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard memory functions SHOULD be removed once all custom library
N*               functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'INCLUDE FILES  Note #3'.
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #1.                                         */
N#define  Str_FmtPrint                   snprintf
N#define  Str_FmtScan                    sscanf
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N                                                                /* ------------------ STR LEN  FNCTS ------------------ */
NCPU_SIZE_T   Str_Len            (const  CPU_CHAR      *pstr);
N
NCPU_SIZE_T   Str_Len_N          (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR COPY FNCTS ------------------ */
NCPU_CHAR    *Str_Copy           (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src);
N
NCPU_CHAR    *Str_Copy_N         (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src,
N                                        CPU_SIZE_T     len_max);
N
N
NCPU_CHAR    *Str_Cat            (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat);
N
NCPU_CHAR    *Str_Cat_N          (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR CMP  FNCTS ------------------ */
NCPU_INT16S   Str_Cmp            (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_Cmp_N          (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
NCPU_INT16S   Str_CmpIgnoreCase  (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_CmpIgnoreCase_N(const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR SRCH FNCTS ------------------ */
NCPU_CHAR    *Str_Char           (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_N         (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last      (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last_N    (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Replace   (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace);
N
NCPU_CHAR    *Str_Char_Replace_N (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace,
N                                        CPU_SIZE_T     len_max);
N
NCPU_CHAR    *Str_Str            (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch);
N
NCPU_CHAR    *Str_Str_N          (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch,
N                                        CPU_SIZE_T     len_max);
N
N
N/*$PAGE*/
N                                                                       /* ------------------ STR FMT  FNCTS ------------------ */
NCPU_CHAR    *Str_FmtNbr_Int32U  (       CPU_INT32U     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
NCPU_CHAR    *Str_FmtNbr_Int32S  (       CPU_INT32S     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
N#if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_CHAR    *Str_FmtNbr_32      (       CPU_FP32       nbr,
S                                        CPU_INT08U     nbr_dig,
S                                        CPU_INT08U     nbr_dp,
S                                        CPU_CHAR       lead_char,
S                                        CPU_BOOLEAN    nul,
S                                        CPU_CHAR      *pstr);
N#endif
N
N
N                                                                       /* ----------------- STR PARSE FNCTS ------------------ */
NCPU_INT32U   Str_ParseNbr_Int32U(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
NCPU_INT32S   Str_ParseNbr_Int32S(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_CFG_FP_EN
S#error  "LIB_STR_CFG_FP_EN                     not #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_STR_CFG_FP_EN != DEF_DISABLED) && \
S        (LIB_STR_CFG_FP_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_STR_CFG_FP_EN               illegally #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S
S#elif   (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#elif   (0u == 1u)
S
S#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG        not #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S
S#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG  illegally #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S#endif
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_str.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib str module include.                       */
N
L 71 "..\..\uCOS-III\uC-LIB\lib_str.c" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            LOCAL DEFINES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           LOCAL CONSTANTS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          LOCAL DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            LOCAL TABLES
N*********************************************************************************************************
N*/
N
Nstatic  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
N   (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
X   (CPU_INT32U) 4294967295u,                 
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
X   (CPU_INT32U)(4294967295u /  1u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
X   (CPU_INT32U)(4294967295u /  2u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
X   (CPU_INT32U)(4294967295u /  3u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
X   (CPU_INT32U)(4294967295u /  4u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
X   (CPU_INT32U)(4294967295u /  5u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
X   (CPU_INT32U)(4294967295u /  6u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
X   (CPU_INT32U)(4294967295u /  7u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
X   (CPU_INT32U)(4294967295u /  8u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
X   (CPU_INT32U)(4294967295u /  9u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
X   (CPU_INT32U)(4294967295u / 10u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
X   (CPU_INT32U)(4294967295u / 11u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
X   (CPU_INT32U)(4294967295u / 12u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
X   (CPU_INT32U)(4294967295u / 13u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
X   (CPU_INT32U)(4294967295u / 14u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
X   (CPU_INT32U)(4294967295u / 15u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
X   (CPU_INT32U)(4294967295u / 16u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
X   (CPU_INT32U)(4294967295u / 17u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
X   (CPU_INT32U)(4294967295u / 18u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
X   (CPU_INT32U)(4294967295u / 19u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
X   (CPU_INT32U)(4294967295u / 20u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
X   (CPU_INT32U)(4294967295u / 21u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
X   (CPU_INT32U)(4294967295u / 22u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
X   (CPU_INT32U)(4294967295u / 23u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
X   (CPU_INT32U)(4294967295u / 24u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
X   (CPU_INT32U)(4294967295u / 25u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
X   (CPU_INT32U)(4294967295u / 26u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
X   (CPU_INT32U)(4294967295u / 27u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
X   (CPU_INT32U)(4294967295u / 28u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
X   (CPU_INT32U)(4294967295u / 29u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
X   (CPU_INT32U)(4294967295u / 30u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
X   (CPU_INT32U)(4294967295u / 31u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
X   (CPU_INT32U)(4294967295u / 32u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
X   (CPU_INT32U)(4294967295u / 33u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
X   (CPU_INT32U)(4294967295u / 34u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
X   (CPU_INT32U)(4294967295u / 35u),          
N   (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
X   (CPU_INT32U)(4294967295u / 36u)           
N};
N
N
N/*
N*********************************************************************************************************
N*                                       LOCAL GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      LOCAL FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nstatic  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
N                                               CPU_INT08U     nbr_dig,
N                                               CPU_INT08U     nbr_base,
N                                               CPU_BOOLEAN    nbr_neg,
N                                               CPU_CHAR       lead_char,
N                                               CPU_BOOLEAN    lower_case,
N                                               CPU_BOOLEAN    nul,
N                                               CPU_CHAR      *pstr);
N
Nstatic  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
N                                               CPU_CHAR     **pstr_next,
N                                               CPU_INT08U     nbr_base,
N                                               CPU_BOOLEAN    nbr_signed,
N                                               CPU_BOOLEAN   *pnbr_neg);
N
N
N/*
N*********************************************************************************************************
N*                                     LOCAL CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Len()
N*
N* Description : Calculate length of a string.
N*
N* Argument(s) : pstr        Pointer to string (see Note #1).
N*
N* Return(s)   : Length of string; number of characters in string before terminating NULL character 
N*                   (see Note #2b1).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
N*
N*                       (1) "The strlen() function shall compute the number of bytes in the string to 
N*                            which 's' ('pstr') points," ...
N*                       (2) "not including the terminating null byte."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
N*
N*                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
N*                       (2) "no return value shall be reserved to indicate an error."
N*
N*               (3) String length calculation terminates when :
N*
N*                   (a) String pointer points to NULL.
N*                       (1) String buffer overlaps with NULL address.
N*                       (2) String length calculated for string up to but NOT beyond or including
N*                           the NULL address.
N*
N*                   (b) Terminating NULL character found.
N*                       (1) String length calculated for string up to but NOT           including
N*                           the NULL character (see Note #2a2).
N*********************************************************************************************************
N*/
N
NCPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
N{
N    CPU_SIZE_T  len;
N
N
N    len = Str_Len_N(pstr,
N                    DEF_INT_CPU_U_MAX_VAL);
X                    4294967295u);
N
N    return (len);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Len_N()
N*
N* Description : Calculate length of a string, up to a maximum number of characters.
N*
N* Argument(s) : pstr        Pointer to string (see Note #1).
N*
N*               len_max     Maximum number of characters to search (see Note #3c).
N*
N* Return(s)   : Length of string; number of characters in string before terminating NULL character, 
N*                   if terminating NULL character     found (see Note #2b1).
N*
N*               Requested maximum number of characters to search, 
N*                   if terminating NULL character NOT found (see Note #3c).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
N*
N*                       (1) "The strlen() function shall compute the number of bytes in the string to 
N*                            which 's' ('pstr') points," ...
N*                       (2) "not including the terminating null byte."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
N*
N*                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
N*                       (2) "no return value shall be reserved to indicate an error."
N*
N*               (3) String length calculation terminates when :
N*
N*                   (a) String pointer points to NULL.
N*                       (1) String buffer overlaps with NULL address.
N*                       (2) String length calculated for string up to but NOT beyond or including
N*                           the NULL address.
N*
N*                   (b) Terminating NULL character found.
N*                       (1) String length calculated for string up to but NOT           including
N*                           the NULL character (see Note #2a2).
N*
N*                   (c) 'len_max' number of characters searched.
N*                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
N*********************************************************************************************************
N*/
N
NCPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
N                              CPU_SIZE_T   len_max)
N{
N    const  CPU_CHAR    *pstr_len;
N           CPU_SIZE_T   len;
N
N
N    pstr_len = pstr;
N    len      = 0u;
N    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
N           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
N           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
N        pstr_len++;
N        len++;
N    }
N
N    return (len);                                               /* Rtn str len (see Note #3b1).                         */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Copy()
N*
N* Description : Copy source string to destination string buffer.
N*
N* Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
N*
N*               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
N*
N* Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
N*
N*               Pointer to NULL,               otherwise      (see Note #2b2A).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                       (1) Destination buffer size MUST be large enough to accommodate the entire source
N*                           string size including the terminating NULL character.
N*
N*                   (b) Source buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
N*
N*                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src') 
N*                            ... into the array pointed to by 's1' ('pstr_dest')" ...
N*                       (2) "(including the terminating null byte)."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
N*
N*                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
N*                       (2) "no return value is reserved to indicate an error."
N*                           (A) #### This requirement is intentionally NOT implemented in order to return 
N*                               NULL for any error(s).
N*
N*                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
N*                       copying takes place between objects that overlap, the behavior is undefined".
N*
N*               (3) String copy terminates when :
N*
N*                   (a) Destination/Source string pointer(s) are passed NULL pointers.
N*                       (1) No string copy performed; NULL pointer returned.
N*
N*                   (b) Destination/Source string pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Source string's terminating NULL character found.
N*                       (1) Entire source string copied into destination string buffer (see Note #2a).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
N                     const  CPU_CHAR  *pstr_src)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Copy_N(pstr_dest,
N                          pstr_src,
N                          DEF_INT_CPU_U_MAX_VAL);
X                          4294967295u);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            Str_Copy_N()
N*
N* Description : Copy source string to destination string buffer, up to a maximum number of characters.
N*
N* Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
N*
N*               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
N*
N*               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
N*
N* Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
N*
N*               Pointer to NULL,               otherwise      (see Note #2b2A).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                       (1) Destination buffer size MUST be large enough to accommodate the entire source
N*                           string size including the terminating NULL character.
N*
N*                   (b) Source string buffer NOT modified.
N*
N*               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
N*
N*                           (A) "The strncpy() function shall copy ... the array pointed to by 's2' 
N*                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
N*                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
N*                           (C)  &   "(bytes that follow a null byte are not copied)".
N*
N*                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that 
N*                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter 
N*                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in 
N*                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes 
N*                               in all are written."
N*
N*                               (1) #### Since Str_Copy() limits the maximum number of characters to copy 
N*                                   via Str_Copy_N() by the CPU's maximum number of addressable characters, 
N*                                   this requirement is intentionally NOT implemented to avoid appending 
N*                                   a potentially large number of unnecessary terminating NULL characters.
N*
N*                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also  
N*                               states that "if there is no null byte in the first 'n' ('len_max') bytes of 
N*                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
N*
N*                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
N*                       (2) "no return value is reserved to indicate an error."
N*                           (A) #### This requirement is intentionally ignored in order to return NULL 
N*                               for any error(s).
N*
N*                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
N*                       copying takes place between objects that overlap, the behavior is undefined".
N*
N*               (3) String copy terminates when :
N*
N*                   (a) Destination/Source string pointer(s) are passed NULL pointers.
N*                       (1) No string copy performed; NULL pointer returned.
N*
N*                   (b) Destination/Source string pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Source string's terminating NULL character found.
N*                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
N*
N*                   (d) 'len_max' number of characters copied.
N*                       (1) 'len_max' number of characters MAY include the terminating NULL character 
N*                           (see Note #2a1C).
N*                       (2) Null copies allowed (i.e. zero-length copies).
N*                           (A) No string copy performed; destination string returned  (see Note #2b1).
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
N                       const  CPU_CHAR    *pstr_src,
N                              CPU_SIZE_T   len_max)
N{
N           CPU_CHAR    *pstr_copy_dest;
N    const  CPU_CHAR    *pstr_copy_src;
N           CPU_SIZE_T   len_copy;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
N    if (pstr_dest == (CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N    if (pstr_src  == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_copy_dest = pstr_dest;
N    pstr_copy_src  = pstr_src;
N    len_copy       = 0u;
N
N    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
N           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
N           (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
N           ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
N       *pstr_copy_dest = *pstr_copy_src;
N        pstr_copy_dest++;
N        pstr_copy_src++;
N        len_copy++;
N    }
N                                                                /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
N    if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
N        (pstr_copy_src  == (const CPU_CHAR *)0)) {
N         return ((CPU_CHAR *)0);
N    }
N
N    if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
N       *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
N    }
N
N
N    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Cat()
N*
N* Description : Append concatenation string to destination string.
N*
N* Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
N*
N*               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
N*
N* Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
N*
N*               Pointer to NULL,               otherwise      (see Note #2b2A).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                       (1) Destination buffer size MUST be large enough to accommodate the entire 
N*                           concatenated string size including the terminating NULL character.
N*
N*                   (b) Concatenation string buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
N*
N*                       (1) "The strcat() function shall append a copy of the string pointed to by 's2' 
N*                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
N*
N*                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
N*                                end of 's1' ('pstr_dest')."
N*                           (B)  A "terminating null byte" is appended at the end of the concatenated 
N*                                destination strings.
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
N*
N*                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
N*                       (2) "no return value shall be reserved to indicate an error."
N*                           (A) #### This requirement is intentionally NOT implemented in order to return 
N*                               NULL for any error(s).
N*
N*                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
N*                       copying takes place between objects that overlap, the behavior is undefined."
N*
N*               (3) String concatenation terminates when :
N*
N*                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (b) Destination/Concatenation string pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Concatenation string's terminating NULL character found.
N*                       (1) Entire concatenation string appended to destination string (see Note #2a1).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
N                    const  CPU_CHAR  *pstr_cat)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Cat_N(pstr_dest,
N                         pstr_cat,
N                         DEF_INT_CPU_U_MAX_VAL);
X                         4294967295u);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Cat_N()
N*
N* Description : Append concatenation string to destination string, up to a maximum number of characters.
N*
N* Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
N*
N*               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
N*
N*               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
N*
N* Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
N*
N*               Pointer to NULL,               otherwise      (see Note #2b2A).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                       (1) Destination buffer size MUST be large enough to accommodate the entire 
N*                           concatenated string size including the terminating NULL character.
N*
N*                   (b) Concatenation string buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
N*
N*                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2' 
N*                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
N*                           (B)  but "not more than 'n' ('len_max') bytes".
N*
N*                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
N*                                end of 's1' ('pstr_dest')."
N*                           (B) "(a null byte and bytes that follow it are not appended)."
N*                           (C) "A terminating null byte is always appended to the result."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
N*
N*                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
N*                       (2) "no return value shall be reserved to indicate an error."
N*                           (A) #### This requirement is intentionally NOT implemented in order to return 
N*                               NULL for any error(s).
N*
N*                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
N*                       copying takes place between objects that overlap, the behavior is undefined."
N*
N*               (3) String concatenation terminates when :
N*
N*                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (b) Destination/Concatenation string pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Concatenation string's terminating NULL character found.
N*                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
N*
N*                   (d) 'len_max' number of characters concatenated.
N*
N*                       (1) 'len_max' number of characters does NOT include the terminating NULL character 
N*                           (see Note #2a2).
N*
N*                       (2) Null concatenations allowed (i.e. zero-length concatenations).
N*                           (A) No string concatenation performed; destination string returned 
N*                               (see Note #2b1).
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
N                      const  CPU_CHAR    *pstr_cat,
N                             CPU_SIZE_T   len_max)
N{
N           CPU_CHAR    *pstr_cat_dest;
N    const  CPU_CHAR    *pstr_cat_src;
N           CPU_SIZE_T   len_cat;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
N    if (pstr_dest == (CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N    if (pstr_cat  == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
N        return ((CPU_CHAR *)pstr_dest);
N    }
N
N
N    pstr_cat_dest = pstr_dest;
N    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
N           (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
N        pstr_cat_dest++;
N    }
N    if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
N        return ((CPU_CHAR *)0);
N    }
N
N    pstr_cat_src = pstr_cat;
N    len_cat      = 0u;
N
N    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
N           ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
N           (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
N           ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
N       *pstr_cat_dest = *pstr_cat_src;
N        pstr_cat_dest++;
N        pstr_cat_src++;
N        len_cat++;
N    }
N                                                                /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
N    if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
N        (pstr_cat_src  == (const CPU_CHAR *)0)) {
N         return ((CPU_CHAR *)0);
N    }
N
N   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
N
N
N    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Cmp()
N*
N* Description : Determine if two strings are identical.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
N*
N*               See also Note #2b.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
N*                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the 
N*                       string pointed to by 's2' ('p2_str)".
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
N*                          "upon successful completion, strcmp() shall return an integer greater than,
N*                           equal to, or less than 0".
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
N*                           sign of a non-zero return value shall be determined by the sign of the difference
N*                           between the values of the first pair of bytes ... that differ in the strings
N*                           being compared".
N*
N*               (3) String comparison terminates when :
N*
N*                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
N*                               (1) NULL strings identical; 0 returned.
N*
N*                           (B) (1) 'p1_str' passed a NULL pointer.
N*                                   (a) Return negative value of character pointed to by 'p2_str'.
N*
N*                               (2) 'p2_str' passed a NULL pointer.
N*                                   (a) Return positive value of character pointed to by 'p1_str'.
N*
N*                       (2) (A) BOTH strings point to NULL.
N*                               (1) Strings overlap with NULL address.
N*                               (2) Strings identical up to but NOT beyond or including the NULL address;
N*                                   0 returned.
N*
N*                           (B) (1) 'p1_str_cmp_next' points to NULL.
N*                                   (a) 'p1_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
N*
N*                               (2) 'p2_str_cmp_next' points to NULL.
N*                                   (a) 'p2_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
N*
N*                   (b) Terminating NULL character found in both strings.
N*                       (1) Strings identical; 0 returned.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (c) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
N*                           from the character pointed to by 'p1_str'.
N*
N*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N
NCPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
N                     const  CPU_CHAR  *p2_str)
N{
N    CPU_INT16S  cmp_val;
N
N
N    cmp_val = Str_Cmp_N(p1_str,
N                        p2_str,
N                        DEF_INT_CPU_U_MAX_VAL);
X                        4294967295u);
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Cmp_N()
N*
N* Description : Determine if two strings are identical for up to a maximum number of characters.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N*               len_max     Maximum number of characters to compare  (see Note  #3d).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
N*
N*               See also Note #2b.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
N*
N*                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str') 
N*                            to the array pointed to by 's2' ('p2_str)" ...
N*                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
N*                          "upon successful completion, strncmp() shall return an integer greater than,
N*                           equal to, or less than 0".
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
N*                          "the sign of a non-zero return value is determined by the sign of the difference
N*                           between the values of the first pair of bytes ... that differ in the strings
N*                           being compared".
N*
N*               (3) String comparison terminates when :
N*
N*                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
N*                               (1) NULL strings identical; 0 returned.
N*
N*                           (B) (1) 'p1_str' passed a NULL pointer.
N*                                   (a) Return negative value of character pointed to by 'p2_str'.
N*
N*                               (2) 'p2_str' passed a NULL pointer.
N*                                   (a) Return positive value of character pointed to by 'p1_str'.
N*
N*                       (2) (A) BOTH strings point to NULL.
N*                               (1) Strings overlap with NULL address.
N*                               (2) Strings identical up to but NOT beyond or including the NULL address;
N*                                   0 returned.
N*
N*                           (B) (1) 'p1_str_cmp_next' points to NULL.
N*                                   (a) 'p1_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
N*
N*                               (2) 'p2_str_cmp_next' points to NULL.
N*                                   (a) 'p2_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
N*
N*                   (b) Terminating NULL character found in both strings.
N*                       (1) Strings identical; 0 returned.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (c) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
N*                           from the character pointed to by 'p1_str'.
N*
N*                   (d) (1) 'len_max' passed a zero length.
N*                           (A) Zero-length strings identical; 0 returned.
N*
N*                       (2) First 'len_max' number of characters identical.
N*                           (A) Strings identical; 0 returned.
N*
N*                       See also Note #2a2.
N*
N*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
N                       const  CPU_CHAR    *p2_str,
N                              CPU_SIZE_T   len_max)
N{
N    const  CPU_CHAR    *p1_str_cmp;
N    const  CPU_CHAR    *p2_str_cmp;
N    const  CPU_CHAR    *p1_str_cmp_next;
N    const  CPU_CHAR    *p2_str_cmp_next;
N           CPU_INT16S   cmp_val;
N           CPU_SIZE_T   cmp_len;
N
N
N    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
N        return (0);
N    }
N
N    if (p1_str == (const CPU_CHAR *)0) {
N        if (p2_str == (const CPU_CHAR *)0) {
N            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
N        }
N        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
N        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
N    }
N    if (p2_str == (const CPU_CHAR *)0) {
N        cmp_val = (CPU_INT16S)(*p1_str);
N        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
N    }
N
N
N    p1_str_cmp      = p1_str;
N    p2_str_cmp      = p2_str;
N    p1_str_cmp_next = p1_str_cmp;
N    p2_str_cmp_next = p2_str_cmp;
N    p1_str_cmp_next++;
N    p2_str_cmp_next++;
N    cmp_len         = 0u;
N
N    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
N           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
N           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
N           ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
N           ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
N        p1_str_cmp++;
N        p2_str_cmp++;
N        p1_str_cmp_next++;
N        p2_str_cmp_next++;
N        cmp_len++;
N    }
N
N
N    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
N        return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
N    }
N
N    if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
N                                                                /* ... calc & rtn char diff  (see Note #3c1).           */
N         cmp_val = (CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp);
N
N    } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
N         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
N
N    } else {
N        if (p1_str_cmp_next == (const CPU_CHAR *)0) {
N            if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
N                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
N            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
N                                                                /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
N                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
N            }
N        } else {                                                /* If p2_str_cmp_next NULL, ...                         */
N            cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
N        }
N    }
N
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         Str_CmpIgnoreCase()
N*
N* Description : Determine if two strings are identical, ignoring case.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
N*
N*               See also Note #2b.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
N*
N*                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1' 
N*                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
N*                           (B) "ignoring differences in case".
N*
N*                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
N*                            and then a byte comparison performed."
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
N*                          "upon successful completion, strcasecmp() shall return an integer greater than,
N*                           equal to, or less than 0".
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
N*                           sign of a non-zero return value shall be determined by the sign of the difference
N*                           between the values of the first pair of bytes ... that differ in the strings
N*                           being compared".
N*
N*               (3) String comparison terminates when :
N*
N*                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
N*                               (1) NULL strings identical; 0 returned.
N*
N*                           (B) (1) 'p1_str' passed a NULL pointer.
N*                                   (a) Return negative value of character pointed to by 'p2_str', converted
N*                                       to lower case (see Note #2a2).
N*
N*                               (2) 'p2_str' passed a NULL pointer.
N*                                   (a) Return positive value of character pointed to by 'p1_str', converted
N*                                       to lower case (see Note #2a2).
N*
N*                       (2) (A) BOTH strings point to NULL.
N*                               (1) Strings overlap with NULL address.
N*                               (2) Strings identical up to but NOT beyond or including the NULL address;
N*                                   0 returned.
N*
N*                           (B) (1) 'p1_str_cmp_next' points to NULL.
N*                                   (a) 'p1_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
N*                                       converted to lower case (see Note #2a2).
N*
N*                               (2) 'p2_str_cmp_next' points to NULL.
N*                                   (a) 'p2_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
N*                                       converted to lower case (see Note #2a2).
N*
N*                   (b) Terminating NULL character found in both strings.
N*                       (1) Strings identical; 0 returned.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (c) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
N*                           converted to lower case, from the character pointed to by 'p1_str', converted
N*                           to lower case.
N*
N*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
N                               const  CPU_CHAR  *p2_str)
N{
N    CPU_INT16S  cmp_val;
N
N
N    cmp_val = Str_CmpIgnoreCase_N(p1_str,
N                                  p2_str,
N                                  DEF_INT_CPU_U_MAX_VAL);
X                                  4294967295u);
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        Str_CmpIgnoreCase_N()
N*
N* Description : Determine if two strings are identical for up to a maximum number of characters,
N*                   ignoring case.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N*               len_max     Maximum number of characters to compare  (see Note  #3d).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
N*
N*               See also Note #2b.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
N*
N*                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1' 
N*                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
N*                           (B) "ignoring differences in case"                           ...
N*                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
N*
N*                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
N*                            and then a byte comparison performed."
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
N*                          "upon successful completion, strncasecmp() shall return an integer greater than,
N*                           equal to, or less than 0".
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
N*                           sign of a non-zero return value shall be determined by the sign of the difference
N*                           between the values of the first pair of bytes ... that differ in the strings
N*                           being compared".
N*
N*               (3) String comparison terminates when :
N*
N*                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
N*                               (1) NULL strings identical; 0 returned.
N*
N*                           (B) (1) 'p1_str' passed a NULL pointer.
N*                                   (a) Return negative value of character pointed to by 'p2_str', converted
N*                                       to lower case (see Note #2a2).
N*
N*                               (2) 'p2_str' passed a NULL pointer.
N*                                   (a) Return positive value of character pointed to by 'p1_str', converted
N*                                       to lower case (see Note #2a2).
N*
N*                       (2) (A) BOTH strings point to NULL.
N*                               (1) Strings overlap with NULL address.
N*                               (2) Strings identical up to but NOT beyond or including the NULL address;
N*                                   0 returned.
N*
N*                           (B) (1) 'p1_str_cmp_next' points to NULL.
N*                                   (a) 'p1_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
N*                                       converted to lower case (see Note #2a2).
N*
N*                               (2) 'p2_str_cmp_next' points to NULL.
N*                                   (a) 'p2_str' overlaps with NULL address.
N*                                   (b) Strings compared up to but NOT beyond or including the NULL address.
N*                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
N*                                       converted to lower case (see Note #2a2).
N*
N*                   (b) Terminating NULL character found in both strings.
N*                       (1) Strings identical; 0 returned.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (c) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
N*                           converted to lower case, from the character pointed to by 'p1_str', converted
N*                           to lower case.
N*
N*                   (d) (1) 'len_max' passed a zero length.
N*                           (A) Zero-length strings identical; 0 returned.
N*
N*                       (2) First 'len_max' number of characters identical.
N*                           (A) Strings identical; 0 returned.
N*
N*                       See also Note #2a1C.
N*$PAGE*
N*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N
NCPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
N                                 const  CPU_CHAR    *p2_str,
N                                        CPU_SIZE_T   len_max)
N{
N    const  CPU_CHAR    *p1_str_cmp;
N    const  CPU_CHAR    *p2_str_cmp;
N    const  CPU_CHAR    *p1_str_cmp_next;
N    const  CPU_CHAR    *p2_str_cmp_next;
N           CPU_CHAR     char_1;
N           CPU_CHAR     char_2;
N           CPU_INT16S   cmp_val;
N           CPU_SIZE_T   cmp_len;
N
N
N    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
N        return (0);
N    }
N
N    if (p1_str == (const CPU_CHAR *)0) {
N        if (p2_str == (const CPU_CHAR *)0) {
N            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
N        }
N        char_2  =  ASCII_ToLower(*p2_str);
N        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
N        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
N    }
N    if (p2_str == (const CPU_CHAR *)0) {
N        char_1  =  ASCII_ToLower(*p1_str);
N        cmp_val = (CPU_INT16S)char_1;
N        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
N    }
N
N
N    p1_str_cmp      = p1_str;
N    p2_str_cmp      = p2_str;
N    p1_str_cmp_next = p1_str_cmp;
N    p2_str_cmp_next = p2_str_cmp;
N    p1_str_cmp_next++;
N    p2_str_cmp_next++;
N    char_1          = ASCII_ToLower(*p1_str_cmp);
N    char_2          = ASCII_ToLower(*p2_str_cmp);
N    cmp_len         = 0u;
N
N    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
N           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
N           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
N           ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
N           ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
N        p1_str_cmp++;
N        p2_str_cmp++;
N        p1_str_cmp_next++;
N        p2_str_cmp_next++;
N        cmp_len++;
N        char_1 = ASCII_ToLower(*p1_str_cmp);
N        char_2 = ASCII_ToLower(*p2_str_cmp);
N    }
N
N
N    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
N        return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
N    }
N
N    if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
N         cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */
N
N    } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
N         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
N
N    } else {
N        if (p1_str_cmp_next == (const CPU_CHAR *)0) {
N            if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
N                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
N            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
N                char_2  =  ASCII_ToLower(*p2_str_cmp_next);
N                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
N            }
N        } else {                                                /* If p2_str_cmp_next NULL, ...                         */
N            char_1  =  ASCII_ToLower(*p1_str_cmp_next);
N            cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
N        }
N    }
N
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Char()
N*
N* Description : Search string for first occurrence of specific character.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
N*
N*               Pointer to NULL,                                           otherwise (see Note #2b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
N*
N*                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
N*                            ... in the string pointed to by 's' ('pstr')."
N*                       (2) "The terminating null byte is considered to be part of the string."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
N*                       "upon completion, strchr() shall return" :
N*
N*                       (1) "a pointer to the byte," ...
N*                       (2) "or a null pointer if the byte was not found."
N*                           (A) #### Although NO strchr() specification states to return NULL for 
N*                               any other reason(s), NULL is also returned for any error(s).
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned 
N*                           (see Note #2b2).
N*                       (2) Applicable even if search character is the terminating NULL character 
N*                           (see Note #2a2).
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to first occurrence of search character in search string
N*                           (see Note #2a1).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
N                            CPU_CHAR   srch_char)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Char_N(pstr,
N                          DEF_INT_CPU_U_MAX_VAL,
X                          4294967295u,
N                          srch_char);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            Str_Char_N()
N*
N* Description : Search string for first occurrence of specific character, up to a maximum number 
N*                   of characters.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               len_max         Maximum number of characters to search (see Notes #2c & #3e).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
N*
N*               Pointer to NULL,                                           otherwise (see Note #2b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
N*
N*                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
N*                            ... in the string pointed to by 's' ('pstr')."
N*                       (2) "The terminating null byte is considered to be part of the string."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
N*                       "upon completion, strchr() shall return" :
N*
N*                       (1) "a pointer to the byte," ...
N*                       (2) "or a null pointer if the byte was not found."
N*                           (A) #### Although NO strchr() specification states to return NULL for 
N*                               any other reason(s), NULL is also returned for any error(s).
N*
N*                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
N*                       argument list for consistency with all other custom string library functions.
N*                       However, the 'len_max' argument is sequentially ordered as the second argument 
N*                       to comply with most standard library's strnchr() argument list.
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned 
N*                           (see Note #2b2).
N*                       (2) Applicable even if search character is the terminating NULL character 
N*                           (see Note #2a2).
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to first occurrence of search character in search string
N*                           (see Note #2a1).
N*
N*                   (e) 'len_max' number of characters searched.
N*                       (1) Search character NOT found in search string within first 'len_max' number 
N*                           of characters; NULL pointer returned.
N*                       (2) 'len_max' number of characters MAY include terminating NULL character 
N*                           (see Note #2a2).
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
N                              CPU_SIZE_T   len_max,
N                              CPU_CHAR     srch_char)
N{
N    const  CPU_CHAR    *pstr_char;
N           CPU_SIZE_T   len_srch;
N
N
N    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_char = pstr;
N    len_srch  = 0u;
N
N    while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
N           (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
N           (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
N           ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
N        pstr_char++;
N        len_srch++;
N    }
N
N
N    if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
N        return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
N    }
N
N    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
N         return ((CPU_CHAR *)0);
N    }
N
N
N    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           Str_Char_Last()
N*
N* Description : Search string for last occurrence of specific character.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
N*
N*               Pointer to NULL,                                          otherwise (see Note #2b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
N*
N*                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
N*                            ... in the string pointed to by 's' ('pstr')."
N*                       (2) "The terminating null byte is considered to be part of the string."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
N*                       "upon successful completion, strrchr() shall return" :
N*
N*                       (1) "a pointer to the byte" ...
N*                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
N*                           (A) #### Although NO strrchr() specification states to return NULL for 
N*                               any other reason(s), NULL is also returned for any error(s).
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String searched from end to beginning.
N*                       (1) Search character NOT found in search string; NULL pointer returned.
N*                       (2) Applicable even if search character is the terminating NULL character 
N*                           (see Note #2a2).
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to last occurrence of search character in search string 
N*                           (see Note #2a1).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
N                                 CPU_CHAR   srch_char)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Char_Last_N(pstr,
N                               DEF_INT_CPU_U_MAX_VAL,
X                               4294967295u,
N                               srch_char);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          Str_Char_Last_N()
N*
N* Description : Search string for last occurrence of specific character, up to a maximum number 
N*                   of characters.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               len_max         Maximum number of characters to search (see Notes #2c & #3e).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
N*
N*               Pointer to NULL,                                          otherwise (see Note #2b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
N*
N*                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
N*                            ... in the string pointed to by 's' ('pstr')."
N*                       (2) "The terminating null byte is considered to be part of the string."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
N*                       "upon successful completion, strrchr() shall return" :
N*
N*                       (1) "a pointer to the byte" ...
N*                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
N*                           (A) #### Although NO strrchr() specification states to return NULL for 
N*                               any other reason(s), NULL is also returned for any error(s).
N*
N*                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
N*                       argument list for consistency with all other custom string library functions.
N*                       However, the 'len_max' argument is sequentially ordered as the second argument 
N*                       to comply with most standard library's strnrchr() argument list.
N*
N*                       See also 'Str_Char_N()  Note #2c'.
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String searched from end to beginning.
N*                       (1) Search character NOT found in search string; NULL pointer returned 
N*                           (see Note #2b2).
N*                       (2) Applicable even if search character is the terminating NULL character 
N*                           (see Note #2a2).
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to last occurrence of search character in search string 
N*                           (see Note #2a1).
N*
N*                   (e) 'len_max' number of characters searched.
N*                       (1) Search character NOT found in search string within last 'len_max' number 
N*                           of characters; NULL pointer returned.
N*                       (2) 'len_max' number of characters MAY include terminating NULL character 
N*                           (see Note #2a2).
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
N                                   CPU_SIZE_T   len_max,
N                                   CPU_CHAR     srch_char)
N{
N    const  CPU_CHAR    *pstr_char;
N           CPU_SIZE_T   str_len_max;
N           CPU_SIZE_T   str_len;
N
N
N    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_char    = pstr;
N     str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
N     str_len     = Str_Len_N(pstr_char, str_len_max);
N    pstr_char   += str_len;
N
N    if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
N        return ((CPU_CHAR *)0);
N    }
N
N    while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
N           (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
N        pstr_char--;
N    }
N
N
N    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
N         return ((CPU_CHAR *)0);
N    }
N
N
N    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         Str_Char_Replace()
N*
N* Description : Search string for specific character and replace it by another specific character.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               char_srch       Search character.
N*
N*               char_replace    Replace character.
N*
N* Return(s)   : Pointer to string, if NO error(s).
N*
N*               Pointer to NULL,   otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned
N*                       (2) Applicable even if search character is the terminating NULL character
N*
N*                   (d) Search character found.
N*                       (1) Replace character found by the specified character.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
N                             CPU_CHAR   char_srch,
N                             CPU_CHAR   char_replace)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Char_Replace_N(pstr,
N                                  char_srch,
N                                  char_replace,
N                                  DEF_INT_CPU_U_MAX_VAL);
X                                  4294967295u);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        Str_Char_Replace_N()
N*
N* Description : Search string for specific character and replace it by another specific character, up to
N*               a maximum number of characters.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               char_srch       Search character.
N*
N*               char_replace    Replace character.
N*
N*               len_max         Maximum number of characters to search (see Notes #2c & #3e).
N*
N* Return(s)   : Pointer to string, if NO error(s).
N*
N*               Pointer to NULL,   otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address; NULL pointer returned.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned
N*                       (2) Applicable even if search character is the terminating NULL character
N*
N*                   (d) Search character found.
N*                       (1) Replace character found by the specified character.
N*
N*                   (e) 'len_max' number of characters searched.
N*                       (1) Search character NOT found in search string within first 'len_max' number
N*                           of characters; NULL pointer returned.
N*                       (2) 'len_max' number of characters MAY include terminating NULL character
N*                           (see Note #2a2).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
N                               CPU_CHAR     char_srch,
N                               CPU_CHAR     char_replace,
N                               CPU_SIZE_T   len_max)
N{
N    CPU_CHAR    *pstr_char;
N    CPU_SIZE_T   len;
N
N
N    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
N        return ((CPU_CHAR *)0);
N    }
N
N    pstr_char = pstr;
N    len       = len_max;
N
N    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
N           (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
X           (*pstr_char !=  0x00   ) &&                
N           ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
N
N        if (*pstr_char == char_srch) {
N            *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
N        }
N
N        pstr_char++;
N        len--;
N    }
N
N    return (pstr);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Str()
N*
N* Description : Search string for first occurence of a specific search string.
N*
N* Argument(s) : pstr            Pointer to        string (see Note #1).
N*
N*               pstr_srch       Pointer to search string (see Note #1).
N*
N* Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
N*
N*               Pointer to string,                                      if NULL search string (see Note #2b2).
N*
N*               Pointer to NULL,                                        otherwise             (see Note #2b1B).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
N*
N*                       (1) "The strstr() function shall locate the first occurrence  in the string 
N*                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
N*                            pointed to by 's2' ('pstr_srch')" ...
N*                       (2) "(excluding the terminating null byte)."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
N*
N*                       (1) "Upon successful completion, strstr() shall return" :
N*                           (A) "a pointer to the located string" ...
N*                           (B) "or a null pointer if the string is not found."
N*                               (1) #### Although NO strstr() specification states to return NULL for 
N*                                   any other reason(s), NULL is also returned for any error(s).
N*
N*                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
N*                            shall return 's1' ('pstr')."
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer(s) are passed NULL pointers.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Search string length equal to zero.
N*                       (1) No string search performed; string pointer returned (see Note #2b2).
N*
N*                   (d) Search string length greater than string length.
N*                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
N*
N*                   (e) Entire string has been searched.
N*                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
N*
N*                   (f) Search string found.
N*                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
N                    const  CPU_CHAR  *pstr_srch)
N{
N    CPU_CHAR  *pstr_rtn;
N
N
N    pstr_rtn = Str_Str_N(pstr,
N                         pstr_srch,
N                         DEF_INT_CPU_U_MAX_VAL);
X                         4294967295u);
N
N    return (pstr_rtn);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Str_N()
N*
N* Description : Search string for first occurence of a specific search string, up to a maximum number 
N*                   of characters.
N*
N* Argument(s) : pstr            Pointer to        string (see Note #1).
N*
N*               pstr_srch       Pointer to search string (see Note #1).
N*
N*               len_max         Maximum number of characters to search (see Note #3g).
N*
N* Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
N*
N*               Pointer to string,                                      if NULL search string (see Note #2b2).
N*
N*               Pointer to NULL,                                        otherwise             (see Note #2b1B).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
N*
N*                       (1) "The strstr() function shall locate the first occurrence  in the string 
N*                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
N*                            pointed to by 's2' ('pstr_srch')" ...
N*                       (2) "(excluding the terminating null byte)."
N*
N*                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
N*
N*                       (1) "Upon successful completion, strstr() shall return" :
N*                           (A) "a pointer to the located string" ...
N*                           (B) "or a null pointer if the string is not found."
N*                               (1) #### Although NO strstr() specification states to return NULL for 
N*                                   any other reason(s), NULL is also returned for any error(s).
N*
N*                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
N*                            shall return 's1' ('pstr')."
N*
N*               (3) String search terminates when :
N*
N*                   (a) String pointer(s) are passed NULL pointers.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer(s) point to NULL.
N*                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
N*
N*                   (c) Search string length equal to zero.
N*                       (1) No string search performed; string pointer returned (see Note #2b2).
N*
N*                   (d) Search string length greater than string length.
N*                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
N*
N*                   (e) Entire string has been searched.
N*                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
N*                       (2) Maximum size of the search is defined as the subtraction of the
N*                           search string length from the string length.
N*
N*                   (f) Search string found.
N*                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
N*                       (2) Search string found via Str_Cmp_N().
N*
N*                   (g) 'len_max' number of characters searched.
N*                       (1) 'len_max' number of characters does NOT include terminating NULL character
N*                           (see Note #2a2).
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
N                      const  CPU_CHAR    *pstr_srch,
N                             CPU_SIZE_T   len_max)
N{
N           CPU_SIZE_T    str_len;
N           CPU_SIZE_T    str_len_srch;
N           CPU_SIZE_T    len_max_srch;
N           CPU_SIZE_T    srch_len;
N           CPU_SIZE_T    srch_ix;
N           CPU_BOOLEAN   srch_done;
N           CPU_INT16S    srch_cmp;
N    const  CPU_CHAR     *pstr_str;
N    const  CPU_CHAR     *pstr_srch_ix;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
N    if (pstr == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N    if (pstr_srch == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
N        return ((CPU_CHAR *)0);
N    }
N
N                                                                /* Lim max srch str len (to chk > str len).             */
N    len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
X    len_max_srch = (len_max <       4294967295u)
N                 ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
X                 ? (len_max + 1u) : 4294967295u;
N
N    str_len      = Str_Len_N(pstr,      len_max);
N    str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
N    if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
N        return ((CPU_CHAR *)pstr);
N    }
N    if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
N        return ((CPU_CHAR *)0);
N    }
N                                                                /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
N    pstr_str = pstr      + str_len;
N    if (pstr_str == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N    pstr_str = pstr_srch + str_len_srch;
N    if (pstr_str == (const CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N
N
N    srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
N    srch_ix   = 0u;
N    srch_done = DEF_NO;
X    srch_done = 0u;
N
N    do {
N        pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
N        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
N        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
X        srch_done    = (srch_cmp == 0) ? 1u : 0u;
N        srch_ix++;
N    } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
X    } while ((srch_done == 0u) && (srch_ix <= srch_len));
N
N
N    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
N        return ((CPU_CHAR *)0);
N    }
N
N    return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         Str_FmtNbr_Int32U()
N*
N* Description : Format 32-bit unsigned integer into a multi-digit character string.
N*
N* Argument(s) : nbr             Number           to format.
N*
N*               nbr_dig         Number of digits to format (see Note #1).
N*
N*                               The following may be used to specify the number of digits to format :
N*
N*                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
N*                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
N*
N*               nbr_base        Base   of number to format (see Note #2).
N*
N*                               The following may be used to specify the number base :
N*
N*                                   DEF_NBR_BASE_BIN            Base  2
N*                                   DEF_NBR_BASE_OCT            Base  8
N*                                   DEF_NBR_BASE_DEC            Base 10
N*                                   DEF_NBR_BASE_HEX            Base 16
N*
N*               lead_char       Prepend leading character  (see Note #3) :
N*
N*                                   '\0'                    Do NOT prepend leading character to string.
N*                                     Printable character          Prepend leading character to string.
N*                                   Unprintable character   Format invalid string (see Note #6).
N*
N*               lower_case      Format alphabetic characters (if any) in lower case :
N*
N*                                   DEF_NO          Format alphabetic characters in upper case.
N*                                   DEF_YES         Format alphabetic characters in lower case.
N*
N*               nul             Append terminating NULL-character (see Note #4) :
N*
N*                                   DEF_NO          Do NOT append terminating NULL-character to string.
N*                                   DEF_YES                Append terminating NULL-character to string.
N*
N*               pstr            Pointer to character array to return formatted number string (see Note #5).
N*
N* Return(s)   : Pointer to formatted string, if NO error(s).
N*
N*               Pointer to NULL,             otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
N*                       is performed except possible NULL-termination of the string (see Note #4).
N*
N*                           Example :
N*
N*                               nbr      = 23456
N*                               nbr_dig  = 0
N*                               nbr_base = 10
N*
N*                               pstr     = ""                   See Note #6a
N*
N*                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
N*                       significant integer digits of the number to format ('nbr'); then an invalid 
N*                       string is formatted instead of truncating any significant integer digits.
N*
N*                           Example :
N*
N*                               nbr      = 23456
N*                               nbr_dig  = 3
N*                               nbr_base = 10
N*
N*                               pstr     = "???"                See Note #6b
N*
N*               (2) The number's base MUST be between 2 & 36, inclusive.
N*$PAGE*
N*               (3) Leading character option prepends leading characters prior to the first non-zero digit.
N*
N*                   (a) (1) Leading character MUST be a printable ASCII character.
N*
N*                       (2) (A) Leading character MUST NOT be a number base digit, ...
N*                           (B) with the exception of '0'.
N*
N*                   (b) The number of leading characters is such that the total number of significant 
N*                       integer digits plus the number of leading characters is equal to the requested 
N*                       number of integer digits to format ('nbr_dig').
N*
N*                           Example :
N*
N*                               nbr       = 23456
N*                               nbr_dig   = 7
N*                               nbr_base  = 10
N*                               lead_char = ' '
N*
N*                               pstr      = "  23456"
N*
N*                   (c) (1) If the value of the number to format is     zero  ...
N*                       (2) ... & the number of digits to format is non-zero, ...
N*                       (3) ... but NO leading character available;           ...
N*                       (4) ... then one digit of '0' value is formatted.
N*
N*                           This is NOT a leading character; but a single integer digit of '0' value.
N*
N*               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
N*                       array formatting.
N*
N*                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
N*                       terminate option DISABLED will cause character string run-on.
N*
N*               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (b) To prevent character buffer overrun :
N*
N*                           Character array size MUST be  >=  ('nbr_dig'          +
N*                                                               1 'NUL' terminator)  characters
N*
N*               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
N*                   ('?') will be formatted, where the number of question marks is determined by the 
N*                   number of digits to format ('nbr_dig') :
N*
N*                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
N*                          number of     =  {
N*                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
N*
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
N                              CPU_INT08U    nbr_dig,
N                              CPU_INT08U    nbr_base,
N                              CPU_CHAR      lead_char,
N                              CPU_BOOLEAN   lower_case,
N                              CPU_BOOLEAN   nul,
N                              CPU_CHAR     *pstr)
N{
N    CPU_CHAR  *pstr_fmt;
N
N
N    pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
N                                nbr_dig,
N                                nbr_base,
N                                DEF_NO,
X                                0u,
N                                lead_char,
N                                lower_case,
N                                nul,
N                                pstr);
N
N    return (pstr_fmt);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         Str_FmtNbr_Int32S()
N*
N* Description : Format 32-bit signed integer into a multi-digit character string.
N*
N* Argument(s) : nbr             Number           to format.
N*
N*               nbr_dig         Number of digits to format (see Note #1).
N*
N*                               The following may be used to specify the number of digits to format :
N*
N*                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
N*                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
N*                                                                   (plus 1 digit for possible negative sign)
N*
N*               nbr_base        Base   of number to format (see Note #2).
N*
N*                               The following may be used to specify the number base :
N*
N*                                   DEF_NBR_BASE_BIN            Base  2
N*                                   DEF_NBR_BASE_OCT            Base  8
N*                                   DEF_NBR_BASE_DEC            Base 10
N*                                   DEF_NBR_BASE_HEX            Base 16
N*
N*               lead_char       Prepend leading character  (see Note #3) :
N*
N*                                   '\0'                    Do NOT prepend leading character to string.
N*                                     Printable character          Prepend leading character to string.
N*                                   Unprintable character   Format invalid string (see Note #6).
N*
N*               lower_case      Format alphabetic characters (if any) in lower case :
N*
N*                                   DEF_NO          Format alphabetic characters in upper case.
N*                                   DEF_YES         Format alphabetic characters in lower case.
N*
N*               nul             Append terminating NULL-character (see Note #4) :
N*
N*                                   DEF_NO          Do NOT append terminating NULL-character to string.
N*                                   DEF_YES                Append terminating NULL-character to string.
N*
N*               pstr            Pointer to character array to return formatted number string (see Note #5).
N*
N* Return(s)   : Pointer to formatted string, if NO error(s).
N*
N*               Pointer to NULL,             otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
N*                       is performed except possible NULL-termination of the string (see Note #4).
N*
N*                           Example :
N*
N*                               nbr      = -23456
N*                               nbr_dig  =  0
N*                               nbr_base = 10
N*
N*                               pstr     = ""                   See Note #6a
N*
N*                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
N*                       significant integer digits of the number to format ('nbr'); then an invalid 
N*                       string is formatted instead of truncating any significant integer digits.
N*
N*                           Example :
N*
N*                               nbr      = 23456
N*                               nbr_dig  = 3
N*                               nbr_base = 10
N*
N*                               pstr     = "???"                See Note #6b
N*
N*                   (c) If the number to format ('nbr') is negative but the number of digits to format 
N*                       ('nbr_dig') is equal to the number of significant integer digits of the number 
N*                       to format ('nbr'); then an invalid string is formatted instead of truncating 
N*                       the negative sign.
N*
N*                           Example :
N*
N*                               nbr      = -23456
N*                               nbr_dig  =  5
N*                               nbr_base = 10
N*
N*                               pstr     = "?????"              See Note #6b
N*
N*               (2) The number's base MUST be between 2 & 36, inclusive.
N*$PAGE*
N*               (3) Leading character option prepends leading characters prior to the first non-zero digit.
N*
N*                   (a) (1) Leading character MUST be a printable ASCII character.
N*
N*                       (2) (A) Leading character MUST NOT be a number base digit, ...
N*                           (B) with the exception of '0'.
N*
N*                   (b) (1) The number of leading characters is such that the total number of significant 
N*                           integer digits plus the number of leading characters plus possible negative 
N*                           sign character is equal to the requested number of integer digits to format 
N*                           ('nbr_dig').
N*
N*                               Examples :
N*
N*                                   nbr       = 23456
N*                                   nbr_dig   = 7
N*                                   nbr_base  = 10
N*                                   lead_char = ' '
N*
N*                                   pstr      = "  23456"
N*
N*
N*                                   nbr       = -23456
N*                                   nbr_dig   =  7
N*                                   nbr_base  = 10
N*                                   lead_char = ' '
N*
N*                                   pstr      = " -23456"
N*
N*                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is     a '0' digit; then the negative sign character 
N*                               prefixes all leading characters prior to the formatted number.
N*
N*                                   Examples :
N*
N*                                       nbr        = -23456
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 10
N*                                       lead_char  = '0'
N*
N*                                       pstr       = "-0023456"
N*
N*
N*                                       nbr        = -43981
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 16
N*                                       lead_char  = '0'
N*                                       lower_case = DEF_NO
N*
N*                                       pstr       = "-000ABCD"
N*
N*                           (B) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is NOT a '0' digit; then the negative sign character 
N*                               immediately prefixes the most significant digit of the formatted number.
N*
N*                                   Examples :
N*
N*                                       nbr        = -23456
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 10
N*                                       lead_char  = '#'
N*
N*                                       pstr       = "##-23456"
N*
N*
N*                                       nbr        = -43981
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 16
N*                                       lead_char  = '#'
N*                                       lower_case = DEF_YES
N*
N*                                       pstr       = "###-abcd"
N*
N*                   (c) (1) If the value of the number to format is     zero  ...
N*                       (2) ... & the number of digits to format is non-zero, ...
N*                       (3) ... but NO leading character available;           ...
N*                       (4) ... then one digit of '0' value is formatted.
N*
N*                           This is NOT a leading character; but a single integer digit of '0' value.
N*$PAGE*
N*               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
N*                       array formatting.
N*
N*                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
N*                       terminate option DISABLED will cause character string run-on.
N*
N*               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (b) To prevent character buffer overrun :
N*
N*                           Character array size MUST be  >=  ('nbr_dig'          +
N*                                                               1 negative sign   +
N*                                                               1 'NUL' terminator)  characters
N*
N*               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
N*                   ('?') will be formatted, where the number of question marks is determined by the 
N*                   number of digits to format ('nbr_dig') :
N*
N*                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
N*                          number of     =  {
N*                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
N*
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
N                              CPU_INT08U    nbr_dig,
N                              CPU_INT08U    nbr_base,
N                              CPU_CHAR      lead_char,
N                              CPU_BOOLEAN   lower_case,
N                              CPU_BOOLEAN   nul,
N                              CPU_CHAR     *pstr)
N{
N    CPU_CHAR     *pstr_fmt;
N    CPU_INT32S    nbr_fmt;
N    CPU_BOOLEAN   nbr_neg;
N
N
N    if (nbr < 0) {                                              /* If nbr neg, ...                                      */
N        nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
N        nbr_neg =  DEF_YES;
X        nbr_neg =  1u;
N    } else {
N        nbr_fmt =  nbr;
N        nbr_neg =  DEF_NO;
X        nbr_neg =  0u;
N    }
N
N    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
N                                            nbr_dig,
N                                            nbr_base,
N                                            nbr_neg,
N                                            lead_char,
N                                            lower_case,
N                                            nul,
N                                            pstr);
N
N    return (pstr_fmt);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           Str_FmtNbr_32()
N*
N* Description : Format number into a multi-digit character string.
N*
N* Argument(s) : nbr             Number                         to format (see Note #1).
N*
N*               nbr_dig         Number of decimal       digits to format (see Note #2).
N*
N*               nbr_dp          Number of decimal point digits to format.
N*
N*               lead_char       Prepend leading character (see Note #3) :
N*
N*                                   '\0'                    Do NOT prepend leading character to string.
N*                                     Printable character          Prepend leading character to string.
N*                                   Unprintable character   Format invalid string (see Note #6d).
N*
N*               nul             Append terminating NULL-character (see Note #4) :
N*
N*                                   DEF_NO          Do NOT append terminating NULL-character to string.
N*                                   DEF_YES                Append terminating NULL-character to string.
N*
N*               pstr            Pointer to character array to return formatted number string (see Note #5).
N*
N* Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
N*
N*               Pointer to NULL,             otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
N*
N*
N*                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
N*                           32-bit Floating-point Number  =  -----------------------------------------------------
N*                                                                             log [External-Base]
N*
N*                                                             log [2 ^ 24]
N*                                                         =  --------------
N*                                                               log [10]
N*
N*                                                         <  7.225  Base-10 Digits
N*
N*                               where
N*                                       Internal-Base                   Internal number base of floating-
N*                                                                           point numbers (i.e.  2)
N*                                       External-Base                   External number base of floating-
N*                                                                           point numbers (i.e. 10)
N*                                       Number-Internal-Base-Digits     Number of internal number base
N*                                                                           significant digits (i.e. 24)
N*
N*                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the 
N*                       maximum accuracy.
N*$PAGE*
N*               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO 
N*                       formatting is performed except possible NULL-termination of the string (see Note #4).
N*
N*                           Example :
N*
N*                               nbr     = -23456.789
N*                               nbr_dig =  0
N*                               nbr_dp  =  0
N*
N*                               pstr    = ""                        See Note #7a
N*
N*                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of 
N*                           significant integer digits of the number to format ('nbr'); then an invalid 
N*                           string is formatted instead of truncating any significant integer digits.
N*
N*                               Example :
N*
N*                                   nbr     = 23456.789
N*                                   nbr_dig = 3
N*                                   nbr_dp  = 2
N*
N*                                   pstr    = "??????"              See Note #7d
N*
N*                       (2) If the number to format ('nbr') is negative but the number of digits to format 
N*                           ('nbr_dig') is equal to the number of significant integer digits of the number 
N*                           to format ('nbr'); then an invalid string is formatted instead of truncating 
N*                           the negative sign.
N*
N*                               Example :
N*
N*                                   nbr     = -23456.789
N*                                   nbr_dig =  5
N*                                   nbr_dp  =  2
N*
N*                                   pstr    = "????????"            See Note #7d
N*
N*                       (3) If the number to format ('nbr') is negative but the number of significant 
N*                           integer digits is zero, & the number of digits to format ('nbr_dig') is one 
N*                           but the number of decimal point digits to format ('nbr_dp') is zero; then 
N*                           an invalid string is formatted instead of truncating the negative sign.
N*
N*                               Example :
N*
N*                                   nbr     = -0.7895
N*                                   nbr_dig =  1
N*                                   nbr_dp  =  0
N*
N*                                   pstr    = "?"                   See Note #7d
N*
N*                       (4) (A) If the number to format ('nbr') is negative but the number of significant 
N*                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
N*                               zero but the number of decimal point digits to format ('nbr_dp') is non-
N*                               zero; then the negative sign immediately prefixes the decimal point -- 
N*                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
N*
N*                                   Example :
N*
N*                                       nbr     = -0.7895
N*                                       nbr_dig =  0
N*                                       nbr_dp  =  2
N*
N*                                       pstr    = "-.78"
N*
N*                           (B) If the number to format ('nbr') is positive but the number of significant 
N*                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
N*                               zero but the number of decimal point digits to format ('nbr_dp') is non-
N*                               zero; then a single decimal digit of '0' prefixes the decimal point.
N*
N*                               This '0' digit is used whenever a negative sign is not formatted (see 
N*                               Note #2b4A) so that the formatted string's decimal point is not floating, 
N*                               but fixed in the string as the 2nd character.
N*
N*                                   Example :
N*
N*                                       nbr     =  0.7895
N*                                       nbr_dig =  0
N*                                       nbr_dp  =  2
N*
N*                                       pstr    = "0.78"
N*$PAGE*
N*                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
N*
N*                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point 
N*                               numbers, digits following all significantly-accurate digits of the number to 
N*                               format ('nbr') will be inaccurate; ...
N*                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all 
N*                               digits or decimal places following all significantly-accurate digits of the 
N*                               number to format ('nbr') will be replaced & formatted with zeros ('0').
N*
N*                                   Example :
N*
N*                                       nbr                            = 123456789.012345
N*                                       nbr_dig                        = 9
N*                                       nbr_dp                         = 6
N*                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
N*
N*                                       pstr                           = "123456700.000000"
N*
N*                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr') 
N*                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's 
N*                           &/or compiler's floating-point implementation.
N*
N*                       See also Note #1.
N*
N*               (3) Leading character option prepends leading characters prior to the first non-zero digit.
N*
N*                   (a) (1) Leading character MUST be a printable ASCII character.
N*
N*                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
N*                           (B) with the exception of '0'.
N*
N*                   (b) (1) The number of leading characters is such that the total number of significant 
N*                           integer digits plus the number of leading characters plus possible negative 
N*                           sign character is equal to the requested number of integer digits to format 
N*                           ('nbr_dig').
N*
N*                               Examples :
N*
N*                                   nbr       = 23456.789
N*                                   nbr_dig   = 7
N*                                   nbr_dp    = 2
N*                                   lead_char = ' '
N*
N*                                   pstr      = "  23456.78"
N*
N*
N*                                   nbr       = -23456.789
N*                                   nbr_dig   =  7
N*                                   nbr_dp    =  2
N*                                   lead_char = ' '
N*
N*                                   pstr      = " -23456.78"
N*
N*                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is     a '0' digit; then the negative sign character 
N*                               prefixes all leading characters prior to the formatted number.
N*
N*                                   Example :
N*
N*                                       nbr       = -23456.789
N*                                       nbr_dig   =  8
N*                                       nbr_dp    =  2
N*                                       lead_char = '0'
N*
N*                                       pstr      = "-0023456.78"
N*
N*                           (B) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is NOT a '0' digit; then the negative sign character 
N*                               immediately prefixes the most significant digit of the formatted number.
N*
N*                                   Examples :
N*
N*                                       nbr       = -23456.789
N*                                       nbr_dig   =  8
N*                                       nbr_dp    =  2
N*                                       lead_char = '#'
N*
N*                                       pstr      = "##-23456.78"
N*
N*                   (c) (1) If the integer value of the number to format is zero & ...
N*                       (2) ... the number of digits to format is greater than one ...
N*                       (3) ... OR  the number is NOT negative,                    ...
N*                       (4) ... but NO leading character available;                ...
N*                       (5) ... then one digit of '0' value is formatted.
N*
N*                           This is NOT a leading character; but a single integer digit of '0' value.
N*
N*                       See also Note #2b4B.
N*$PAGE*
N*               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
N*                       array formatting.
N*
N*                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
N*                       terminate option DISABLED will cause character string run-on.
N*
N*               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (b) To prevent character buffer overrun :
N*
N*                           Character array size MUST be  >=  ('nbr_dig'          +
N*                                                              'nbr_dp'           +
N*                                                               1 negative sign   +
N*                                                               1 decimal point   +
N*                                                               1 'NUL' terminator)  characters
N*
N*               (6) String format terminates when :
N*
N*                   (a) Format string pointer is passed a NULL pointer.
N*                       (1) No      string formatted;                NULL pointer returned.
N*
N*                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
N*                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
N*
N*                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
N*                           integer digits of the number to format ('nbr'), including possible 
N*                           negative sign.
N*                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
N*
N*                   (d) Lead character is NOT a valid, printable character (see Note #3a).
N*                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
N*
N*                   (e) Number successfully formatted into character string array.
N*
N*               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
N*                   ('?') will be formatted, where the number of question marks is determined by the 
N*                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
N*
N*                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
N*                                           {                                        'nbr_dp'  = 0
N*                                           {
N*                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
N*                                           {                                        'nbr_dp'  = 0
N*                      Invalid string's     {
N*                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
N*                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
N*                                           {         1 (for negative sign) ]
N*                                           {
N*                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
N*                                           {        'nbr_dp'               +        'nbr_dp'  > 0
N*                                           {         1 (for decimal point) ]
N*
N*********************************************************************************************************
N*/
N
N#if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
S                          CPU_INT08U    nbr_dig,
S                          CPU_INT08U    nbr_dp,
S                          CPU_CHAR      lead_char,
S                          CPU_BOOLEAN   nul,
S                          CPU_CHAR     *pstr)
S{
S    CPU_CHAR     *pstr_fmt;
S    CPU_DATA      i;
S    CPU_FP32      nbr_fmt;
S    CPU_FP32      nbr_log;
S    CPU_INT32U    nbr_shiftd;
S    CPU_INT16U    nbr_dig_max;
S    CPU_INT16U    nbr_dig_sig;
S    CPU_INT08U    nbr_neg_sign;
S    CPU_INT08U    dig_val;
S    CPU_FP32      dig_exp;
S    CPU_FP32      dp_exp;
S    CPU_BOOLEAN   lead_char_dig;
S    CPU_BOOLEAN   lead_char_fmtd;
S    CPU_BOOLEAN   lead_char_0;
S    CPU_BOOLEAN   fmt_invalid;
S    CPU_BOOLEAN   print_char;
S    CPU_BOOLEAN   nbr_neg;
S    CPU_BOOLEAN   nbr_neg_fmtd;
S
S
S/*$PAGE*/
S                                                                /* ---------------- VALIDATE FMT ARGS ----------------- */
S    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
S        return ((CPU_CHAR *)0);
S    }
S
S    fmt_invalid = DEF_NO;
S
S    if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
S        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
S    }
S
S    if (lead_char != (CPU_CHAR)'\0') {
S        print_char =  ASCII_IsPrint(lead_char);
S        if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
S            fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
S
S        } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
S            lead_char_dig = ASCII_IsDig(lead_char);
S            if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
S                fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
S            }
S        }
S    }
S
S
S                                                                /* ----------------- PREPARE NBR FMT ------------------ */
S    pstr_fmt = pstr;
S
S    if (fmt_invalid == DEF_NO) {
S        if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
S            nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
S            nbr_neg_sign =  1u;
S            nbr_neg      =  DEF_YES;
S        } else {
S            nbr_fmt      =  nbr;
S            nbr_neg_sign =  0u;
S            nbr_neg      =  DEF_NO;
S        }
S
S        nbr_log     = nbr_fmt;
S        nbr_dig_max = 0u;
S        while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
S            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
S            nbr_log /= 10.0f;
S        }
S
S        if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
S             (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
S            ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
S             (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
S             (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
S                                                                /* .. prepare nbr digs to fmt.                          */
S            dig_exp = 1.0f;
S            for (i = 1u; i < nbr_dig; i++) {
S                dig_exp *= 10.0f;
S            }
S
S            nbr_neg_fmtd   =  DEF_NO;
S            nbr_dig_sig    =  0u;
S            lead_char_fmtd =  DEF_NO;
S            lead_char_0    = (lead_char == '0')                 /* Chk if lead char a '0' dig (see Note #3b2).          */
S                           ?  DEF_YES : DEF_NO;
S
S        } else {                                                /* Else if nbr trunc'd, ...                             */
S            fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
S        }
S    }
S
S
S/*$PAGE*/
S                                                                /* ------------------- FMT NBR STR -------------------- */
S    for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
S        if (fmt_invalid == DEF_NO) {
S            if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
S                nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
S                if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
S                    (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
S                                                                /* ... calc & fmt dig val;                     ...      */
S                    if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
S                        (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
S
S                        if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
S                            pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
S                        }
S                       *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
S                        nbr_neg_fmtd = DEF_YES;
S                    }
S
S                    if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
S                        dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
S                       *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
S
S                        nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
S
S                    } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
S                               (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
S                       *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
S                    }
S
S                } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
S                           (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
S                           (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
S
S                   *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
S                    nbr_neg_fmtd = DEF_YES;
S
S                } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
S                   *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
S                    lead_char_fmtd = DEF_YES;
S                }
S
S                dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
S
S            } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
S               *pstr_fmt++ = '0';
S            }
S
S        } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
S           *pstr_fmt++ = '?';
S        }
S    }
S
S
S/*$PAGE*/
S    if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
S        if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
S            if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
S                if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
S                    (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
S                    *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
S                } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
S                    *pstr_fmt++ = '0';
S                }
S            } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
S                *pstr_fmt++ = '?';
S            }
S        }
S
S        if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
S           *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
S        } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
S           *pstr_fmt++ = '?';
S        }
S
S        dp_exp = 10.0f;
S        for (i = 0u; i < nbr_dp; i++) {
S            if (fmt_invalid == DEF_NO) {
S                                                                /* If nbr sig digs < max, fmt str dps;    ...           */
S                if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
S                    nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
S                    dig_val     = (CPU_INT32U)(nbr_shiftd % 10u);
S                   *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
S                    dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
S
S                    if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
S                        (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
S                         nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
S                    }
S
S                } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
S                   *pstr_fmt++ = '0';
S                }
S
S            } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
S               *pstr_fmt++ = '?';
S            }
S        }
S    }
S
S
S    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
S       *pstr_fmt = (CPU_CHAR)'\0';
S    }
S
S
S    if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
S        return ((CPU_CHAR *)0);
S    }
S
S
S    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
S}
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        Str_ParseNbr_Int32U()
N*
N* Description : Parse 32-bit unsigned integer from string.
N*
N* Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
N*
N*               pstr_next   Optional pointer to a variable to ... :
N*
N*                               (a) Return a pointer to first character following the integer string,
N*                                       if NO error(s) [see Note #2a2B2];
N*                               (b) Return a pointer to 'pstr',
N*                                       otherwise      (see Note #2a2A2).
N*
N*               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
N*
N* Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
N*
N*               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
N*
N*               0,                   otherwise                            (see Note #2a3B).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
N*                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
N*                       to a type unsigned long ... representation" :
N*
N*                       (1) "First, they decompose the input string into three parts" :
N*
N*                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
N*                                by isspace()]."
N*
N*                               (1) "The subject sequence is defined as the longest initial subsequence of the
N*                                    input string, starting with the first non-white-space character that is of
N*                                    the expected form.  The subject sequence shall contain no characters if the
N*                                    input string is empty or consists entirely of white-space characters."
N*
N*                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
N*                                    determined by the value of 'base' ('nbr_base')" :
N*
N*                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
N*                                        subject sequence is that of a decimal constant, octal constant, or 
N*                                        hexadecimal constant" :
N*
N*                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
N*                                            sequence of decimal digits."
N*
N*                                       (2) "An octal constant consists of the prefix '0' optionally followed by
N*                                            a sequence of the digits '0' to '7' only."
N*
N*                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
N*                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
N*                                            (or 'F') with values 10 to 15 respectively."
N*
N*                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
N*                                        of the subject sequence is a sequence of letters and digits representing 
N*                                        an integer with the radix specified by 'base' ('nbr_base')" :
N*
N*                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
N*                                                ascribed the values 10 to 35"; ...
N*                                           (B) "only letters whose ascribed values are less than that of base
N*                                                are permitted."
N*
N*                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
N*                                                '0X' may optionally precede the sequence of letters and digits."
N*
N*                                           (B) Although NO specification states that "if the value of 'base' 
N*                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
N*                                               the sequence of letters and digits"; it seems reasonable to 
N*                                               allow the '0' character to be optionally parsed.
N*
N*                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
N*
N*                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
N*                                       integer string into an unsigned integer.
N*
N*                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
N*                                   (b) "including the terminating null byte of the input string" ...
N*                               (2) "other than a sign or a permissible letter or digit."
N*$PAGE*
N*                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
N*
N*                           (A) "If the subject sequence is empty or does not have the expected form" :
N*
N*                               (1) "no conversion [is] performed"; ...
N*                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr' 
N*                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
N*
N*                           (B) "If the subject sequence has the expected form" :
N*
N*                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
N*                                        starting with the first digit shall be interpreted as an integer constant."
N*
N*                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
N*                                        used as the base for conversion, ascribing to each letter its value as 
N*                                        given above" (see Note #2a1B1b1A).
N*
N*                               (2) "A pointer to the final string shall be stored in the object pointed to by
N*                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
N*                                   pointer."
N*
N*                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
N*
N*                           (A) "Upon successful completion, these functions shall return the converted value."
N*                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
N*                                    ... shall be returned."
N*
N*                           (B) "If no conversion could be performed, 0 shall be returned."
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           shall fail if" :
N*
N*                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
N*
N*                           (B) "[ERANGE] - The value to be returned is not representable."
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           may fail if" :
N*
N*                           (A) "[EINVAL] - No conversion could be performed."
N*
N*               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
N*
N*                   (a) Valid parse string integer :
N*
N*                           pstr      = "     ABCDE xyz"
N*                           nbr_base  = 16
N*
N*                           nbr       = 703710
N*                           pstr_next = " xyz"
N*
N*
N*                   (b) Invalid parse string integer :
N*
N*                           pstr      = "     ABCDE"
N*                           nbr_base  = 10
N*
N*                           nbr       =  0
N*                           pstr_next = pstr = "     ABCDE"
N*
N*
N*                   (c) Valid hexadecimal parse string integer :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  = 16
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (d) Valid decimal parse string integer ('0x' prefix ignored
N*                               following invalid hexadecimal characters) :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (e) Valid decimal parse string integer ('0'  prefix ignored
N*                               following invalid octal       characters) :
N*
N*                           pstr      = "     0GABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "GABCDE"
N*
N*$PAGE*
N*                   (f) Parse string integer overflow :
N*
N*                           pstr      = "   12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = DEF_INT_32U_MAX_VAL
N*                           pstr_next = "*123456"
N*
N*
N*                   (g) Invalid negative unsigned parse string :
N*
N*                           pstr      = "  -12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = 0
N*                           pstr_next = pstr = "  -12345678901234567890*123456"
N*
N*********************************************************************************************************
N*/
N
NCPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
N                                        CPU_CHAR    **pstr_next,
N                                        CPU_INT08U    nbr_base)
N{
N    CPU_INT32U  nbr;
N
N
N    nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
N                                            pstr_next,
N                                            nbr_base,
N                                            DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
X                                            0u,              
N                             (CPU_BOOLEAN *)0);
N
N    return (nbr);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        Str_ParseNbr_Int32S()
N*
N* Description : Parse 32-bit signed integer from string.
N*
N* Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
N*
N*               pstr_next   Optional pointer to a variable to ... :
N*
N*                               (a) Return a pointer to first character following the integer string,
N*                                       if NO error(s) [see Note #2a2B2];
N*                               (b) Return a pointer to 'pstr',
N*                                       otherwise      (see Note #2a2A2).
N*
N*               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
N*
N* Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
N*
N*               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
N*
N*               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
N*
N*               0,                   otherwise                                    (see Note #2a3B).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
N*                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
N*                       to a type long ... representation" :
N*
N*                       (1) "First, they decompose the input string into three parts" :
N*
N*                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
N*                                by isspace()]."
N*
N*                               (1) "The subject sequence is defined as the longest initial subsequence of the
N*                                    input string, starting with the first non-white-space character that is of
N*                                    the expected form.  The subject sequence shall contain no characters if the
N*                                    input string is empty or consists entirely of white-space characters."
N*
N*                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
N*                                    determined by the value of 'base' ('nbr_base')" :
N*
N*                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
N*                                        subject sequence is that of a decimal constant, octal constant, or 
N*                                        hexadecimal constant" :
N*
N*                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
N*                                            sequence of decimal digits."
N*
N*                                       (2) "An octal constant consists of the prefix '0' optionally followed by
N*                                            a sequence of the digits '0' to '7' only."
N*
N*                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
N*                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
N*                                            (or 'F') with values 10 to 15 respectively."
N*
N*                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
N*                                        of the subject sequence is a sequence of letters and digits representing 
N*                                        an integer with the radix specified by 'base' ('nbr_base')" :
N*
N*                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
N*                                                ascribed the values 10 to 35"; ...
N*                                           (B) "only letters whose ascribed values are less than that of base
N*                                                are permitted."
N*
N*                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
N*                                                '0X' may optionally precede the sequence of letters and digits."
N*
N*                                           (B) Although NO specification states that "if the value of 'base' 
N*                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
N*                                               the sequence of letters and digits"; it seems reasonable to 
N*                                               allow the '0' character to be optionally parsed.
N*
N*                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
N*
N*                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
N*                                       integer string into an unsigned integer.
N*
N*                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
N*                                   (b) "including the terminating null byte of the input string" ...
N*                               (2) "other than a sign or a permissible letter or digit."
N*$PAGE*
N*                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
N*
N*                           (A) "If the subject sequence is empty or does not have the expected form" :
N*
N*                               (1) "no conversion is performed"; ...
N*                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
N*                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
N*
N*                           (B) "If the subject sequence has the expected form" :
N*
N*                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
N*                                        starting with the first digit shall be interpreted as an integer constant."
N*
N*                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
N*                                        used as the base for conversion, ascribing to each letter its value as 
N*                                        given above" (see Note #2a1B1b1A).
N*
N*                               (2) "A pointer to the final string shall be stored in the object pointed to by
N*                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
N*                                   pointer."
N*
N*                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
N*
N*                           (A) "Upon successful completion, these functions shall return the converted value."
N*
N*                               (1) "If the correct value is outside the range of representable values", either
N*                                    of the following "shall be returned" :
N*                                   (a) "{LONG_MIN}" or ...
N*                                   (b) "{LONG_MAX}"
N*
N*                           (B) "If no conversion could be performed, 0 shall be returned."
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           shall fail if" :
N*
N*                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
N*
N*                           (B) "[ERANGE] - The value to be returned is not representable."
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           may fail if" :
N*
N*                           (A) "[EINVAL] - No conversion could be performed."
N*
N*               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
N*
N*                   (a) Valid parse string integer :
N*
N*                           pstr      = "     ABCDE xyz"
N*                           nbr_base  = 16
N*
N*                           nbr       = 703710
N*                           pstr_next = " xyz"
N*
N*
N*                   (b) Invalid parse string integer :
N*
N*                           pstr      = "     ABCDE"
N*                           nbr_base  = 10
N*
N*                           nbr       =  0
N*                           pstr_next = pstr = "     ABCDE"
N*
N*
N*                   (c) Valid hexadecimal parse string integer :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  = 16
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (d) Valid decimal parse string integer ('0x' prefix ignored
N*                               following invalid hexadecimal characters) :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (e) Valid decimal parse string integer ('0'  prefix ignored
N*                               following invalid octal       characters) :
N*
N*                           pstr      = "     0GABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "GABCDE"
N*
N*$PAGE*
N*                   (f) Parse string integer overflow :
N*
N*                           pstr      = "   12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = DEF_INT_32S_MAX_VAL
N*                           pstr_next = "*123456"
N*
N*
N*                   (g) Parse string integer underflow :
N*
N*                           pstr      = "  -12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = DEF_INT_32S_MIN_VAL
N*                           pstr_next = "*123456"
N*
N*********************************************************************************************************
N*/
N
NCPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
N                                        CPU_CHAR    **pstr_next,
N                                        CPU_INT08U    nbr_base)
N{
N    CPU_INT32S   nbr;
N    CPU_INT32U   nbr_abs;
N    CPU_BOOLEAN  nbr_neg;
N
N
N    nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
N                                 pstr_next,
N                                 nbr_base,
N                                 DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
X                                 1u,                        
N                                &nbr_neg);
N
N    if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
X    if (nbr_neg == 0u) {                                     
N        nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
X        nbr = (nbr_abs > (CPU_INT32U) 2147483647)          ?  (CPU_INT32S)2147483647
N                                                                    :  (CPU_INT32S)nbr_abs;
N    } else {
N        nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
X        nbr = (nbr_abs > (CPU_INT32U)-(-2147483647)) ?  (CPU_INT32S)((-2147483647) - 1)
N                                                                    : -(CPU_INT32S)nbr_abs;
N    }
N
N    return (nbr);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*********************************************************************************************************
N*                                           LOCAL FUNCTIONS
N*********************************************************************************************************
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         Str_FmtNbr_Int32()
N*
N* Description : Format 32-bit integer into a multi-digit character string.
N*
N* Argument(s) : nbr             Number           to format.
N*
N*               nbr_dig         Number of digits to format (see Note #1).
N*
N*               nbr_base        Base   of number to format (see Note #2).
N*
N*               nbr_neg         Indicates whether number to format is negative :
N*               -------
N*                                   DEF_NO          Number is non-negative.
N*                                   DEF_YES         Number is     negative.
N*
N*                               Argument validated in Str_FmtNbr_Int32U(),
N*                                                     Str_FmtNbr_Int32S().
N*
N*               lead_char       Prepend leading character  (see Note #3) :
N*
N*                                   '\0'                    Do NOT prepend leading character to string.
N*                                     Printable character          Prepend leading character to string.
N*                                   Unprintable character   Format invalid string (see Note #6e).
N*
N*               lower_case      Format alphabetic characters (if any) in lower case :
N*
N*                                   DEF_NO          Format alphabetic characters in upper case.
N*                                   DEF_YES         Format alphabetic characters in lower case.
N*
N*               nul             Append terminating NULL-character (see Note #4) :
N*
N*                                   DEF_NO          Do NOT append terminating NULL-character to string.
N*                                   DEF_YES                Append terminating NULL-character to string.
N*
N*               pstr            Pointer to character array to return formatted number string (see Note #5).
N*
N* Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
N*
N*               Pointer to NULL,             otherwise.
N*
N* Caller(s)   : Str_FmtNbr_Int32U(),
N*               Str_FmtNbr_Int32S().
N*$PAGE*
N* Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
N*
N*
N*                               Maximum Number of             [  log (Number)      ]
N*                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
N*                                   to Format                 [   log (Base)       ]
N*
N*                               where
N*                                       Number                  Number to format
N*                                       Base            Base of number to format
N*
N*                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
N*                           is performed except possible NULL-termination of the string (see Note #4).
N*
N*                               Example :
N*
N*                                   nbr      = -23456
N*                                   nbr_dig  =  0
N*                                   nbr_base = 10
N*
N*                                   pstr     = ""                   See Note #7a
N*
N*                       (2) If the number of digits to format ('nbr_dig') is less than the number of 
N*                           significant integer digits of the number to format ('nbr'); then an invalid 
N*                           string is formatted instead of truncating any significant integer digits.
N*
N*                               Example :
N*
N*                                   nbr      = 23456
N*                                   nbr_dig  = 3
N*                                   nbr_base = 10
N*
N*                                   pstr     = "???"                See Note #7b
N*
N*                       (3) If the number to format ('nbr') is negative but the number of digits to format 
N*                           ('nbr_dig') is equal to the number of significant integer digits of the number 
N*                           to format ('nbr'); then an invalid string is formatted instead of truncating 
N*                           the negative sign.
N*
N*                               Example :
N*
N*                                   nbr      = -23456
N*                                   nbr_dig  =  5
N*                                   nbr_base = 10
N*
N*                                   pstr     = "?????"              See Note #7b
N*
N*               (2) The number's base MUST be between 2 & 36, inclusive.
N*$PAGE*
N*               (3) Leading character option prepends leading characters prior to the first non-zero digit.
N*
N*                   (a) (1) Leading character MUST be a printable ASCII character.
N*
N*                       (2) (A) Leading character MUST NOT be a number base digit, ...
N*                           (B) with the exception of '0'.
N*
N*                   (b) (1) The number of leading characters is such that the total number of significant 
N*                           integer digits plus the number of leading characters plus possible negative 
N*                           sign character is equal to the requested number of integer digits to format 
N*                           ('nbr_dig').
N*
N*                               Examples :
N*
N*                                   nbr       = 23456
N*                                   nbr_dig   = 7
N*                                   nbr_base  = 10
N*                                   lead_char = ' '
N*
N*                                   pstr      = "  23456"
N*
N*
N*                                   nbr       = -23456
N*                                   nbr_dig   = 7
N*                                   nbr_base  = 10
N*                                   lead_char = ' '
N*
N*                                   pstr      = " -23456"
N*
N*                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is     a '0' digit; then the negative sign character 
N*                               prefixes all leading characters prior to the formatted number.
N*
N*                                   Examples :
N*
N*                                       nbr        = -23456
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 10
N*                                       lead_char  = '0'
N*
N*                                       pstr       = "-0023456"
N*
N*
N*                                       nbr        = -43981
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 16
N*                                       lead_char  = '0'
N*                                       lower_case = DEF_NO
N*
N*                                       pstr       = "-000ABCD"
N*
N*                           (B) If the number to format ('nbr') is negative AND the leading character 
N*                               ('lead_char') is NOT a '0' digit; then the negative sign character 
N*                               immediately prefixes the most significant digit of the formatted number.
N*
N*                                   Examples :
N*
N*                                       nbr        = -23456
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 10
N*                                       lead_char  = '#'
N*
N*                                       pstr       = "##-23456"
N*
N*
N*                                       nbr        = -43981
N*                                       nbr_dig    =  8
N*                                       nbr_base   = 16
N*                                       lead_char  = '#'
N*                                       lower_case = DEF_YES
N*
N*                                       pstr       = "###-abcd"
N*
N*                   (c) (1) If the value of the number to format is     zero  ...
N*                       (2) ... & the number of digits to format is non-zero, ...
N*                       (3) ... but NO leading character available;           ...
N*                       (4) ... then one digit of '0' value is formatted.
N*
N*                           This is NOT a leading character; but a single integer digit of '0' value.
N*$PAGE*
N*               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
N*                       array formatting.
N*
N*                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
N*                       terminate option DISABLED will cause character string run-on.
N*
N*               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (b) To prevent character buffer overrun :
N*
N*                           Character array size MUST be  >=  ('nbr_dig'          +
N*                                                               1 negative sign   +
N*                                                               1 'NUL' terminator)  characters
N*
N*               (6) String format terminates when :
N*
N*                   (a) Format string pointer is passed a NULL pointer.
N*                       (1) No      string formatted;                NULL pointer returned.
N*
N*                   (b) Number of digits to format ('nbr_dig') is zero.
N*                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
N*
N*                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
N*                           integer digits of the number to format ('nbr'), including possible 
N*                           negative sign.
N*                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
N*
N*                   (d) Base is passed an invalid base (see Note #2).
N*                       (1) Invalid string format performed; NULL pointer returned.
N*
N*                   (e) Lead character is NOT a valid, printable character (see Note #3a).
N*                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
N*
N*                   (f) Number successfully formatted into character string array.
N*
N*               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
N*                   ('?') will be formatted, where the number of question marks is determined by the 
N*                   number of digits to format ('nbr_dig') :
N*
N*                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
N*                          number of     =  {
N*                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
N*
N*********************************************************************************************************
N*/
N
Nstatic  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
N                                     CPU_INT08U    nbr_dig,
N                                     CPU_INT08U    nbr_base,
N                                     CPU_BOOLEAN   nbr_neg,
N                                     CPU_CHAR      lead_char,
N                                     CPU_BOOLEAN   lower_case,
N                                     CPU_BOOLEAN   nul,
N                                     CPU_CHAR     *pstr)
N{
N    CPU_CHAR     *pstr_fmt;
N    CPU_DATA      i;
N    CPU_INT32U    nbr_fmt;
N    CPU_INT32U    nbr_log;
N    CPU_INT08U    nbr_dig_max;
N    CPU_INT08U    nbr_dig_min;
N    CPU_INT08U    nbr_dig_fmtd;
N    CPU_INT08U    nbr_neg_sign;
N    CPU_INT08U    nbr_lead_char;
N    CPU_INT08U    dig_val;
N    CPU_INT08U    lead_char_delta_0;
N    CPU_INT08U    lead_char_delta_a;
N    CPU_BOOLEAN   lead_char_dig;
N    CPU_BOOLEAN   lead_char_0;
N    CPU_BOOLEAN   fmt_invalid;
N    CPU_BOOLEAN   print_char;
N    CPU_BOOLEAN   nbr_neg_fmtd;
N
N
N/*$PAGE*/
N                                                                /* ---------------- VALIDATE FMT ARGS ----------------- */
N    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
N        return ((CPU_CHAR *)0);
N    }
N
N    fmt_invalid = DEF_NO;
X    fmt_invalid = 0u;
N
N    if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
N        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
X        fmt_invalid = 1u;                                   
N    }
N                                                                /* If invalid base, ...                                 */
N    if ((nbr_base <  2u) ||
N        (nbr_base > 36u)) {
N        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
X        fmt_invalid = 1u;                                   
N    }
N
N    if (lead_char != (CPU_CHAR)'\0') {
N        print_char =  ASCII_IsPrint(lead_char);
N        if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
X        if (print_char != 1u) {                             
N            fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
X            fmt_invalid = 1u;                               
N
N        } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
N            lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
N            if (lower_case != DEF_YES) {
X            if (lower_case != 1u) {
N                lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
N            } else {
N                lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
N            }
N
N            lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
N                             ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
N                                                    (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
X                                                    (lead_char_delta_a < (nbr_base - 10u))))) ? 1u : 0u;
N
N            if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
X            if (lead_char_dig == 1u) {                      
N                fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
X                fmt_invalid = 1u;                           
N            }
N        }
N    }
N
N
N                                                                /* ----------------- PREPARE NBR FMT ------------------ */
N    pstr_fmt = pstr;
N
N    if (fmt_invalid == DEF_NO) {
X    if (fmt_invalid == 0u) {
N        nbr_fmt     = nbr;
N        nbr_log     = nbr;
N        nbr_dig_max = 1u;
N        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
N            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
N            nbr_log /= nbr_base;
N        }
N
N        nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
X        nbr_neg_sign = (nbr_neg == 1u) ? 1u : 0u;
N        if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
N            nbr_neg_fmtd = DEF_NO;
X            nbr_neg_fmtd = 0u;
N            nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
X            nbr_dig_min  = (((nbr_dig_max) < (nbr_dig)) ? (nbr_dig_max) : (nbr_dig));
N                                                                /* ... calc nbr digs to fmt & nbr lead chars.           */
N            if (lead_char != (CPU_CHAR)'\0') {
N                nbr_dig_fmtd  = nbr_dig;
N                nbr_lead_char = nbr_dig     -
N                                nbr_dig_min - nbr_neg_sign;
N            } else {
N                nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
N                nbr_lead_char = 0u;
N            }
N
N            if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
N                lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
N                            ?  DEF_YES : DEF_NO;
X                            ?  1u : 0u;
N            } else {
N                lead_char_0 =  DEF_NO;
X                lead_char_0 =  0u;
N            }
N
N        } else {                                                /* Else if nbr trunc'd, ...                             */
N            fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
X            fmt_invalid = 1u;                               
N        }
N    }
N
N    if (fmt_invalid != DEF_NO) {
X    if (fmt_invalid != 0u) {
N        nbr_dig_fmtd = nbr_dig;
N    }
N
N
N/*$PAGE*/
N                                                                /* ------------------- FMT NBR STR -------------------- */
N    pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
N
N    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
X    if (nul != 0u) {                                         
N       *pstr_fmt = (CPU_CHAR)'\0';
N    }
N    pstr_fmt--;
N
N
N    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
N        if (fmt_invalid == DEF_NO) {
X        if (fmt_invalid == 0u) {
N            if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
N                (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
N                                                                /* ... calc & fmt dig val;                      ...     */
N                dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
N                if (dig_val < 10u) {
N                   *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
N                } else {
N                    if (lower_case !=  DEF_YES) {
X                    if (lower_case !=  1u) {
N                       *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
N                    } else {
N                       *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
N                    }
N                }
N
N                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
N
N            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
X            } else if ((nbr_neg      == 1u)  &&             
N                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
X                     (((lead_char_0  == 0u )  &&             
N                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
X                       (nbr_neg_fmtd == 0u )) ||             
N                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
X                      ((lead_char_0  != 0u )  &&             
N                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
N
N               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
N                nbr_neg_fmtd = DEF_YES;
X                nbr_neg_fmtd = 1u;
N
N            } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
N               *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
N            }
N
N        } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
N           *pstr_fmt-- = '?';
N        }
N    }
N
N
N    if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
X    if (fmt_invalid != 0u) {                                 
N        return ((CPU_CHAR *)0);
N    }
N
N
N    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        Str_ParseNbr_Int32()
N*
N* Description : Parse 32-bit integer from string.
N*
N* Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
N*
N*               pstr_next       Optional pointer to a variable to ... :
N*
N*                                   (a) Return a pointer to first character following the integer string,
N*                                           if NO error(s) [see Note #2a2B2];
N*                                   (b) Return a pointer to 'pstr',
N*                                           otherwise      (see Note #2a2A2).
N*
N*               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
N*
N*               nbr_signed      Indicates whether number to parse is signed :
N*
N*                                   DEF_NO                  Number is unsigned.
N*                                   DEF_YES                 Number is   signed.
N*
N*               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
N*
N*                                   DEF_NO                  Number is non-negative.
N*                                   DEF_YES                 Number is     negative.
N*
N* Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
N*
N*               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
N*
N*               0,                   otherwise                            (see Note #2a3B).
N*
N* Caller(s)   : Str_ParseNbr_Int32U(),
N*               Str_ParseNbr_Int32S().
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
N*                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
N*                       to a type long ... representation" :
N*
N*                       (1) "First, they decompose the input string into three parts" :
N*
N*                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
N*                                by isspace()]."
N*
N*                               (1) "The subject sequence is defined as the longest initial subsequence of the
N*                                    input string, starting with the first non-white-space character that is of
N*                                    the expected form.  The subject sequence shall contain no characters if the
N*                                    input string is empty or consists entirely of white-space characters."
N*
N*                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
N*                                    determined by the value of 'base' ('nbr_base')" :
N*
N*                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
N*                                        subject sequence is that of a decimal constant, octal constant, or 
N*                                        hexadecimal constant" :
N*
N*                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
N*                                            sequence of decimal digits."
N*
N*                                       (2) "An octal constant consists of the prefix '0' optionally followed by
N*                                            a sequence of the digits '0' to '7' only."
N*
N*                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
N*                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
N*                                            (or 'F') with values 10 to 15 respectively."
N*
N*                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
N*                                        of the subject sequence is a sequence of letters and digits representing 
N*                                        an integer with the radix specified by 'base' ('nbr_base')" :
N*
N*                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
N*                                                ascribed the values 10 to 35"; ...
N*                                           (B) "only letters whose ascribed values are less than that of base
N*                                                are permitted."
N*
N*                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
N*                                               '0X' may optionally precede the sequence of letters and digits."
N*
N*                                           (B) Although NO specification states that "if the value of 'base' 
N*                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
N*                                               the sequence of letters and digits"; it seems reasonable to 
N*                                               allow the '0' character to be optionally parsed.
N*$PAGE*
N*                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
N*
N*                                   (a) It does NOT seem reasonable to parse & convert a negative number
N*                                       integer string into an unsigned integer.  However, a negative sign
N*                                       for an unsigned integer will automatically be parsed as an invalid
N*                                       character (see Note #2aC1).
N*
N*                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
N*                                   (b) "including the terminating null byte of the input string" ...
N*                               (2) "other than a sign or a permissible letter or digit."
N*
N*                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
N*
N*                           (A) "If the subject sequence is empty or does not have the expected form" :
N*
N*                               (1) "no conversion is performed"; ...
N*                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
N*                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
N*
N*                           (B) "If the subject sequence has the expected form" :
N*
N*                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
N*                                        starting with the first digit shall be interpreted as an integer constant."
N*
N*                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
N*                                        used as the base for conversion, ascribing to each letter its value as 
N*                                        given above" (see Note #2a1B1b1A).
N*
N*                               (2) "A pointer to the final string shall be stored in the object pointed to by
N*                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
N*                                   pointer."
N*
N*                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
N*
N*                           (A) "Upon successful completion, these functions shall return the converted value."
N*                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
N*                                    [or] {LONG_MAX} ... shall be returned."
N*
N*                           (B) "If no conversion could be performed, 0 shall be returned."
N*
N*                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           shall fail if" :
N*
N*                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
N*
N*                           (B) "[ERANGE] - The value to be returned is not representable."
N*
N*                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
N*                           may fail if" :
N*
N*                           (A) "[EINVAL] - No conversion could be performed."
N*$PAGE*
N*               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
N*
N*                   (a) Valid parse string integer :
N*
N*                           pstr      = "     ABCDE xyz"
N*                           nbr_base  = 16
N*
N*                           nbr       = 703710
N*                           pstr_next = " xyz"
N*
N*
N*                   (b) Invalid parse string integer :
N*
N*                           pstr      = "     ABCDE"
N*                           nbr_base  = 10
N*
N*                           nbr       =  0
N*                           pstr_next = pstr = "     ABCDE"
N*
N*
N*                   (c) Valid hexadecimal parse string integer :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  = 16
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (d) Valid decimal parse string integer ('0x' prefix ignored
N*                               following invalid hexadecimal characters) :
N*
N*                           pstr      = "     0xGABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "xGABCDE"
N*
N*
N*                   (e) Valid decimal parse string integer ('0'  prefix ignored
N*                               following invalid octal       characters) :
N*
N*                           pstr      = "     0GABCDE"
N*                           nbr_base  =  0
N*
N*                           nbr       =  0
N*                           pstr_next = "GABCDE"
N*
N*
N*                   (f) Parse string integer overflow :
N*
N*                           pstr      = "   12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = DEF_INT_32U_MAX_VAL
N*                           pstr_next = "*123456"
N*
N*
N*                   (g) Parse string integer underflow :
N*
N*                           pstr      = "  -12345678901234567890*123456"
N*                           nbr_base  = 10
N*
N*                           nbr       = DEF_INT_32S_MIN_VAL
N*                           pstr_next = "*123456"
N*
N*
N*               (4) String parse terminates when :
N*
N*                   (a) Base passed an invalid base (see Note #2a1B1b).
N*                       (1) No conversion performed; 0 returned.
N*
N*                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
N*                           (A) No conversion performed; 0 returned.
N*
N*                       (2) Invalid parse string character found (see Note #2a1C).
N*                           (A) Parsed integer returned.
N*                           (B) 'pstr_next' points to invalid character.
N*
N*                       (3) Entire  parse string converted (see Note #2a2B).
N*                           (A) Parsed integer returned.
N*                           (B) 'pstr_next' points to terminating NULL character.
N*
N*               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
N*                   validation or function handling in case of any error(s).
N*********************************************************************************************************
N*/
N/*$PAGE*/
Nstatic  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
N                                               CPU_CHAR     **pstr_next,
N                                               CPU_INT08U     nbr_base,
N                                               CPU_BOOLEAN    nbr_signed,
N                                               CPU_BOOLEAN   *pnbr_neg)
N{
N    const  CPU_CHAR     *pstr_parse;
N    const  CPU_CHAR     *pstr_parse_nbr;
N           CPU_CHAR     *pstr_parse_unused;
N           CPU_CHAR      parse_char;
N           CPU_INT08U    parse_dig;
N           CPU_INT32U    nbr;
N           CPU_BOOLEAN   nbr_neg_unused;
N           CPU_BOOLEAN   nbr_dig;
N           CPU_BOOLEAN   nbr_alpha;
N           CPU_BOOLEAN   nbr_hex;
N           CPU_BOOLEAN   nbr_hex_lower;
N           CPU_BOOLEAN   whitespace;
N           CPU_BOOLEAN   neg;
N           CPU_BOOLEAN   ovf;
N           CPU_BOOLEAN   done;
N
N                                                                /* --------------- VALIDATE PARSE ARGS ---------------- */
N    if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
N        pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
N       (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
N    }
N   *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
N
N    if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
N        pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
N       (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
N    }
N   *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
X   *pnbr_neg = 0u;                                           
N
N
N    if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
N        return (0u);
N    }
N                                                                /* Rtn zero if invalid base (see Note #4a).             */
N    if ((nbr_base == 1u) ||
N        (nbr_base > 36u)) {
N        return (0u);
N    }
N
N
N                                                                /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
N    pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
N
N    whitespace = ASCII_IsSpace(*pstr_parse);
N    while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
X    while (whitespace == 1u) {                              
N        pstr_parse++;
N        whitespace = ASCII_IsSpace(*pstr_parse);
N    }
N
N    switch (*pstr_parse) {
N        case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
N             pstr_parse++;
N             neg = DEF_NO;
X             neg = 0u;
N             break;
N
N
N        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
N             if (nbr_signed == DEF_YES) {
X             if (nbr_signed == 1u) {
N                 pstr_parse++;
N             }
N             neg = DEF_YES;
X             neg = 1u;
N             break;
N
N
N        default:
N             neg = DEF_NO;
X             neg = 0u;
N             break;
N    }
N
N
N/*$PAGE*/
N                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
N    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
N
N    switch (nbr_base) {
N        case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
N             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
N                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
N                  switch (*pstr_parse) {
N                      case 'x':                                 /* For '0x' prefix, ...                                 */
N                      case 'X':
N                           nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
N                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
N                           nbr_hex    =  ASCII_IsDigHex(parse_char);
N                           if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
X                           if (nbr_hex == 1u) {             
N                               pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
N                           }
N                           break;
N
N
N                      default:                                  /* For '0'  prefix, ...                                 */
N                           nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
N                           break;
N                  }
N
N             } else {                                           /* For non-'0' prefix, ...                              */
N                 nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
N             }
N             break;
N
N
N        case  8u:                                               /* See Note #2a1B1a2.                                   */
N             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
N                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
N             }
N             break;
N
N
N        case 16u:                                               /* See Note #2a1B1a3.                                   */
N             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
N                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
N                  switch (*pstr_parse) {
N                      case 'x':
N                      case 'X':
N                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
N                           nbr_hex    =  ASCII_IsDigHex(parse_char);
N                           if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
X                           if (nbr_hex == 1u) {             
N                               pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
N                           }
N                           break;
N
N
N                      default:
N                           break;
N                  }
N             }
N             break;
N
N
N        default:                                                /* See Note #2a1B1b.                                    */
N             break;
N    }
N
N
N/*$PAGE*/
N                                                                /* ------------------ PARSE INT STR ------------------- */
N    nbr  = 0u;
N    ovf  = DEF_NO;
X    ovf  = 0u;
N    done = DEF_NO;
X    done = 0u;
N
N    while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
X    while (done == 0u) {                                     
N        parse_char = (CPU_CHAR)*pstr_parse;
N        nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
N        if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
X        if (nbr_alpha == 1u) {                              
N                                                                /* ... convert parse char into nbr dig.                 */
N            nbr_dig = ASCII_IsDig(parse_char);
N            if (nbr_dig == DEF_YES) {
X            if (nbr_dig == 1u) {
N                parse_dig = (CPU_INT08U)(parse_char - '0');
N            } else {
N                nbr_hex_lower = ASCII_IsLower(parse_char);
N                if (nbr_hex_lower == DEF_YES) {
X                if (nbr_hex_lower == 1u) {
N                    parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
N                } else {
N                    parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
N                }
N            }
N
N            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
N                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
X                if (ovf == 0u) {                             
N                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
N                                                                /* ... merge parse char dig into nbr.                   */
N                        nbr *= nbr_base;
N                        nbr += parse_dig;
N                        if (nbr < parse_dig) {
N                            ovf = DEF_YES;
X                            ovf = 1u;
N                        }
N                    } else {
N                        ovf = DEF_YES;
X                        ovf = 1u;
N                    }
N                }
N                pstr_parse++;
N
N            } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
N                done = DEF_YES;
X                done = 1u;
N            }
N
N        } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
N            done = DEF_YES;
X            done = 1u;
N        }
N    }
N
N    if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
X    if (ovf == 1u) {                                        
N        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
X        nbr  = 4294967295u;                              
N    }
N
N
N    if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
N       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
N    } else {
N       *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
N    }
N
N   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
N
N
N    return (nbr);
N}
N
