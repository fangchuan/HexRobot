; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I..\..\User\bsp_stm32f4xx\flash -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_spi_bus.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;77     */
;;;78     void bsp_InitSPIBus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;79     {
;;;80     #ifdef SOFT_SPI		/* 软件SPI */
;;;81     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;82     
;;;83     	/* 打开GPIO时钟 */
;;;84     	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);
;;;85     
;;;86     	/* 配置几个推完输出IO */
;;;87     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
;;;88     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;89     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
;;;90     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 */
;;;91     
;;;92     	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
;;;93     	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
;;;96     	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
;;;97     
;;;98     	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;99     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
;;;100    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;101    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
;;;102    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 */
;;;103    
;;;104    	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
;;;105    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
;;;106    #endif
;;;107    
;;;108    #ifdef HARD_SPI
;;;109    	/* 硬件SPI */
;;;110    	GPIO_InitTypeDef  GPIO_InitStructure;
;;;111    
;;;112    	/* 开启GPIO时钟 */
;;;113    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;114    
;;;115    
;;;116    	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;117    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI3);
;;;118    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI3);
;;;119    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI3);
;;;120    	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;121    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
00000a  2205              MOVS     r2,#5
00000c  2103              MOVS     r1,#3
00000e  481c              LDR      r0,|L1.128|
000010  f7fffffe          BL       GPIO_PinAFConfig
;;;122    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
000014  2205              MOVS     r2,#5
000016  2104              MOVS     r1,#4
000018  4819              LDR      r0,|L1.128|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;123    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
00001e  2205              MOVS     r2,#5
000020  4611              MOV      r1,r2
000022  4817              LDR      r0,|L1.128|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;124    
;;;125    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000028  2002              MOVS     r0,#2
00002a  f88d0004          STRB     r0,[sp,#4]
;;;126    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
00002e  2001              MOVS     r0,#1
000030  f88d0005          STRB     r0,[sp,#5]
;;;127    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000034  2000              MOVS     r0,#0
000036  f88d0006          STRB     r0,[sp,#6]
;;;128    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00003a  f88d0007          STRB     r0,[sp,#7]
;;;129    
;;;130    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
00003e  2038              MOVS     r0,#0x38
000040  9000              STR      r0,[sp,#0]
;;;131    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  480e              LDR      r0,|L1.128|
000046  f7fffffe          BL       GPIO_Init
;;;132    
;;;133    	/* 打开SPI时钟 */
;;;134    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  0308              LSLS     r0,r1,#12
00004e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;135    	
;;;136    	bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
000052  f44f704b          MOV      r0,#0x32c
000056  f7fffffe          BL       bsp_SPI_Init
;;;137    		| SPI_CPOL_Low | SPI_CPHA_1Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_64 | SPI_FirstBit_MSB);	
;;;138    	
;;;139    	/* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;140    	SPI_HARD->I2SCFGR &= SPI_Mode_Select;		/* 选择SPI模式，不是I2S模式 */
00005a  480a              LDR      r0,|L1.132|
00005c  8b80              LDRH     r0,[r0,#0x1c]
00005e  f24f71ff          MOV      r1,#0xf7ff
000062  4008              ANDS     r0,r0,r1
000064  4907              LDR      r1,|L1.132|
000066  8388              STRH     r0,[r1,#0x1c]
;;;141    
;;;142    	/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;143    	/* Write to SPIx CRCPOLY */
;;;144    	SPI_HARD->CRCPR = 7;		/* 一般不用 */
000068  2007              MOVS     r0,#7
00006a  8208              STRH     r0,[r1,#0x10]
;;;145    
;;;146    
;;;147    	SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */
00006c  2100              MOVS     r1,#0
00006e  4805              LDR      r0,|L1.132|
000070  f7fffffe          BL       SPI_Cmd
;;;148    
;;;149    	SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */
000074  2101              MOVS     r1,#1
000076  4803              LDR      r0,|L1.132|
000078  f7fffffe          BL       SPI_Cmd
;;;150    #endif	
;;;151    }
00007c  bd1c              POP      {r2-r4,pc}
;;;152    
                          ENDP

00007e  0000              DCW      0x0000
                  |L1.128|
                          DCD      0x40020400
                  |L1.132|
                          DCD      0x40013000

                          AREA ||i.bsp_SPI_Init||, CODE, READONLY, ALIGN=2

                  bsp_SPI_Init PROC
;;;161    #ifdef HARD_SPI		/* 硬件SPI */
;;;162    void bsp_SPI_Init(uint16_t _cr1)
000000  4909              LDR      r1,|L2.40|
;;;163    {
;;;164    	SPI_HARD->CR1 = ((SPI_HARD->CR1 & CR1_CLEAR_Mask) | _cr1);
000002  8809              LDRH     r1,[r1,#0]
000004  f4015141          AND      r1,r1,#0x3040
000008  4301              ORRS     r1,r1,r0
00000a  4a07              LDR      r2,|L2.40|
00000c  8011              STRH     r1,[r2,#0]
;;;165    	  
;;;166    	//SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */	    
;;;167        SPI_HARD->CR1 &= CR1_SPE_Reset;	/* Disable the selected SPI peripheral */
00000e  4611              MOV      r1,r2
000010  8809              LDRH     r1,[r1,#0]
000012  f64f72bf          MOV      r2,#0xffbf
000016  4011              ANDS     r1,r1,r2
000018  4a03              LDR      r2,|L2.40|
00001a  8011              STRH     r1,[r2,#0]
;;;168    
;;;169    	//SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */		    
;;;170        SPI_HARD->CR1 |= CR1_SPE_Set;	  /* Enable the selected SPI peripheral */
00001c  4611              MOV      r1,r2
00001e  8809              LDRH     r1,[r1,#0]
000020  f0410140          ORR      r1,r1,#0x40
000024  8011              STRH     r1,[r2,#0]
;;;171    }
000026  4770              BX       lr
;;;172    #endif
                          ENDP

                  |L2.40|
                          DCD      0x40013000

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;425    */
;;;426    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L3.8|
;;;427    {
;;;428    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;429    }
000004  4770              BX       lr
;;;430    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;399    */
;;;400    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;401    {
;;;402    	g_spi_busy = 1;
000002  4901              LDR      r1,|L4.8|
000004  7008              STRB     r0,[r1,#0]
;;;403    }
000006  4770              BX       lr
;;;404    
                          ENDP

                  |L4.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;412    */
;;;413    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;414    {
;;;415    	g_spi_busy = 0;
000002  4901              LDR      r1,|L5.8|
000004  7008              STRB     r0,[r1,#0]
;;;416    }
000006  4770              BX       lr
;;;417    
                          ENDP

                  |L5.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiRead0||, CODE, READONLY, ALIGN=2

                  bsp_spiRead0 PROC
;;;254    */
;;;255    uint8_t bsp_spiRead0(void)
000000  b510              PUSH     {r4,lr}
;;;256    {
;;;257    #ifdef SOFT_SPI		/* 软件SPI */
;;;258    	uint8_t i;
;;;259    	uint8_t read = 0;
;;;260    
;;;261    	for (i = 0; i < 8; i++)
;;;262    	{
;;;263    		read = read<<1;
;;;264    
;;;265    		if (MISO_IS_HIGH())
;;;266    		{
;;;267    			read++;
;;;268    		}
;;;269    		SCK_1();
;;;270    		bsp_spiDelay();
;;;271    		SCK_0();
;;;272    		bsp_spiDelay();
;;;273    	}
;;;274    	return read;
;;;275    #endif
;;;276    
;;;277    #ifdef HARD_SPI		/* 硬件SPI */
;;;278    	uint8_t read;
;;;279    
;;;280    	/* 等待发送缓冲区空 */
;;;281    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L6.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L6.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L6.4|
;;;282    
;;;283    	/* 发送一个字节 */
;;;284    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L6.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;285    
;;;286    	/* 等待数据接收完毕 */
;;;287    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L6.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L6.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L6.26|
;;;288    
;;;289    	/* 读取接收到的数据 */
;;;290    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L6.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;291    
;;;292    	/* 返回读到的数据 */
;;;293    	return read;
00002e  4620              MOV      r0,r4
;;;294    #endif
;;;295    }
000030  bd10              POP      {r4,pc}
;;;296    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiRead1||, CODE, READONLY, ALIGN=2

                  bsp_spiRead1 PROC
;;;350    */
;;;351    uint8_t bsp_spiRead1(void)
000000  b510              PUSH     {r4,lr}
;;;352    {
;;;353    #ifdef SOFT_SPI		/* 软件SPI */
;;;354    	uint8_t i;
;;;355    	uint8_t read = 0;
;;;356    
;;;357    	for (i = 0; i < 8; i++)
;;;358    	{
;;;359    		SCK_0();
;;;360    		bsp_spiDelay();
;;;361    		read = read<<1;
;;;362    		if (MISO_IS_HIGH())
;;;363    		{
;;;364    			read++;
;;;365    		}
;;;366    		SCK_1();
;;;367    		bsp_spiDelay();
;;;368    	}
;;;369    	return read;
;;;370    #endif
;;;371    
;;;372    #ifdef HARD_SPI		/* 硬件SPI */
;;;373    	uint8_t read;
;;;374    
;;;375    	/* 等待发送缓冲区空 */
;;;376    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L7.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L7.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L7.4|
;;;377    
;;;378    	/* 发送一个字节 */
;;;379    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L7.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;380    
;;;381    	/* 等待数据接收完毕 */
;;;382    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L7.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L7.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L7.26|
;;;383    
;;;384    	/* 读取接收到的数据 */
;;;385    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L7.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;386    
;;;387    	/* 返回读到的数据 */
;;;388    	return read;
00002e  4620              MOV      r0,r4
;;;389    #endif
;;;390    }
000030  bd10              POP      {r4,pc}
;;;391    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWrite0||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite0 PROC
;;;207    */
;;;208    void bsp_spiWrite0(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;209    {
000002  4604              MOV      r4,r0
;;;210    #ifdef SOFT_SPI		/* 软件SPI */
;;;211    	uint8_t i;
;;;212    
;;;213    	for(i = 0; i < 8; i++)
;;;214    	{
;;;215    		if (_ucByte & 0x80)
;;;216    		{
;;;217    			MOSI_1();
;;;218    		}
;;;219    		else
;;;220    		{
;;;221    			MOSI_0();
;;;222    		}
;;;223    		bsp_spiDelay();
;;;224    		SCK_1();
;;;225    		_ucByte <<= 1;
;;;226    		bsp_spiDelay();
;;;227    		SCK_0();
;;;228    	}
;;;229    	bsp_spiDelay();
;;;230    #endif
;;;231    
;;;232    #ifdef HARD_SPI		/* 硬件SPI */
;;;233    	/* 等待发送缓冲区空 */
;;;234    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L8.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L8.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L8.6|
;;;235    
;;;236    	/* 发送一个字节 */
;;;237    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L8.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;238    
;;;239    	/* 等待数据接收完毕 */
;;;240    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L8.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L8.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L8.28|
;;;241    
;;;242    	/* 读取接收到的数据 */
;;;243    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L8.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;244    #endif
;;;245    }
00002e  bd10              POP      {r4,pc}
;;;246    
                          ENDP

                  |L8.48|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWrite1||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite1 PROC
;;;304    */
;;;305    void bsp_spiWrite1(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;306    {
000002  4604              MOV      r4,r0
;;;307    #ifdef SOFT_SPI		/* 软件SPI */
;;;308    	uint8_t i;
;;;309    
;;;310    	for(i = 0; i < 8; i++)
;;;311    	{
;;;312    		if (_ucByte & 0x80)
;;;313    		{
;;;314    			MOSI_1();
;;;315    		}
;;;316    		else
;;;317    		{
;;;318    			MOSI_0();
;;;319    		}
;;;320    		SCK_0();
;;;321    		_ucByte <<= 1;
;;;322    		bsp_spiDelay();
;;;323    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
;;;324    		bsp_spiDelay();
;;;325    	}
;;;326    #endif
;;;327    
;;;328    #ifdef HARD_SPI		/* 硬件SPI */
;;;329    	/* 等待发送缓冲区空 */
;;;330    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L9.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L9.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L9.6|
;;;331    
;;;332    	/* 发送一个字节 */
;;;333    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L9.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;334    
;;;335    	/* 等待数据接收完毕 */
;;;336    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L9.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L9.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L9.28|
;;;337    
;;;338    	/* 读取接收到的数据 */
;;;339    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L9.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;340    #endif
;;;341    }
00002e  bd10              POP      {r4,pc}
;;;342    
                          ENDP

                  |L9.48|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 144
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____RRX|
#line 300
|__asm___13_bsp_spi_bus_c_c88bcf96____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
