; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ra8875_port.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ra8875_port.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uCOS-III\Ports -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\fatfs\src -I..\..\Libraries\CMSIS\Include -I..\..\User\control -I"F:\学习用具\2016毕业设计\V5-610_uCOS-III + emWin + FatFS\Project\MDK-ARM(uV4)\RTE" -I"E:\KEIL MDK5\ARM\PACK\Keil\STM32F4xx_DFP\2.6.0" -I"E:\KEIL MDK5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_ra8875_port.crf ..\..\User\bsp_stm32f4xx\src\bsp_ra8875_port.c]
                          THUMB

                          AREA ||i.RA8875_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  RA8875_ConfigGPIO PROC
;;;30     */
;;;31     void RA8875_ConfigGPIO(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;32     {
;;;33     	static uint8_t s_run_first = 0;
;;;34     	
;;;35     	/* 如果已经运行过，则不再执行 */
;;;36     	if (s_run_first == 1)
000002  4818              LDR      r0,|L1.100|
000004  7800              LDRB     r0,[r0,#0]  ; s_run_first
000006  2801              CMP      r0,#1
000008  d100              BNE      |L1.12|
                  |L1.10|
;;;37     	{
;;;38     		return;
;;;39     	}
;;;40     	
;;;41     	s_run_first = 1;
;;;42     	
;;;43     	/* FSMC在 bsp_tft_lcd.c中已经配置好 */
;;;44     	
;;;45     	
;;;46     	/* RA8875按照SPI接口设置后，通过总线方式依然可以读到0X75的特征，因此不能用来自动识别SPI模式 */
;;;47     	{
;;;48     		uint8_t value;
;;;49     		
;;;50     		g_RA8875_IF = RA_HARD_8080_16;	
;;;51     		RA8875_WriteReg(0x60, 0x1A);	/* 60H寄存器背景色寄存器红色[4:0]低5位有效 */
;;;52     		value = RA8875_ReadReg(0x60);
;;;53     		if (value != 0x1A)
;;;54     		{
;;;55     			RA8875_InitSPI();				/* 配置好SPI接口  */
;;;56     			g_RA8875_IF = RA_HARD_SPI;		/* 识别为 SPI总线 */
;;;57     		}
;;;58     	}
;;;59     	
;;;60     	
;;;61     	{
;;;62     		GPIO_InitTypeDef GPIO_InitStructure;
;;;63     		
;;;64     		/* 使能 GPIO时钟 */
;;;65     		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
;;;66     		
;;;67     		/* PD3 连接到RA8875的BUSY引脚，用来识别芯片内忙 */
;;;68     		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;69     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;70     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;71     		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;72     		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;73     		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;74     		
;;;75     		;
;;;76     	}
;;;77     }
00000a  bd1c              POP      {r2-r4,pc}
                  |L1.12|
00000c  2001              MOVS     r0,#1                 ;41
00000e  4915              LDR      r1,|L1.100|
000010  7008              STRB     r0,[r1,#0]            ;41
000012  2003              MOVS     r0,#3                 ;50
000014  4914              LDR      r1,|L1.104|
000016  7008              STRB     r0,[r1,#0]            ;50
000018  211a              MOVS     r1,#0x1a              ;51
00001a  2060              MOVS     r0,#0x60              ;51
00001c  f7fffffe          BL       RA8875_WriteReg
000020  2060              MOVS     r0,#0x60              ;52
000022  f7fffffe          BL       RA8875_ReadReg
000026  4604              MOV      r4,r0                 ;52
000028  2c1a              CMP      r4,#0x1a              ;53
00002a  d004              BEQ      |L1.54|
00002c  f7fffffe          BL       RA8875_InitSPI
000030  2002              MOVS     r0,#2                 ;56
000032  490d              LDR      r1,|L1.104|
000034  7008              STRB     r0,[r1,#0]            ;56
                  |L1.54|
000036  2101              MOVS     r1,#1                 ;65
000038  2008              MOVS     r0,#8                 ;65
00003a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
00003e  2008              MOVS     r0,#8                 ;68
000040  9000              STR      r0,[sp,#0]            ;68
000042  2000              MOVS     r0,#0                 ;69
000044  f88d0004          STRB     r0,[sp,#4]            ;69
000048  2003              MOVS     r0,#3                 ;70
00004a  f88d0005          STRB     r0,[sp,#5]            ;70
00004e  2000              MOVS     r0,#0                 ;71
000050  f88d0006          STRB     r0,[sp,#6]            ;71
000054  f88d0007          STRB     r0,[sp,#7]            ;72
000058  4669              MOV      r1,sp                 ;73
00005a  4804              LDR      r0,|L1.108|
00005c  f7fffffe          BL       GPIO_Init
000060  bf00              NOP      
000062  e7d2              B        |L1.10|
;;;78     
                          ENDP

                  |L1.100|
                          DCD      s_run_first
                  |L1.104|
                          DCD      g_RA8875_IF
                  |L1.108|
                          DCD      0x40020c00

                          AREA ||i.RA8875_Delaly1ms||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1ms PROC
;;;117    */
;;;118    void RA8875_Delaly1ms(void)
000000  2000              MOVS     r0,#0
;;;119    {
;;;120    	uint16_t i;
;;;121    
;;;122    	for (i = 0; i < 5000; i++);	/* 延迟, 不准 */
000002  e001              B        |L2.8|
                  |L2.4|
000004  1c41              ADDS     r1,r0,#1
000006  b288              UXTH     r0,r1
                  |L2.8|
000008  f2413188          MOV      r1,#0x1388
00000c  4288              CMP      r0,r1
00000e  dbf9              BLT      |L2.4|
;;;123    }
000010  4770              BX       lr
;;;124    
                          ENDP


                          AREA ||i.RA8875_Delaly1us||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1us PROC
;;;102    */
;;;103    void RA8875_Delaly1us(void)
000000  2000              MOVS     r0,#0
;;;104    {
;;;105    	uint8_t i;
;;;106    
;;;107    	for (i = 0; i < 10; i++);	/* 延迟, 不准 */
000002  e001              B        |L3.8|
                  |L3.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L3.8|
000008  280a              CMP      r0,#0xa
00000a  dbfb              BLT      |L3.4|
;;;108    }
00000c  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.RA8875_GetDispMemAddr||, CODE, READONLY, ALIGN=2

                  RA8875_GetDispMemAddr PROC
;;;292    */
;;;293    uint32_t RA8875_GetDispMemAddr(void)
000000  4807              LDR      r0,|L4.32|
;;;294    {
;;;295    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000004  2802              CMP      r0,#2
000006  d101              BNE      |L4.12|
;;;296    	{
;;;297    		return 0;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;298    	}
;;;299    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
;;;300    	{
;;;301    		return RA8875_RAM_ADDR;
;;;302    	}
;;;303    	return 0;
;;;304    }
00000a  4770              BX       lr
                  |L4.12|
00000c  4804              LDR      r0,|L4.32|
00000e  7800              LDRB     r0,[r0,#0]            ;299  ; g_RA8875_IF
000010  2803              CMP      r0,#3                 ;299
000012  d102              BNE      |L4.26|
000014  f04f40d8          MOV      r0,#0x6c000000        ;301
000018  e7f7              B        |L4.10|
                  |L4.26|
00001a  2000              MOVS     r0,#0                 ;303
00001c  e7f5              B        |L4.10|
;;;305    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      g_RA8875_IF

                          AREA ||i.RA8875_HighSpeedSPI||, CODE, READONLY, ALIGN=2

                  RA8875_HighSpeedSPI PROC
;;;411    */
;;;412    void RA8875_HighSpeedSPI(void)
000000  b500              PUSH     {lr}
;;;413    {
000002  b085              SUB      sp,sp,#0x14
;;;414    	SPI_InitTypeDef  SPI_InitStructure;
;;;415    
;;;416    	/* 打开SPI时钟 */
;;;417    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;418    
;;;419    	/* 配置SPI硬件参数 */
;;;420    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;421    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000012  f44f7082          MOV      r0,#0x104
000016  f8ad0002          STRH     r0,[sp,#2]
;;;422    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
00001a  2000              MOVS     r0,#0
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;423    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;424    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;425    	*/
;;;426    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000020  2002              MOVS     r0,#2
000022  f8ad0006          STRH     r0,[sp,#6]
;;;427    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
000026  2001              MOVS     r0,#1
000028  f8ad0008          STRH     r0,[sp,#8]
;;;428    	//SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;			/* 时钟上升沿采样数据 */
;;;429    	//SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;		/* 时钟的第2个边沿采样数据 */	
;;;430    	
;;;431    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
00002c  0240              LSLS     r0,r0,#9
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;432    
;;;433    	/*
;;;434    	
;;;435    		示波器实测频率 (STM32F103ZE 上测试)
;;;436    		SPI_BaudRatePrescaler_4 时， SCK = 18M  (显示正常，触摸不正常)
;;;437    		SPI_BaudRatePrescaler_8 时， SCK = 9M   (显示和触摸都正常)
;;;438    		
;;;439    		F407 的 SP1时钟=84M, 需要 8分频 = 10.5M
;;;440    	*/
;;;441    	
;;;442    	/* 设置波特率预分频系数 */
;;;443    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
000032  2018              MOVS     r0,#0x18
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;444    
;;;445    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000038  2000              MOVS     r0,#0
00003a  f8ad000e          STRH     r0,[sp,#0xe]
;;;446    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
00003e  2007              MOVS     r0,#7
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;447    	SPI_Init(SPI1, &SPI_InitStructure);
000044  4669              MOV      r1,sp
000046  4806              LDR      r0,|L5.96|
000048  f7fffffe          BL       SPI_Init
;;;448    
;;;449    	SPI_Cmd(SPI1, DISABLE);			/* 先禁止SPI  */
00004c  2100              MOVS     r1,#0
00004e  4804              LDR      r0,|L5.96|
000050  f7fffffe          BL       SPI_Cmd
;;;450    
;;;451    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000054  2101              MOVS     r1,#1
000056  4802              LDR      r0,|L5.96|
000058  f7fffffe          BL       SPI_Cmd
;;;452    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd00              POP      {pc}
;;;453    
                          ENDP

                  |L5.96|
                          DCD      0x40013000

                          AREA ||i.RA8875_InitSPI||, CODE, READONLY, ALIGN=2

                  RA8875_InitSPI PROC
;;;315    */
;;;316    void RA8875_InitSPI(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;317    {
;;;318    	/*
;;;319    		安富莱STM32-V5 开发板口线分配：  串行Flash型号为 W25Q64BVSSIG (80MHz)
;;;320    		PB3/SPI3_SCK
;;;321    		PB4/SPI3_MISO
;;;322    		PB5/SPI3_MOSI
;;;323    		PI10/TP_NCS			--- 触摸芯片的片选		(RA8875屏无需SPI接口触摸芯片）
;;;324    
;;;325    		STM32硬件SPI接口 = SPI3 或者 SPI1
;;;326    
;;;327    		由于SPI1的时钟源是84M, SPI3的时钟源是42M。为了获得更快的速度，软件上选择SPI1。
;;;328    	*/
;;;329    	{
;;;330    		GPIO_InitTypeDef GPIO_InitStructure;
;;;331    
;;;332    		/* 使能GPIO 时钟 */
;;;333    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOI, ENABLE);
000002  2101              MOVS     r1,#1
000004  f44f7081          MOV      r0,#0x102
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;334    
;;;335    		/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;336    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI3);
;;;337    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI3);
;;;338    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI3);
;;;339    		/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;340    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
00000c  2205              MOVS     r2,#5
00000e  2103              MOVS     r1,#3
000010  481b              LDR      r0,|L6.128|
000012  f7fffffe          BL       GPIO_PinAFConfig
;;;341    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
000016  2205              MOVS     r2,#5
000018  2104              MOVS     r1,#4
00001a  4819              LDR      r0,|L6.128|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;342    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
000020  2205              MOVS     r2,#5
000022  4611              MOV      r1,r2
000024  4816              LDR      r0,|L6.128|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;343    
;;;344    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00002a  2002              MOVS     r0,#2
00002c  f88d0004          STRB     r0,[sp,#4]
;;;345    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
000030  2001              MOVS     r0,#1
000032  f88d0005          STRB     r0,[sp,#5]
;;;346    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000036  2000              MOVS     r0,#0
000038  f88d0006          STRB     r0,[sp,#6]
;;;347    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00003c  f88d0007          STRB     r0,[sp,#7]
;;;348    
;;;349    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
000040  2038              MOVS     r0,#0x38
000042  9000              STR      r0,[sp,#0]
;;;350    		GPIO_Init(GPIOB, &GPIO_InitStructure);
000044  4669              MOV      r1,sp
000046  480e              LDR      r0,|L6.128|
000048  f7fffffe          BL       GPIO_Init
;;;351    
;;;352    		/* 配置片选口线为推挽输出模式 */
;;;353    		RA8875_CS_1();		/* 片选置高，不选中 */
00004c  f44f6080          MOV      r0,#0x400
000050  490c              LDR      r1,|L6.132|
000052  8308              STRH     r0,[r1,#0x18]
;;;354    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000054  2001              MOVS     r0,#1
000056  f88d0004          STRB     r0,[sp,#4]
;;;355    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00005a  2000              MOVS     r0,#0
00005c  f88d0006          STRB     r0,[sp,#6]
;;;356    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000060  2002              MOVS     r0,#2
000062  f88d0005          STRB     r0,[sp,#5]
;;;357    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000066  2000              MOVS     r0,#0
000068  f88d0007          STRB     r0,[sp,#7]
;;;358    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00006c  1508              ASRS     r0,r1,#20
00006e  9000              STR      r0,[sp,#0]
;;;359    		GPIO_Init(GPIOI, &GPIO_InitStructure);
000070  4669              MOV      r1,sp
000072  4804              LDR      r0,|L6.132|
000074  f7fffffe          BL       GPIO_Init
;;;360    	}
;;;361    	
;;;362    	RA8875_LowSpeedSPI();
000078  f7fffffe          BL       RA8875_LowSpeedSPI
;;;363    }
00007c  bd1c              POP      {r2-r4,pc}
;;;364    
                          ENDP

00007e  0000              DCW      0x0000
                  |L6.128|
                          DCD      0x40020400
                  |L6.132|
                          DCD      0x40022000

                          AREA ||i.RA8875_LowSpeedSPI||, CODE, READONLY, ALIGN=2

                  RA8875_LowSpeedSPI PROC
;;;372    */
;;;373    void RA8875_LowSpeedSPI(void)
000000  b500              PUSH     {lr}
;;;374    {
000002  b085              SUB      sp,sp,#0x14
;;;375    	SPI_InitTypeDef  SPI_InitStructure;
;;;376    
;;;377    	/* 打开SPI时钟 */
;;;378    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;379    
;;;380    	/* 配置SPI硬件参数 */
;;;381    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;382    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000012  f44f7082          MOV      r0,#0x104
000016  f8ad0002          STRH     r0,[sp,#2]
;;;383    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
00001a  2000              MOVS     r0,#0
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;384    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;385    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;386    	*/
;;;387    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000020  2002              MOVS     r0,#2
000022  f8ad0006          STRH     r0,[sp,#6]
;;;388    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
000026  2001              MOVS     r0,#1
000028  f8ad0008          STRH     r0,[sp,#8]
;;;389    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
00002c  0240              LSLS     r0,r0,#9
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;390    
;;;391    	/* 设置波特率预分频系数 */
;;;392    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
000032  2028              MOVS     r0,#0x28
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;393    
;;;394    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000038  2000              MOVS     r0,#0
00003a  f8ad000e          STRH     r0,[sp,#0xe]
;;;395    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
00003e  2007              MOVS     r0,#7
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;396    	SPI_Init(SPI1, &SPI_InitStructure);
000044  4669              MOV      r1,sp
000046  4806              LDR      r0,|L7.96|
000048  f7fffffe          BL       SPI_Init
;;;397    
;;;398    	SPI_Cmd(SPI1, DISABLE);			/* 先禁止SPI  */
00004c  2100              MOVS     r1,#0
00004e  4804              LDR      r0,|L7.96|
000050  f7fffffe          BL       SPI_Cmd
;;;399    
;;;400    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000054  2101              MOVS     r1,#1
000056  4802              LDR      r0,|L7.96|
000058  f7fffffe          BL       SPI_Cmd
;;;401    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd00              POP      {pc}
;;;402    
                          ENDP

                  |L7.96|
                          DCD      0x40013000

                          AREA ||i.RA8875_ReadBusy||, CODE, READONLY, ALIGN=2

                  RA8875_ReadBusy PROC
;;;86     */
;;;87     uint8_t RA8875_ReadBusy(void)
000000  4804              LDR      r0,|L8.20|
;;;88     {
;;;89     	if ((PORT_WAIT->IDR & PIN_WAIT) == 0) 
000002  6800              LDR      r0,[r0,#0]
000004  f0000008          AND      r0,r0,#8
000008  b908              CBNZ     r0,|L8.14|
;;;90     		return 1;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;91     	else 
;;;92     		return 0;
;;;93     }
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0                 ;92
000010  e7fc              B        |L8.12|
;;;94     
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40020c10

                          AREA ||i.RA8875_ReadData||, CODE, READONLY, ALIGN=2

                  RA8875_ReadData PROC
;;;178    */
;;;179    uint8_t RA8875_ReadData(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181    	uint8_t value = 0;
000002  2400              MOVS     r4,#0
;;;182    	
;;;183    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480e              LDR      r0,|L9.64|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d10e              BNE      |L9.42|
;;;184    	{
;;;185    		RA8875_CS_0();
00000c  0240              LSLS     r0,r0,#9
00000e  490d              LDR      r1,|L9.68|
000010  8348              STRH     r0,[r1,#0x1a]
;;;186    		SPI_ShiftByte(SPI_READ_DATA);
000012  2040              MOVS     r0,#0x40
000014  f7fffffe          BL       SPI_ShiftByte
;;;187    		value = SPI_ShiftByte(0x00);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       SPI_ShiftByte
00001e  4604              MOV      r4,r0
;;;188    		RA8875_CS_1();
000020  f44f6080          MOV      r0,#0x400
000024  4907              LDR      r1,|L9.68|
000026  8308              STRH     r0,[r1,#0x18]
000028  e007              B        |L9.58|
                  |L9.42|
;;;189    	}
;;;190    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00002a  4805              LDR      r0,|L9.64|
00002c  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00002e  2803              CMP      r0,#3
000030  d103              BNE      |L9.58|
;;;191    	{
;;;192    		value = RA8875_RAM;		/* 读取寄存器值 */
000032  f04f40d8          MOV      r0,#0x6c000000
000036  8800              LDRH     r0,[r0,#0]
000038  b2c4              UXTB     r4,r0
                  |L9.58|
;;;193    	}
;;;194    
;;;195    	return value;	
00003a  4620              MOV      r0,r4
;;;196    }
00003c  bd10              POP      {r4,pc}
;;;197    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      g_RA8875_IF
                  |L9.68|
                          DCD      0x40022000

                          AREA ||i.RA8875_ReadData16||, CODE, READONLY, ALIGN=2

                  RA8875_ReadData16 PROC
;;;237    */
;;;238    uint16_t RA8875_ReadData16(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240    	uint16_t value;
;;;241    	
;;;242    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  4812              LDR      r0,|L10.76|
000004  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000006  2802              CMP      r0,#2
000008  d117              BNE      |L10.58|
;;;243    	{
;;;244    		RA8875_CS_0();
00000a  0240              LSLS     r0,r0,#9
00000c  4910              LDR      r1,|L10.80|
00000e  8348              STRH     r0,[r1,#0x1a]
;;;245    		SPI_ShiftByte(SPI_READ_DATA);
000010  2040              MOVS     r0,#0x40
000012  f7fffffe          BL       SPI_ShiftByte
;;;246    		value = SPI_ShiftByte(0x00);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI_ShiftByte
00001c  4604              MOV      r4,r0
;;;247    		value <<= 8;
00001e  f64f70ff          MOV      r0,#0xffff
000022  ea002404          AND      r4,r0,r4,LSL #8
;;;248    		value += SPI_ShiftByte(0x00);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       SPI_ShiftByte
00002c  4420              ADD      r0,r0,r4
00002e  b284              UXTH     r4,r0
;;;249    		RA8875_CS_1();
000030  f44f6080          MOV      r0,#0x400
000034  4906              LDR      r1,|L10.80|
000036  8308              STRH     r0,[r1,#0x18]
000038  e006              B        |L10.72|
                  |L10.58|
;;;250    	}
;;;251    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00003a  4804              LDR      r0,|L10.76|
00003c  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00003e  2803              CMP      r0,#3
000040  d102              BNE      |L10.72|
;;;252    	{
;;;253    		value = RA8875_RAM;		/* 读取寄存器值 */
000042  f04f40d8          MOV      r0,#0x6c000000
000046  8804              LDRH     r4,[r0,#0]
                  |L10.72|
;;;254    	}
;;;255    
;;;256    	return value;	
000048  4620              MOV      r0,r4
;;;257    }
00004a  bd10              POP      {r4,pc}
;;;258    
                          ENDP

                  |L10.76|
                          DCD      g_RA8875_IF
                  |L10.80|
                          DCD      0x40022000

                          AREA ||i.RA8875_ReadStatus||, CODE, READONLY, ALIGN=2

                  RA8875_ReadStatus PROC
;;;266    */
;;;267    uint8_t RA8875_ReadStatus(void)
000000  b510              PUSH     {r4,lr}
;;;268    {
;;;269    	uint8_t value = 0;
000002  2400              MOVS     r4,#0
;;;270    	
;;;271    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480d              LDR      r0,|L11.60|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d10e              BNE      |L11.42|
;;;272    	{
;;;273    		RA8875_CS_0();
00000c  0240              LSLS     r0,r0,#9
00000e  490c              LDR      r1,|L11.64|
000010  8348              STRH     r0,[r1,#0x1a]
;;;274    		SPI_ShiftByte(SPI_READ_STATUS);
000012  20c0              MOVS     r0,#0xc0
000014  f7fffffe          BL       SPI_ShiftByte
;;;275    		value = SPI_ShiftByte(0x00);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       SPI_ShiftByte
00001e  4604              MOV      r4,r0
;;;276    		RA8875_CS_1();
000020  f44f6080          MOV      r0,#0x400
000024  4906              LDR      r1,|L11.64|
000026  8308              STRH     r0,[r1,#0x18]
000028  e006              B        |L11.56|
                  |L11.42|
;;;277    	}
;;;278    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00002a  4804              LDR      r0,|L11.60|
00002c  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00002e  2803              CMP      r0,#3
000030  d102              BNE      |L11.56|
;;;279    	{
;;;280    		value = RA8875_REG;
000032  4804              LDR      r0,|L11.68|
000034  8800              LDRH     r0,[r0,#0]
000036  b2c4              UXTB     r4,r0
                  |L11.56|
;;;281    	}
;;;282    	return value;	
000038  4620              MOV      r0,r4
;;;283    }
00003a  bd10              POP      {r4,pc}
;;;284    
                          ENDP

                  |L11.60|
                          DCD      g_RA8875_IF
                  |L11.64|
                          DCD      0x40022000
                  |L11.68|
                          DCD      0x6c080000

                          AREA ||i.RA8875_WriteCmd||, CODE, READONLY, ALIGN=2

                  RA8875_WriteCmd PROC
;;;132    */
;;;133    void RA8875_WriteCmd(uint8_t _ucRegAddr)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480c              LDR      r0,|L12.56|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d10d              BNE      |L12.40|
;;;136    	{
;;;137    		RA8875_CS_0();
00000c  0240              LSLS     r0,r0,#9
00000e  490b              LDR      r1,|L12.60|
000010  8348              STRH     r0,[r1,#0x1a]
;;;138    		SPI_ShiftByte(SPI_WRITE_CMD);
000012  2080              MOVS     r0,#0x80
000014  f7fffffe          BL       SPI_ShiftByte
;;;139    		SPI_ShiftByte(_ucRegAddr);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPI_ShiftByte
;;;140    		RA8875_CS_1();
00001e  f44f6080          MOV      r0,#0x400
000022  4906              LDR      r1,|L12.60|
000024  8308              STRH     r0,[r1,#0x18]
000026  e005              B        |L12.52|
                  |L12.40|
;;;141    	}
;;;142    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000028  4803              LDR      r0,|L12.56|
00002a  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00002c  2803              CMP      r0,#3
00002e  d101              BNE      |L12.52|
;;;143    	{
;;;144    		RA8875_REG = _ucRegAddr;	/* 设置寄存器地址 */
000030  4803              LDR      r0,|L12.64|
000032  8004              STRH     r4,[r0,#0]
                  |L12.52|
;;;145    	}
;;;146    }
000034  bd10              POP      {r4,pc}
;;;147    
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
                          DCD      g_RA8875_IF
                  |L12.60|
                          DCD      0x40022000
                  |L12.64|
                          DCD      0x6c080000

                          AREA ||i.RA8875_WriteData||, CODE, READONLY, ALIGN=2

                  RA8875_WriteData PROC
;;;155    */
;;;156    void RA8875_WriteData(uint8_t _ucRegValue)
000000  b510              PUSH     {r4,lr}
;;;157    {
000002  4604              MOV      r4,r0
;;;158    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480c              LDR      r0,|L13.56|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d10d              BNE      |L13.40|
;;;159    	{
;;;160    		RA8875_CS_0();
00000c  0240              LSLS     r0,r0,#9
00000e  490b              LDR      r1,|L13.60|
000010  8348              STRH     r0,[r1,#0x1a]
;;;161    		SPI_ShiftByte(SPI_WRITE_DATA);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_ShiftByte
;;;162    		SPI_ShiftByte(_ucRegValue);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPI_ShiftByte
;;;163    		RA8875_CS_1();
00001e  f44f6080          MOV      r0,#0x400
000022  4906              LDR      r1,|L13.60|
000024  8308              STRH     r0,[r1,#0x18]
000026  e006              B        |L13.54|
                  |L13.40|
;;;164    	}
;;;165    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000028  4803              LDR      r0,|L13.56|
00002a  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00002c  2803              CMP      r0,#3
00002e  d102              BNE      |L13.54|
;;;166    	{
;;;167    		RA8875_RAM = _ucRegValue;	/* 设置寄存器地址 */
000030  f04f40d8          MOV      r0,#0x6c000000
000034  8004              STRH     r4,[r0,#0]
                  |L13.54|
;;;168    	}
;;;169    }
000036  bd10              POP      {r4,pc}
;;;170    
                          ENDP

                  |L13.56|
                          DCD      g_RA8875_IF
                  |L13.60|
                          DCD      0x40022000

                          AREA ||i.RA8875_WriteData16||, CODE, READONLY, ALIGN=2

                  RA8875_WriteData16 PROC
;;;205    */
;;;206    void RA8875_WriteData16(uint16_t _usRGB)
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  4604              MOV      r4,r0
;;;208    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  4813              LDR      r0,|L14.84|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d11a              BNE      |L14.66|
;;;209    	{
;;;210    		RA8875_CS_0();
00000c  0240              LSLS     r0,r0,#9
00000e  4912              LDR      r1,|L14.88|
000010  8348              STRH     r0,[r1,#0x1a]
;;;211    		SPI_ShiftByte(SPI_WRITE_DATA);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_ShiftByte
;;;212    		SPI_ShiftByte(_usRGB >> 8);
000018  1220              ASRS     r0,r4,#8
00001a  f7fffffe          BL       SPI_ShiftByte
;;;213    		RA8875_CS_1();
00001e  f44f6080          MOV      r0,#0x400
000022  490d              LDR      r1,|L14.88|
000024  8308              STRH     r0,[r1,#0x18]
;;;214    		
;;;215    		/* 必须增加一些延迟，否则连续写像素可能出错 */
;;;216    		RA8875_CS_1();
000026  8308              STRH     r0,[r1,#0x18]
;;;217    		RA8875_CS_1();
000028  8308              STRH     r0,[r1,#0x18]
;;;218    		
;;;219    		RA8875_CS_0();
00002a  8348              STRH     r0,[r1,#0x1a]
;;;220    		SPI_ShiftByte(SPI_WRITE_DATA);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SPI_ShiftByte
;;;221    		SPI_ShiftByte(_usRGB);
000032  b2e0              UXTB     r0,r4
000034  f7fffffe          BL       SPI_ShiftByte
;;;222    		RA8875_CS_1();
000038  f44f6080          MOV      r0,#0x400
00003c  4906              LDR      r1,|L14.88|
00003e  8308              STRH     r0,[r1,#0x18]
000040  e006              B        |L14.80|
                  |L14.66|
;;;223    	}
;;;224    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000042  4804              LDR      r0,|L14.84|
000044  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000046  2803              CMP      r0,#3
000048  d102              BNE      |L14.80|
;;;225    	{
;;;226    		RA8875_RAM = _usRGB;	/* 设置寄存器地址 */
00004a  f04f40d8          MOV      r0,#0x6c000000
00004e  8004              STRH     r4,[r0,#0]
                  |L14.80|
;;;227    	}
;;;228    }
000050  bd10              POP      {r4,pc}
;;;229    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      g_RA8875_IF
                  |L14.88|
                          DCD      0x40022000

                          AREA ||i.SPI_ShiftByte||, CODE, READONLY, ALIGN=2

                  SPI_ShiftByte PROC
;;;461    */
;;;462    static uint8_t SPI_ShiftByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;463    {
000002  4604              MOV      r4,r0
;;;464    	uint8_t ucRxByte;
;;;465    
;;;466    	/* 等待发送缓冲区空 */
;;;467    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L15.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L15.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L15.6|
;;;468    
;;;469    	/* 发送一个字节 */
;;;470    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L15.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;471    
;;;472    	/* 等待数据接收完毕 */
;;;473    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L15.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L15.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L15.28|
;;;474    
;;;475    	/* 读取接收到的数据 */
;;;476    	ucRxByte = SPI_I2S_ReceiveData(SPI1);
000028  4802              LDR      r0,|L15.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c5              UXTB     r5,r0
;;;477    
;;;478    	/* 返回读到的数据 */
;;;479    	return ucRxByte;
000030  4628              MOV      r0,r5
;;;480    }
000032  bd70              POP      {r4-r6,pc}
;;;481    
                          ENDP

                  |L15.52|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  g_RA8875_IF
000000  03                DCB      0x03
                  s_run_first
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_ra8875_port.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_ra8875_port_c_9d513f85____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_ra8875_port_c_9d513f85____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_ra8875_port_c_9d513f85____REVSH|
#line 144
|__asm___17_bsp_ra8875_port_c_9d513f85____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_ra8875_port_c_9d513f85____RRX|
#line 300
|__asm___17_bsp_ra8875_port_c_9d513f85____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
